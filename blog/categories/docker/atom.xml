<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Docker | Mon blog perso.]]></title>
  <link href="http://mcamuzat.github.io/blog/categories/docker/atom.xml" rel="self"/>
  <link href="http://mcamuzat.github.io/"/>
  <updated>2015-07-26T17:08:34+02:00</updated>
  <id>http://mcamuzat.github.io/</id>
  <author>
    <name><![CDATA[mcamuzat]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Mise en Place De Travis]]></title>
    <link href="http://mcamuzat.github.io/blog/2015/07/25/mise-en-place-de-travis/"/>
    <updated>2015-07-25T16:37:49+02:00</updated>
    <id>http://mcamuzat.github.io/blog/2015/07/25/mise-en-place-de-travis</id>
    <content type="html"><![CDATA[<h2>Introduction</h2>

<p>Après la création de la <a href="/blog/2015/07/19/histogramme-et-ligne-de-commande/">librairie</a>, la création et la publication du <a href="blog/2015/07/24/creer-son-depot-sous-packagist/">package</a>, je propose d&#8217;ajouter l&#8217;intégration continue avec Travis. Travis est gratuit pour les projets open-source. (L&#8217;url n&#8217;est d&#8217;ailleurs pas la même c&#8217;est travis-ci.org pour les projets publics, et travis-ci.com pour les projets privés)</p>

<h2>L&#8217;intégration continue.</h2>

<p>Il faut bien entendu s&#8217;inscrire sur Travis. On s&#8217;authentifie grâce à son identifiant github.</p>

<p>Nous allons rajouter le fichier <code>.travis.yml</code> dans notre dépôt.</p>

<pre><code class="yml">language: php
install: composer install
php:
  - 5.4
  - 5.5
  - 5.6
  - hhvm
  - nightly
</code></pre>

<p>Quand je synchronise mes dépôts. Il suffit de cliquer sur le slider pour activé l&#8217;intégration continue.</p>

<p><img class="center" src="/images/travis_choice.png" width="600" height="234" title="&lsquo;Activer l'intégration continue&rsquo; &lsquo;Activée l'intégration continue&rsquo;" ></p>

<p>On peux lire les logs, d&#8217;ailleurs on se rend compte que travis utilise Docker</p>

<p><img class="center" src="/images/travis_log.png" width="600" height="405" title="&lsquo;Log de travis&rsquo; &lsquo;Log de travis&rsquo;" ></p>

<p>et voici le résultat</p>

<p><img class="center" src="/images/travis_depot.png" width="600" height="320" title="&lsquo;Dashboard du projet&rsquo; &lsquo;Dashboard du projet&rsquo;" ></p>

<p>A chaque commit je lance un build. J&#8217;ai vraiment été très surpris par la simplicité de la mise en œuvre.</p>

<h2>En conclusion</h2>

<p>On peux lancer un build sans passer par travis grâce à docker et <a href="https://github.com/jolicode/JoliCi">JoliCi</a>, Voir ce <a href="blog/2015/04/18/dockers-et-ci/">post</a> à la fin</p>

<p>Dans le prochain article, nous allons parler de CodeSniffer.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Go Introduction]]></title>
    <link href="http://mcamuzat.github.io/blog/2015/05/10/go-introduction/"/>
    <updated>2015-05-10T18:21:31+02:00</updated>
    <id>http://mcamuzat.github.io/blog/2015/05/10/go-introduction</id>
    <content type="html"><![CDATA[<h2>Introduction</h2>

<p>J&#8217;ai regardé Docker. Docker est en Go ainsi que pas mal de projets en fait. J&#8217;ai donc décidé d&#8217;essayer.</p>

<p>Dans ce chapitre nous n&#8217;allons pas trop discuter du langage mais surtout mettre en place tout les outils.</p>

<h2>Installation(linux)</h2>

<ul>
<li><p>Nous allons télécharger les fichiers <a href="https://golang.org/dl/">ici</a></p></li>
<li><p>On décompresse le fichier
<code>bash
sudo tar -C /usr/local -xzf go1.4.2.linux-amd64.tar.gz
</code></p></li>
</ul>


<p>Créer un répertoire go dans votre <code>/usr/local</code></p>

<ul>
<li>enfin il faut l&#8217;ajouter à votre <code>$PATH</code> en modifiant le <code>.profile</code></li>
</ul>


<pre><code>export PATH=$PATH:/usr/local/go/bin
</code></pre>

<ul>
<li>testons dans notre ligne de commande.</li>
</ul>


<pre><code>$ go version
go version go1.4.2 linux/amd64
</code></pre>

<h2>Hello world !</h2>

<p>Ouvrons un fichier <code>hello.go</code></p>

<pre><code class="go">package main

import "fmt"

func main() {
    fmt.Printf("hello, world\n")
}
</code></pre>

<p>Pour l&#8217;exécuter
<code>sh
go run hello.go
hello, world
</code></p>

<p>Tout va bien ! Nous avons installé Go</p>

<h2>Organisation d&#8217;un projet</h2>

<p>L&#8217;organisation d&#8217;un projet sous Go est fixe ! Comprendre qu&#8217;il faut un <strong>workspace</strong></p>

<p>Nous allons ensemble créer le projet <code>Hello</code></p>

<ul>
<li><p>Créer un répertoire <code>go</code></p></li>
<li><p>Assigner la variable d&#8217;environnement <code>$GOPATH</code></p></li>
</ul>


<pre><code> export GOPATH=$HOME/go
</code></pre>

<ul>
<li><p>enfin rajouter le $GOPATH/bin dans le PATH
<code>
export PATH=$PATH:$GOPATH/bin
</code></p></li>
<li><p>Nous voulons sauvegarder notre code quelques part. ici github!
<code>
mkdir -p $GOPATH/src/github.com/&lt;votreusername&gt;/hello
</code></p></li>
</ul>


<p>Votre <code>username</code> est votre namespace pour les packages (un peu comme java).</p>

<ul>
<li><p>dans notre répertoire <code>src/github.com/&lt;votreusername&gt;/hello</code> nous allons copier notre <code>hello.go</code></p></li>
<li><p>Tout est en place. Il n&#8217;y a plus qu&#8217;a taper <code>go install github.com/user/hello</code>.</p></li>
<li><p>autre possibilité se rendre dans le répertoire <code>src/github.com/&lt;votreusername&gt;/hello</code>
<code>bash
go install
</code></p></li>
<li><p>Nous pouvons vérifier que dans le répertoire <code>$HOME/go</code> il y a un dossier <code>bin/</code>
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$GOPATH/bin/hello
</span><span class='line'>hello world&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h1&gt;de manière plus simple puisque nous avons ajouter dans le path $GOPATH/bin&lt;/h1&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;hello
</span><span class='line'>hello world</span></code></pre></td></tr></table></div></figure>
voici la structure finale</p></li>
</ul>


<pre><code>.
├── bin
│   └── hello
└── src
    └── github.com
        └── mcamuzat
            └── hello
                ├── hello.go
                ├── LICENSE
                └── README.md
</code></pre>

<h2>Sauvegarde d&#8217;un projet</h2>

<p>Nous allons sauvegarder celui-ci sous <a href="https://github.com/">Github</a>. Ce n&#8217;est pas obligatoire.
<code>
cd $GOPATH/src/github.com/user/hello
git init
git add .
git commit -m"create project"
</code></p>

<p>Sous github, j&#8217;ai crée un nouveau repository <code>hello-go</code></p>

<pre><code>git remote add origin git@github.com:mcamuzat/hello-go.git
git pull --rebase
git push origin master
</code></pre>

<h2>Conclusion</h2>

<p>Nous avons d&#8217;installer Go.</p>

<p>Je viens juste de m&#8217;y mettre, Je ne sais pas encore ce que la suite nous réserve..</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Docker-machine]]></title>
    <link href="http://mcamuzat.github.io/blog/2015/05/09/docker-machine/"/>
    <updated>2015-05-09T18:29:45+02:00</updated>
    <id>http://mcamuzat.github.io/blog/2015/05/09/docker-machine</id>
    <content type="html"><![CDATA[<h2>Introduction</h2>

<p>Nous allons voir <a href="https://docs.docker.com/machine/">docker-machine</a>. Docker-machine permet de simplifier l&#8217;installation/gestion/déploiement de Docker.</p>

<h2>Installation</h2>

<p>Tout d&#8217;abord il faut connaitre votre architecture <code>x86_64</code>ou <code>i386</code>.</p>

<p>La commande classique est <code>uname -a</code>.</p>

<p>Puis télécharger l&#8217;exécutable via <code>curl</code></p>

<p>Sous linux.
<code>bash
curl -L https://github.com/docker/machine/releases/download/v0.2.0/docker-machine_linux-amd64 &gt; docker-machine
sudo mv docker-machine /usr/local/bin/docker-machine
</code></p>

<p>Puis le marquer comme exécutable.
<code>bash
sudo chmod +x /usr/local/bin/docker-machine
</code></p>

<p>Testons notre application.
<code>bash
docker-machine -v
</code></p>

<p>Enfin vous avez besoin d&#8217;avoir <a href="https://www.virtualbox.org/wiki/Downloads">Virtual-Box</a></p>

<h2>Mise en route.</h2>

<p>Voici la commande pour tout lancer</p>

<pre><code class="bash">docker-machine create --driver virtualbox dev
</code></pre>

<p>Cette ligne demande à docker-machine de créer une environnement que l&#8217;on appelle <strong>dev</strong> qui sera sur Virtual-box.
docker-machine va télécharger une iso (boot2docker) contenant docker. Et lancer Virtualbox.</p>

<p>Jusqu&#8217;à maintenant on avait installé docker sur notre ordi local.
Ici on installe docker sur une VM.
Toutes les commandes seront passer de manière transparente à la machine virtuelle.
L&#8217;avantage de cette méthode est que tout le monde utilise la même iso virtuelle (boot2docker). Il n&#8217;y a moins le risque du &ldquo;chez moi ça marche&rdquo; qui est une remarque au combien rageante.</p>

<p>Je veux travailler sur mon environnement de dev</p>

<pre><code>eval "$(docker-machine env dev)"
</code></pre>

<p>Toutes mes commandes sont directement envoyées sur la vm à distance
<code>
docker run busybox echo hello
</code></p>

<p>Je peux rajouter un environnement (ici <strong>prod</strong>)
<code>
docker-machine create --driver amazon prod --les options qui vont bien..
</code></p>

<p>Il suffit de changer l&#8217;environnement pour automatiquement déployer sur Amazon.
<code>
eval "$(docker-machine env prod)"
</code></p>

<p>Plein de drivers sont fournis:</p>

<ul>
<li><a href="https://docs.docker.com/machine/#amazon-web-services">Amazon Web Services</a></li>
<li><a href="https://docs.docker.com/machine/#digital-ocean">Digital Ocean</a></li>
<li><a href="https://docs.docker.com/machine/#google-compute-engine">Google Compute Engine</a></li>
<li><a href="https://docs.docker.com/machine/#ibm-softlayer">IBM Softlayer</a></li>
<li><a href="https://docs.docker.com/machine/#microsoft-azure">Microsoft Azure</a></li>
<li><a href="https://docs.docker.com/machine/#microsoft-hyper-v">Microsoft Hyper-V</a></li>
<li><a href="https://docs.docker.com/machine/#openstack">Openstack</a></li>
<li><a href="https://docs.docker.com/machine/#rackspace">Rackspace</a></li>
<li><a href="https://docs.docker.com/machine/#oracle-virtualbox">Oracle VirtualBox</a></li>
<li><a href="https://docs.docker.com/machine/#vmware-fusion">VMware Fusion</a></li>
<li><a href="https://docs.docker.com/machine/#vmware-vcloud-air">VMware vCloud Air</a></li>
<li><a href="https://docs.docker.com/machine/#vmware-vsphere">VMware vSphere</a></li>
</ul>


<h2>L&#8217;avantage de docker-machine</h2>

<ul>
<li>Simplifie l&#8217;installation. il n&#8217;y a que docker-machine à installer. Arès docker-machine s&#8217;occupe de tout installer. (il installe docker sur un vm/instance)</li>
<li>Simplifie le déploiement, il suffit de changer l&#8217;environnement</li>
<li>Enfin il s&#8217;interface avec docker-swarm (qui permet de gérer plusieurs nodes de Dockers).</li>
</ul>


<h2>En conclusion</h2>

<p>Le slogan &ldquo;a way to get from zero to Docker&rdquo; est plutôt juste.</p>

<ul>
<li>Cela simplifie beaucoup l&#8217;installation sous windows (pas testé :-)).</li>
<li>Et harmonise les environnements de dev (tout le monde utilise la même iso)</li>
<li>Facilite le déploiement. Il n&#8217;y a pas a se soucier si c&#8217;est du Amazon/OpenStack/Azure..</li>
</ul>


<p>Dans un prochain post nous allons essayer de voir docker-swarm.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Docker-compose]]></title>
    <link href="http://mcamuzat.github.io/blog/2015/05/03/docker-compose/"/>
    <updated>2015-05-03T21:33:31+02:00</updated>
    <id>http://mcamuzat.github.io/blog/2015/05/03/docker-compose</id>
    <content type="html"><![CDATA[<h2>Docker-compose</h2>

<p>Dans le post précèdent sur docker, j&#8217;avais expliqué comment automatiser la création des containers grâce au <code>Dockerfile</code> aujourd&#8217;hui je vais expliquer <code>docker-compose</code></p>

<h2>Intro.</h2>

<p>Dans un projet, il n&#8217;y a rarement qu&#8217;une seule instance. Voir il peut y avoir plusieurs fronts et une seule base de donnée. docker-compose est la justement pour organiser cela.</p>

<p>Par exemple le <code>docker-compose.yml</code> suivant:</p>

<pre><code class="yml">web:
  image: php:5.6-apache
  links:
    - db:db
  volumes:
    - .:/var/www/html

db:
  image: postgres
</code></pre>

<p>On déclare deux type de containers le container type <strong>web</strong> et le container de type <strong>db</strong>. à noter la ligne <code>links</code> qui fait que le container web partage/vois le container db</p>

<p>Il suffit de faire <code>docker-compose up</code> (comme un <code>vagrant up</code>)  pour automatiquement lancer deux containers. un container web avec une image php-5.6, et un container avec PostGresSQL</p>

<h2>Installation</h2>

<p>Il existe deux façons de l&#8217;installer soit passer par <code>pip</code> (pip est l&#8217;équivalent de <code>npm</code> pour le python).</p>

<pre><code class="bash">sudo pip install -U docker-compose
</code></pre>

<p>Ou de passer par curl</p>

<pre><code class="bash">curl -L https://github.com/docker/compose/releases/download/1.2.0/docker-compose-`uname -s`-`uname -m` &gt; /usr/local/bin/docker-compose
chmod +x /usr/local/bin/docker-compose
</code></pre>

<h2>Quelques commandes</h2>

<p>Lancer les containers en mode démon (<code>-d</code>)</p>

<pre><code>docker-compose up -d
</code></pre>

<p>Cela crée deux containers</p>

<p>Que l&#8217;on peux surveiller grâce à la commande suivante
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>docker-compose ps&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;Name                   Command               State    Ports   
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;hr /&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;compose_db_1    /docker-entrypoint.sh postgres   Up      5432/tcp
</span><span class='line'>compose_web_1   apache2-foreground               Up      80/tcp&lt;br/&gt;</span></code></pre></td></tr></table></div></figure></p>

<p>On peux voir les logs
<code>
docker-compose logs
</code></p>

<p>Plus intéressant on peux rajouter des containers..</p>

<pre><code>docker-compose scale web=3
Creating compose_web_2...
Creating compose_web_3...
Starting compose_web_2...
Starting compose_web_3...
</code></pre>

<p>Si je re-liste mes containers
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>docker-compose ps&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;Name                   Command               State    Ports   
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;hr /&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;compose_db_1    /docker-entrypoint.sh postgres   Up      5432/tcp
</span><span class='line'>compose_web_1   apache2-foreground               Up      80/tcp &lt;br/&gt;
</span><span class='line'>compose_web_2   apache2-foreground               Up      80/tcp &lt;br/&gt;
</span><span class='line'>compose_web_3   apache2-foreground               Up      80/tcp</span></code></pre></td></tr></table></div></figure></p>

<p>Je viens de multiplier par 3 le nombre de container en une simple commande et sans stopper le système.</p>

<h2>Conclusion</h2>

<p>Si vous n&#8217;avez qu&#8217;un seul container docker-compose ne sert pas à grand chose. Mais si vous avez plusieurs containers. Cela ne vaux pas la peine de se priver. Docker-compose contient en fait la liste des container ainsi que leurs configurations si on devait les lancers en la ligne de commande.</p>

<p>Dans le prochain post sur docker, je vais tenter <code>docker-machine</code>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Awesome Et Liste De Liens]]></title>
    <link href="http://mcamuzat.github.io/blog/2015/04/29/awesome-et-liste-de-liens/"/>
    <updated>2015-04-29T22:15:34+02:00</updated>
    <id>http://mcamuzat.github.io/blog/2015/04/29/awesome-et-liste-de-liens</id>
    <content type="html"><![CDATA[<h2>Introduction</h2>

<p>Les développeurs aiment les liens. Il y a toujours un article à partager et/ou sauvegarder. Pour les sauvegarder, Personnelement j&#8217;utilisai un fichier texte ou j&#8217;ajoutai en favori dans mon navigateur (avec plus ou moins de bonheur au moment du changement d&#8217;ordinateur). Des gens ont décidé de versionner leurs listes de liens sur Github.  Cela s&#8217;appelle  <strong>Awesome</strong>-(la techno ou le thème que vous vous voulez)</p>

<p>par exemple:</p>

<ul>
<li>PHP : <a href="https://github.com/ziadoz/awesome-php">awesome-php</a></li>
<li>Symfony2 : <a href="https://github.com/EmanueleMinotto/awesome-symfony2">awesome-symfony2</a></li>
<li>Docker : <a href="https://github.com/veggiemonk/awesome-docker">awesome-docker</a></li>
<li>Les meilleurs cours en ligne : <a href="https://github.com/prakhar1989/awesome-courses">awesome-courses</a></li>
<li>React : <a href="https://github.com/enaqx/awesome-react">awesome-react</a></li>
<li>Sysadmin: <a href="https://github.com/kahun/awesome-sysadmin">awesome-sysadmin</a></li>
<li>Web Performance Optimization:<a href="https://github.com/davidsonfellipe/awesome-wpo">awesome-wpo</a></li>
<li>etc ..</li>
</ul>


<h2>Des listes qui contiennent des listes.</h2>

<p>Ben oui la liste est longue. C&#8217;est pour cela qu&#8217;il existe une awesome-list de awesome</p>

<ul>
<li><a href="https://github.com/bayandin/awesome-awesomeness">awesome-awesomeness</a></li>
</ul>


<h2>Une conclusion</h2>

<p>Si vous cherchez à vous former dans une techno, je crois que vous savez par où commencer.</p>
]]></content>
  </entry>
  
</feed>
