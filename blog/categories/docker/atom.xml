<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Docker | Mon blog perso.]]></title>
  <link href="http://mcamuzat.github.io/blog/categories/docker/atom.xml" rel="self"/>
  <link href="http://mcamuzat.github.io/"/>
  <updated>2015-11-02T23:20:28+01:00</updated>
  <id>http://mcamuzat.github.io/</id>
  <author>
    <name><![CDATA[mcamuzat]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[PHP Code Sniffer Mise en Place]]></title>
    <link href="http://mcamuzat.github.io/blog/2015/08/01/php-code-sniffer-mise-en-place/"/>
    <updated>2015-08-01T18:33:12+02:00</updated>
    <id>http://mcamuzat.github.io/blog/2015/08/01/php-code-sniffer-mise-en-place</id>
    <content type="html"><![CDATA[<h2>Qualité de code et php</h2>

<p>Dans ce post nous allons voir les logiciels qui permettent de respecter les standards de code en PHP.</p>

<p>En pratique il n&#8217;y en a que 2.</p>

<ul>
<li><a href="https://github.com/squizlabs/PHP_CodeSniffer">CodeSniffer</a></li>
<li><a href="http://cs.sensiolabs.org/">PHP Coding Standards Fixer</a></li>
</ul>


<h2>CodeSniffer</h2>

<p>Il y a différentes normes de codage :  les plus connus sont la <a href="http://www.php-fig.org/psr/psr-1/">psr-1</a> et la <a href="http://www.php-fig.org/psr/psr-2/">psr-2</a>. La psr-2 hérite de la psr-1. Mais certain Framework ont leur propres méthodes d&#8217;indentations. On peux personnaliser d&#8217;ailleurs les différentes règles. Les gouts et les couleurs de chacun sur le code est subjectif. L&#8217;intérêt de suivre les recommandations est que cela dépassionne le débat. Cela passe CodeSniffer ou cela ne passe pas. Pour participer au projet Open-source, il faut suivre la norme.</p>

<p>La norme est pointilleuse sur les commentaires aussi. Si pas de commentaire pas de validation. On est quasiment forcer d&#8217;écrire la documentation. Cela a parfois un effet pervers ou le programmeur remplit sans trop réfléchir pour faire passer code sniffer.</p>

<p>Très souvent on ajoute un <em>hook</em> sur les commits de git. Lorsque on commite, git déclenche le logiciel, si un des fichiers n&#8217;est pas valide CodeSniffer on refuse de commiter. C&#8217;est assez peu contraignant quand la codebase est déjà indentée. (quoique parfois cela tombe vraiment au mauvais moment).En général on vérifie seulement sur les fichiers modifiés. Re-indenter tout le projet est souvent trop compliqué, trop long et un peu suicidaire si vous avez des rebases et des merges.</p>

<h2>Installation de CodeSniffer</h2>

<p>Deux possibilités</p>

<h3>Dans le projet</h3>

<p>via une dépendance au projet en l&#8217;ajoutant dans le <code>composer.json</code></p>

<pre><code class="json">{
    "require-dev": {
        "squizlabs/php_codesniffer": "2.*"
    }
}
</code></pre>

<p>Alors dans le projet
<code>sh
./vendor/bin/phpcs -h
</code></p>

<p>Personnellement je définie toujours un répertoire <code>bin</code> par défaut</p>

<pre><code class="json">    "config": {
        "bin-dir": "bin"
    },
</code></pre>

<p>Ainsi la commande précédente devient</p>

<pre><code class="sh">bin/phpcs 
</code></pre>

<h3>Installation globale</h3>

<p>Soit l&#8217;installer de manière globale</p>

<pre><code>composer global require "squizlabs/php_codesniffer=*"
</code></pre>

<p>Attention si vous utilisez Composer de manière globale ne pas oublier de rajouter dans votre <code>$PATH</code>
<code>
export PATH=~/.composer/vendor/bin:$PATH
</code></p>

<h3>Ajoutez les reglès symfony</h3>

<p>par défaut phpcs vient avec les règles suivantes</p>

<ul>
<li><a href="http://www.php-fig.org/psr/psr-1/">psr-1</a></li>
<li><a href="http://www.php-fig.org/psr/psr-2/">psr-2</a></li>
<li><a href="https://github.com/squizlabs/PHP_CodeSniffer/tree/master/CodeSniffer/Standards/Squiz">Squiz</a></li>
<li><a href="http://framework.zend.com/manual/1.12/fr/coding-standard.html">Zend</a></li>
<li><a href="https://pear.php.net/manual/en/standards.php">Pear</a></li>
<li><a href="https://github.com/squizlabs/PHP_CodeSniffer/tree/master/CodeSniffer/Standards/PHPCS">Phpcs</a></li>
</ul>


<p>Il manque Symfony..</p>

<p>Voici une méthode simple (mais pas la méthode officielle) si vous voulez l&#8217;installer de manière globale. Je rajoute dans le répertoire <code>Standards</code> un répertoire <code>Symfony2</code></p>

<pre><code>$ composer global require "squizlabs/php_codesniffer=*"
$ cd ~/.composer/vendor/squizlabs/php_codesniffer/CodeSniffer/Standards
$ git clone git@github.com:escapestudios/Symfony2-coding-standard.git Symfony2
</code></pre>

<p>On vérifie que les règles symfony2 sont bien installées</p>

<pre><code>phpcs -i
</code></pre>

<p>Symfony2 en défaut. Ainsi pas besoin de préciser <code>--standard=Symfony2</code></p>

<pre><code>phpcs --config-set default_standard Symfony2
</code></pre>

<h3>Php-cbf</h3>

<p>Code sniffer est capable de corriger certaines fautes tout seul. Encore une fois essayer de faire au fur et à mesure. Le commit d&#8217;indentation avec 500 fichiers modifiés est un calvaire à gérer si vous faite des revues de codes ou pire un rebase.</p>

<p>La syntaxe est la même que phpcs.
<code>
php-cbf src/
</code></p>

<h2>Php-cs-fixer</h2>

<p>Écris par <a href="http://sensiolabs.com/">Sensio</a> les créateurs de <a href="http://symfony.com/">Symfony</a>. Ce logiciel fixe automatiquement l&#8217;indentation et différentes règles. L&#8217;avantage est qu&#8217;il est simple à installer pas besoin de cloner d&#8217;autre dépôt.</p>

<h2>Avoir tout les outils via docker.</h2>

<p>J&#8217;ai déjà présenté les différentes méthodes avec <a href="https://github.com/jolicode/docker-images/tree/master/languages/php/phaudit">phaudit</a> ans cette article <a href="/blog/2015/04/18/dockers-et-ci/">ici</a></p>

<h2>Méthode par rapport à git</h2>

<p>Pour lancer une vérification avant chaque commit
Il suffit de créer un fichier <code>pre-commit.sh</code> dans le répertoire <code>.git/hook</code>. Il y a plein d&#8217;exemples sur le net. Je n&#8217;ai pas d&#8217;exemple à partager. Le code ne m&#8217;appartient plus..</p>

<h2>Installation sous VIM.</h2>

<p>C&#8217;est très simple Il faut installer le plugin <a href="https://github.com/scrooloose/syntastic">syntastic</a>. C&#8217;est un plugin qui gère un peu près tout les formats possibles.</p>

<p>Code-sniffer doit être installé de manière <strong>globale</strong></p>

<p>Il suffit de rajouter cette ligne dans votre <code>.vimrc</code></p>

<pre><code>let g:syntastic_php_checkers=['php', 'phpcs']
</code></pre>

<p>A chaque fois que l&#8217;on enregistre le fichier, le plugin lance automatiquement d&#8217;abord <code>php</code> pour vérifier que le fichier est valide, puis <code>phpcs</code>.</p>

<p>Le résultat est très intuitif on a une flèche <code>&gt;</code> à chaque ligne qui pose problème. Il suffit de passer le curseur pour connaitre l&#8217;erreur. Enfin un screenshot sera plus clair.</p>

<p><img class="center" src="/images/syntastic.png" width="600" height="212" title="&lsquo;Screenshot de syntastic&rsquo; &lsquo;syntastic&rsquo;" ></p>

<h2>Conclusion</h2>

<p>Respecter la norme psr-2 ou autre n&#8217;est pas très compliqué, avec l&#8217;habitude c&#8217;est même plutôt facile. Il est plus facile de d&#8217;intervenir sur un code propre. Sur la mise en place, on a vu qu&#8217;il y a deux possibilités soit des warning dans le code soit une correction automatique. Je ne suis pas <em>fan</em> pas la correction automatique. Je ne veux pas que le logiciel prennent des décisions pour moi.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Mise en Place De Travis]]></title>
    <link href="http://mcamuzat.github.io/blog/2015/07/25/mise-en-place-de-travis/"/>
    <updated>2015-07-25T16:37:49+02:00</updated>
    <id>http://mcamuzat.github.io/blog/2015/07/25/mise-en-place-de-travis</id>
    <content type="html"><![CDATA[<h2>Introduction</h2>

<p>Après la création de la <a href="/blog/2015/07/19/histogramme-et-ligne-de-commande/">librairie</a>, la création et la publication du <a href="blog/2015/07/24/creer-son-depot-sous-packagist/">package</a>, je propose d&#8217;ajouter l&#8217;intégration continue avec Travis. Travis est gratuit pour les projets open-source. (L&#8217;url n&#8217;est d&#8217;ailleurs pas la même c&#8217;est travis-ci.org pour les projets publics, et travis-ci.com pour les projets privés)</p>

<h2>L&#8217;intégration continue.</h2>

<p>Il faut bien entendu s&#8217;inscrire sur Travis. On s&#8217;authentifie grâce à son identifiant github.</p>

<p>Nous allons rajouter le fichier <code>.travis.yml</code> dans notre dépôt.</p>

<pre><code class="yml">language: php
install: composer install
php:
  - 5.4
  - 5.5
  - 5.6
  - hhvm
  - nightly
</code></pre>

<p>Quand je synchronise mes dépôts. Il suffit de cliquer sur le slider pour activé l&#8217;intégration continue.</p>

<p><img class="center" src="/images/travis_choice.png" width="600" height="234" title="&lsquo;Activer l'intégration continue&rsquo; &lsquo;Activée l'intégration continue&rsquo;" ></p>

<p>On peux lire les logs, d&#8217;ailleurs on se rend compte que travis utilise Docker</p>

<p><img class="center" src="/images/travis_log.png" width="600" height="405" title="&lsquo;Log de travis&rsquo; &lsquo;Log de travis&rsquo;" ></p>

<p>et voici le résultat</p>

<p><img class="center" src="/images/travis_depot.png" width="600" height="320" title="&lsquo;Dashboard du projet&rsquo; &lsquo;Dashboard du projet&rsquo;" ></p>

<p>A chaque commit je lance un build. J&#8217;ai vraiment été très surpris par la simplicité de la mise en œuvre.</p>

<h2>En conclusion</h2>

<p>On peux lancer un build sans passer par travis grâce à docker et <a href="https://github.com/jolicode/JoliCi">JoliCi</a>, Voir ce <a href="blog/2015/04/18/dockers-et-ci/">post</a> à la fin</p>

<p>Dans le prochain article, nous allons parler de CodeSniffer.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Go Introduction]]></title>
    <link href="http://mcamuzat.github.io/blog/2015/05/10/go-introduction/"/>
    <updated>2015-05-10T18:21:31+02:00</updated>
    <id>http://mcamuzat.github.io/blog/2015/05/10/go-introduction</id>
    <content type="html"><![CDATA[<h2>Introduction</h2>

<p>J&#8217;ai regardé Docker. Docker est en Go ainsi que pas mal de projets en fait. J&#8217;ai donc décidé d&#8217;essayer.</p>

<p>Dans ce chapitre nous n&#8217;allons pas trop discuter du langage mais surtout mettre en place tout les outils.</p>

<h2>Installation(linux)</h2>

<ul>
<li><p>Nous allons télécharger les fichiers <a href="https://golang.org/dl/">ici</a></p></li>
<li><p>On décompresse le fichier
<code>bash
sudo tar -C /usr/local -xzf go1.4.2.linux-amd64.tar.gz
</code></p></li>
</ul>


<p>Créer un répertoire go dans votre <code>/usr/local</code></p>

<ul>
<li>enfin il faut l&#8217;ajouter à votre <code>$PATH</code> en modifiant le <code>.profile</code></li>
</ul>


<pre><code>export PATH=$PATH:/usr/local/go/bin
</code></pre>

<ul>
<li>testons dans notre ligne de commande.</li>
</ul>


<pre><code>$ go version
go version go1.4.2 linux/amd64
</code></pre>

<h2>Hello world !</h2>

<p>Ouvrons un fichier <code>hello.go</code></p>

<pre><code class="go">package main

import "fmt"

func main() {
    fmt.Printf("hello, world\n")
}
</code></pre>

<p>Pour l&#8217;exécuter
<code>sh
go run hello.go
hello, world
</code></p>

<p>Tout va bien ! Nous avons installé Go</p>

<h2>Organisation d&#8217;un projet</h2>

<p>L&#8217;organisation d&#8217;un projet sous Go est fixe ! Comprendre qu&#8217;il faut un <strong>workspace</strong></p>

<p>Nous allons ensemble créer le projet <code>Hello</code></p>

<ul>
<li><p>Créer un répertoire <code>go</code></p></li>
<li><p>Assigner la variable d&#8217;environnement <code>$GOPATH</code></p></li>
</ul>


<pre><code> export GOPATH=$HOME/go
</code></pre>

<ul>
<li><p>enfin rajouter le $GOPATH/bin dans le PATH
<code>
export PATH=$PATH:$GOPATH/bin
</code></p></li>
<li><p>Nous voulons sauvegarder notre code quelques part. ici github!
<code>
mkdir -p $GOPATH/src/github.com/&lt;votreusername&gt;/hello
</code></p></li>
</ul>


<p>Votre <code>username</code> est votre namespace pour les packages (un peu comme java).</p>

<ul>
<li><p>dans notre répertoire <code>src/github.com/&lt;votreusername&gt;/hello</code> nous allons copier notre <code>hello.go</code></p></li>
<li><p>Tout est en place. Il n&#8217;y a plus qu&#8217;a taper <code>go install github.com/user/hello</code>.</p></li>
<li><p>autre possibilité se rendre dans le répertoire <code>src/github.com/&lt;votreusername&gt;/hello</code>
<code>bash
go install
</code></p></li>
<li><p>Nous pouvons vérifier que dans le répertoire <code>$HOME/go</code> il y a un dossier <code>bin/</code>
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$GOPATH/bin/hello
</span><span class='line'>hello world&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h1&gt;de manière plus simple puisque nous avons ajouter dans le path $GOPATH/bin&lt;/h1&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;hello
</span><span class='line'>hello world</span></code></pre></td></tr></table></div></figure>
voici la structure finale</p></li>
</ul>


<pre><code>.
├── bin
│   └── hello
└── src
    └── github.com
        └── mcamuzat
            └── hello
                ├── hello.go
                ├── LICENSE
                └── README.md
</code></pre>

<h2>Sauvegarde d&#8217;un projet</h2>

<p>Nous allons sauvegarder celui-ci sous <a href="https://github.com/">Github</a>. Ce n&#8217;est pas obligatoire.
<code>
cd $GOPATH/src/github.com/user/hello
git init
git add .
git commit -m"create project"
</code></p>

<p>Sous github, j&#8217;ai crée un nouveau repository <code>hello-go</code></p>

<pre><code>git remote add origin git@github.com:mcamuzat/hello-go.git
git pull --rebase
git push origin master
</code></pre>

<h2>Conclusion</h2>

<p>Nous avons d&#8217;installer Go.</p>

<p>Je viens juste de m&#8217;y mettre, Je ne sais pas encore ce que la suite nous réserve..</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Docker-machine]]></title>
    <link href="http://mcamuzat.github.io/blog/2015/05/09/docker-machine/"/>
    <updated>2015-05-09T18:29:45+02:00</updated>
    <id>http://mcamuzat.github.io/blog/2015/05/09/docker-machine</id>
    <content type="html"><![CDATA[<h2>Introduction</h2>

<p>Nous allons voir <a href="https://docs.docker.com/machine/">docker-machine</a>. Docker-machine permet de simplifier l&#8217;installation/gestion/déploiement de Docker.</p>

<h2>Installation</h2>

<p>Tout d&#8217;abord il faut connaitre votre architecture <code>x86_64</code>ou <code>i386</code>.</p>

<p>La commande classique est <code>uname -a</code>.</p>

<p>Puis télécharger l&#8217;exécutable via <code>curl</code></p>

<p>Sous linux.
<code>bash
curl -L https://github.com/docker/machine/releases/download/v0.2.0/docker-machine_linux-amd64 &gt; docker-machine
sudo mv docker-machine /usr/local/bin/docker-machine
</code></p>

<p>Puis le marquer comme exécutable.
<code>bash
sudo chmod +x /usr/local/bin/docker-machine
</code></p>

<p>Testons notre application.
<code>bash
docker-machine -v
</code></p>

<p>Enfin vous avez besoin d&#8217;avoir <a href="https://www.virtualbox.org/wiki/Downloads">Virtual-Box</a></p>

<h2>Mise en route.</h2>

<p>Voici la commande pour tout lancer</p>

<pre><code class="bash">docker-machine create --driver virtualbox dev
</code></pre>

<p>Cette ligne demande à docker-machine de créer une environnement que l&#8217;on appelle <strong>dev</strong> qui sera sur Virtual-box.
docker-machine va télécharger une iso (boot2docker) contenant docker. Et lancer Virtualbox.</p>

<p>Jusqu&#8217;à maintenant on avait installé docker sur notre ordi local.
Ici on installe docker sur une VM.
Toutes les commandes seront passer de manière transparente à la machine virtuelle.
L&#8217;avantage de cette méthode est que tout le monde utilise la même iso virtuelle (boot2docker). Il n&#8217;y a moins le risque du &ldquo;chez moi ça marche&rdquo; qui est une remarque au combien rageante.</p>

<p>Je veux travailler sur mon environnement de dev</p>

<pre><code>eval "$(docker-machine env dev)"
</code></pre>

<p>Toutes mes commandes sont directement envoyées sur la vm à distance
<code>
docker run busybox echo hello
</code></p>

<p>Je peux rajouter un environnement (ici <strong>prod</strong>)
<code>
docker-machine create --driver amazon prod --les options qui vont bien..
</code></p>

<p>Il suffit de changer l&#8217;environnement pour automatiquement déployer sur Amazon.
<code>
eval "$(docker-machine env prod)"
</code></p>

<p>Plein de drivers sont fournis:</p>

<ul>
<li><a href="https://docs.docker.com/machine/#amazon-web-services">Amazon Web Services</a></li>
<li><a href="https://docs.docker.com/machine/#digital-ocean">Digital Ocean</a></li>
<li><a href="https://docs.docker.com/machine/#google-compute-engine">Google Compute Engine</a></li>
<li><a href="https://docs.docker.com/machine/#ibm-softlayer">IBM Softlayer</a></li>
<li><a href="https://docs.docker.com/machine/#microsoft-azure">Microsoft Azure</a></li>
<li><a href="https://docs.docker.com/machine/#microsoft-hyper-v">Microsoft Hyper-V</a></li>
<li><a href="https://docs.docker.com/machine/#openstack">Openstack</a></li>
<li><a href="https://docs.docker.com/machine/#rackspace">Rackspace</a></li>
<li><a href="https://docs.docker.com/machine/#oracle-virtualbox">Oracle VirtualBox</a></li>
<li><a href="https://docs.docker.com/machine/#vmware-fusion">VMware Fusion</a></li>
<li><a href="https://docs.docker.com/machine/#vmware-vcloud-air">VMware vCloud Air</a></li>
<li><a href="https://docs.docker.com/machine/#vmware-vsphere">VMware vSphere</a></li>
</ul>


<h2>L&#8217;avantage de docker-machine</h2>

<ul>
<li>Simplifie l&#8217;installation. il n&#8217;y a que docker-machine à installer. Arès docker-machine s&#8217;occupe de tout installer. (il installe docker sur un vm/instance)</li>
<li>Simplifie le déploiement, il suffit de changer l&#8217;environnement</li>
<li>Enfin il s&#8217;interface avec docker-swarm (qui permet de gérer plusieurs nodes de Dockers).</li>
</ul>


<h2>En conclusion</h2>

<p>Le slogan &ldquo;a way to get from zero to Docker&rdquo; est plutôt juste.</p>

<ul>
<li>Cela simplifie beaucoup l&#8217;installation sous windows (pas testé :-)).</li>
<li>Et harmonise les environnements de dev (tout le monde utilise la même iso)</li>
<li>Facilite le déploiement. Il n&#8217;y a pas a se soucier si c&#8217;est du Amazon/OpenStack/Azure..</li>
</ul>


<p>Dans un prochain post nous allons essayer de voir docker-swarm.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Docker-compose]]></title>
    <link href="http://mcamuzat.github.io/blog/2015/05/03/docker-compose/"/>
    <updated>2015-05-03T21:33:31+02:00</updated>
    <id>http://mcamuzat.github.io/blog/2015/05/03/docker-compose</id>
    <content type="html"><![CDATA[<h2>Docker-compose</h2>

<p>Dans le post précèdent sur docker, j&#8217;avais expliqué comment automatiser la création des containers grâce au <code>Dockerfile</code> aujourd&#8217;hui je vais expliquer <code>docker-compose</code></p>

<h2>Intro.</h2>

<p>Dans un projet, il n&#8217;y a rarement qu&#8217;une seule instance. Voir il peut y avoir plusieurs fronts et une seule base de donnée. docker-compose est la justement pour organiser cela.</p>

<p>Par exemple le <code>docker-compose.yml</code> suivant:</p>

<pre><code class="yml">web:
  image: php:5.6-apache
  links:
    - db:db
  volumes:
    - .:/var/www/html

db:
  image: postgres
</code></pre>

<p>On déclare deux type de containers le container type <strong>web</strong> et le container de type <strong>db</strong>. à noter la ligne <code>links</code> qui fait que le container web partage/vois le container db</p>

<p>Il suffit de faire <code>docker-compose up</code> (comme un <code>vagrant up</code>)  pour automatiquement lancer deux containers. un container web avec une image php-5.6, et un container avec PostGresSQL</p>

<h2>Installation</h2>

<p>Il existe deux façons de l&#8217;installer soit passer par <code>pip</code> (pip est l&#8217;équivalent de <code>npm</code> pour le python).</p>

<pre><code class="bash">sudo pip install -U docker-compose
</code></pre>

<p>Ou de passer par curl</p>

<pre><code class="bash">curl -L https://github.com/docker/compose/releases/download/1.2.0/docker-compose-`uname -s`-`uname -m` &gt; /usr/local/bin/docker-compose
chmod +x /usr/local/bin/docker-compose
</code></pre>

<h2>Quelques commandes</h2>

<p>Lancer les containers en mode démon (<code>-d</code>)</p>

<pre><code>docker-compose up -d
</code></pre>

<p>Cela crée deux containers</p>

<p>Que l&#8217;on peux surveiller grâce à la commande suivante
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>docker-compose ps&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;Name                   Command               State    Ports   
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;hr /&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;compose_db_1    /docker-entrypoint.sh postgres   Up      5432/tcp
</span><span class='line'>compose_web_1   apache2-foreground               Up      80/tcp&lt;br/&gt;</span></code></pre></td></tr></table></div></figure></p>

<p>On peux voir les logs
<code>
docker-compose logs
</code></p>

<p>Plus intéressant on peux rajouter des containers..</p>

<pre><code>docker-compose scale web=3
Creating compose_web_2...
Creating compose_web_3...
Starting compose_web_2...
Starting compose_web_3...
</code></pre>

<p>Si je re-liste mes containers
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>docker-compose ps&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;Name                   Command               State    Ports   
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;hr /&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;compose_db_1    /docker-entrypoint.sh postgres   Up      5432/tcp
</span><span class='line'>compose_web_1   apache2-foreground               Up      80/tcp &lt;br/&gt;
</span><span class='line'>compose_web_2   apache2-foreground               Up      80/tcp &lt;br/&gt;
</span><span class='line'>compose_web_3   apache2-foreground               Up      80/tcp</span></code></pre></td></tr></table></div></figure></p>

<p>Je viens de multiplier par 3 le nombre de container en une simple commande et sans stopper le système.</p>

<h2>Conclusion</h2>

<p>Si vous n&#8217;avez qu&#8217;un seul container docker-compose ne sert pas à grand chose. Mais si vous avez plusieurs containers. Cela ne vaux pas la peine de se priver. Docker-compose contient en fait la liste des container ainsi que leurs configurations si on devait les lancers en la ligne de commande.</p>

<p>Dans le prochain post sur docker, je vais tenter <code>docker-machine</code>.</p>
]]></content>
  </entry>
  
</feed>
