<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: javascript | Journal d'un panda.]]></title>
  <link href="http://mcamuzat.github.io/blog/categories/javascript/atom.xml" rel="self"/>
  <link href="http://mcamuzat.github.io/"/>
  <updated>2015-11-11T17:52:18+01:00</updated>
  <id>http://mcamuzat.github.io/</id>
  <author>
    <name><![CDATA[mcamuzat]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Yield PHP Co-routine]]></title>
    <link href="http://mcamuzat.github.io/blog/2015/09/13/yield-php-co-routine/"/>
    <updated>2015-09-13T20:31:37+02:00</updated>
    <id>http://mcamuzat.github.io/blog/2015/09/13/yield-php-co-routine</id>
    <content type="html"><![CDATA[<p>Nous allons continuer sur le <em>yield</em> <a href="/blog/2015/09/06/php-yield-les-generateurs/">partie1</a></p>

<p>Nous avons vu la fonction xrange qui permet de générer un million de valeurs pour un coup très faible en mémoire.</p>

<p>Mais il y a mieux ! On peux envoyer des valeurs dans le générateur
&#8220;` php
&lt;?php
function generateAnimal() {
    $input = (yield &lsquo;Panda&rsquo;);
    var_dump(&ldquo;j&#8217;ai reçu $input&rdquo;);
    $input = (yield &lsquo;Lama&rsquo;);
    var_dump(&ldquo;j&#8217;ai reçu $input&rdquo;);
}</p>

<p>$gen = generateAnimal();
var_dump($gen->current());// string(5) &ldquo;Panda&rdquo;
var_dump($gen->send(&lsquo;Canard&rsquo;));//string(16) &ldquo;j&#8217;ai recu Canard&rdquo;
                               //string(4) &ldquo;Lama&rdquo;
var_dump($gen->send(&lsquo;Poney&rsquo;)); // j&#8217;ai recus Poney.
&#8220;`</p>

<p>Si j&#8217;avais fais deux fois <code>-&gt;next()</code>  au lieux de <code>-&gt;send()</code></p>

<pre><code class="php">$gen = generateAnimal();
var_dump($gen-&gt;current());// string(5) "Panda"
var_dump($gen-&gt;next());//string(16) "j'ai recu NULL"
                               //string(4) "Lama"
var_dump($gen-&gt;next()); // j'ai recus NULL.
</code></pre>

<h2>Les Co-routines</h2>

<p>Une co-routine est une fonction qui peut se suspendre en reprendre quand on le souhaite.</p>

<p>Nous allons faire une classe <code>Task</code>  pour mieux comprendre.</p>

<pre><code class="php">class Task
{
    protected $generator;

    protected $firstCall = true;

    public function __construct(Generator $generator)
    {
        $this-&gt;generator = $generator;
    }

    public function run()
    {
        if ($this-&gt;firstCall) {
            $this-&gt;generator-&gt;current();
        } else {
            $this-&gt;generator-&gt;next();
        }

        $this-&gt;firstCall = false;
    }

    public function finished()
    {
        return !$this-&gt;generator-&gt;valid();
    }
}
</code></pre>

<p>J&#8217;ai besoin d&#8217;un Runner</p>

<pre><code class="php">
class Runner
{
    public function __construct(Task $task)
    {
        $this-&gt;task = $task;
    }

    public function run()
    {
        while (!$this-&gt;task-&gt;finished()) {
            $this-&gt;task-&gt;run();
        }
    }
}
</code></pre>

<p>Un petit code d&#8217;exemple</p>

<pre><code>function task1() {
    for ($i = 1; $i &lt;= 10; ++$i) {
        echo "This is task 1 iteration $i.\n";
        yield;
    }
}

$task = new Task(task1());
$runner = new Runner($task);
$runner-&gt;run();
</code></pre>

<p>Cela donne</p>

<pre><code>This is task 1 iteration 1.
This is task 1 iteration 2.
This is task 1 iteration 3.
This is task 1 iteration 4.
This is task 1 iteration 5.
This is task 1 iteration 6.
This is task 1 iteration 7.
This is task 1 iteration 8.
This is task 1 iteration 9.
This is task 1 iteration 10.
</code></pre>

<p>J&#8217;ai un objet Task qui appelle une fonction et qui rend la main à chaque itération. Cela semble compliqué pour une seule tache. Mais modifions le code pour avoir plusieurs taches.</p>

<pre><code>class Scheduler
{
    protected $queue;

    public function __construct()
    {
        $this-&gt;queue = new SplQueue();
    }

    public function enqueue(Task $task)
    {
        $this-&gt;queue-&gt;enqueue($task);
    }

    public function run()
    {
        while (!$this-&gt;queue-&gt;isEmpty()) {
            $task = $this-&gt;queue-&gt;dequeue();
            $task-&gt;run();

            if (!$task-&gt;finished()) {
                $this-&gt;enqueue($task);
            }
        }
    }
}
</code></pre>

<p>Bon toute la magie est faite grâce à la <code>SplQueue</code> qui est une file d&#8217;attente. J&#8217;ajoute dans la file d&#8217;attente toutes les taches.</p>

<p>Je prend une tache de la file d&#8217;attente. Je l&#8217;exécute avec <code>-&gt;run()</code>, si la tache n&#8217;est pas finie, je la remets dans la file d&#8217;attente.</p>

<p>Reprenons un code d&#8217;exemple</p>

<pre><code class="php">function task1() {
    for ($i = 1; $i &lt;= 10; ++$i) {
        echo "This is task 1 iteration $i.\n";
        yield;
    }
}

function task2() {
    for ($i = 1; $i &lt;= 5; ++$i) {
        echo "This is task 2 iteration $i.\n";
        yield;
    }
}

$task1 =  new Task(task1());
$task2 = new Task(task2());
$scheduler = new Scheduler();
$scheduler-&gt;enqueue($task1);
$scheduler-&gt;enqueue($task2);
$scheduler-&gt;run();
</code></pre>

<p>Le résultat.</p>

<pre><code>This is task 1 iteration 1.
This is task 2 iteration 1.
This is task 1 iteration 2.
This is task 2 iteration 2.
This is task 1 iteration 3.
This is task 2 iteration 3.
This is task 1 iteration 4.
This is task 2 iteration 4.
This is task 1 iteration 5.
This is task 2 iteration 5.
This is task 1 iteration 6.
This is task 1 iteration 7.
This is task 1 iteration 8.
This is task 1 iteration 9.
This is task 1 iteration 10.
</code></pre>

<p>On voit que j&#8217;exécute en parallèle toutes mes deux taches.</p>

<h2>En conclusion</h2>

<p>Il existe deux librairies qui utilise ce concept</p>

<ul>
<li><a href="https://github.com/icicleio/icicle">Icicle</a></li>
<li><a href="https://github.com/recoilphp/recoil">recoil</a></li>
</ul>


<p>Cette façon d&#8217;implémenter est assez curieuse. Car le code ne ressemble pas au code classique asynchrone avec des callbacks et autre événements. Si on regarde bien cela ressemble beaucoup a du code synchrone. Elle est inspirée du <code>C#</code> <code>async/wait</code>. On a l&#8217;impression que cela ressemble a du code synchrone où on ajoute des <code>yield</code> un peu partout. (en simplifiant beaucoup..)</p>

<p>Il y a peu de documentation et d&#8217;exemple sur le sujet.</p>

<ul>
<li>la référence est ce post de <a href="http://nikic.github.io">Nikic</a>: <a href="https://nikic.github.io/2012/12/22/Cooperative-multitasking-using-coroutines-in-PHP.html">Cooperative multitasking using coroutines (in PHP!)</a></li>
<li>Une version légèrement simplifié dont je me suis inspiré pour le code <a href="https://medium.com/@assertchris/co-operative-php-multitasking-ce4ef52858a0">Co-operative PHP Multitasking</a></li>
</ul>


<p>Je vais essayer de continuer avec le yield et repartir sur les promises.</p>

<p>Merci de m&#8217;avoir lu.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Les promises et Php via ReactPhp]]></title>
    <link href="http://mcamuzat.github.io/blog/2015/09/05/les-promises-et-php-via-react/"/>
    <updated>2015-09-05T19:10:10+02:00</updated>
    <id>http://mcamuzat.github.io/blog/2015/09/05/les-promises-et-php-via-react</id>
    <content type="html"><![CDATA[<p>Les promises sont une alternative plus puissante au Callback. Relativement peu connues au début. Elle sont maintenant en standard dans beaucoup de langage javascript ES6, python 3.2, java. Où via des librairies comme <a href="https://github.com/reactphp/promise">react/promise</a> pour php</p>

<p>Une promise représente une valeur donc le résultat n&#8217;est pas encore connu.
Quand le résultat est connu,  la promise a 3 états possibles</p>

<ul>
<li><strong>Pending</strong> ou <strong>Unfulfillled</strong>  en Attente..</li>
<li><strong>Resolved</strong> ou <strong>fulfillled</strong>  Succès</li>
<li><strong>Rejected</strong> ou <strong>Failed</strong>  Erreur.</li>
</ul>


<p>Un <em>Deffered</em> représente un travail qui n&#8217;est pas encore fini. Donc un <em>Deferred</em> possède une promise (une valeur pas encore connues).</p>

<p>Quand la valeur est connue, la promesse utilise un <em>handler</em> (en général <code>-&gt;then()</code>) qui lui-même renvoie une promise. L&#8217;intérêt est que les promises sont chainables.</p>

<p>Mais essayons quelques exemples qui seront un peu plus parlant.</p>

<p>Pour ce faire nous allons d&#8217;abord installer <a href="https://github.com/reactphp/promise">react/promises</a></p>

<pre><code class="php">&lt;?php
require __DIR__.'/vendor/autoload.php';

// On crée un travail
$deferred = new React\Promise\Deferred();

// On veux la promise
$promise  = $deferred-&gt;promise()-&gt;then(
    function () { echo "tout va bien \n"; },
    function () { echo "tout va mal \n"; },
    function () { echo "j'attends\n "; }
);


// Le travail est un succes, on résoud la promise
$deferred-&gt;resolve(); 
</code></pre>

<p>Voici ce que j&#8217;obtiens si je lance le programme.</p>

<pre><code class="php">tout va bien
</code></pre>

<p>Si je remplace <code>$deferred-&gt;resolve()</code> par <code>$deferred-&gt;reject()</code>. Le travail n&#8217;as pas marché. J&#8217;obtiens</p>

<pre><code class="php">Tout va mal
</code></pre>

<p>La syntaxe de <code>then</code> est</p>

<pre><code class="php">then(callable $onFulfilled = null, callable $onRejected = null, callable $onProgress = null)
</code></pre>

<ul>
<li>Si l&#8217;action est un succès, On résous la promise en appelant la fonction <code>$onFulfilled</code>.</li>
<li>L&#8217;action n&#8217;est pas bonne, On rejette la promise avec <code>$onRejected</code>.</li>
<li>Si l&#8217;action est en cours , On appelle <code>$onProgress</code>.</li>
</ul>


<p>A noter qu&#8217;une promise une fois qu&#8217;elle est résolue ou rejetée ne peut plus être réutilisée sauf dans le cas du <code>pending</code></p>

<pre><code class="php">$promise-&gt;notify();
$promise-&gt;notify();
$promise-&gt;notify();
$promise-&gt;resolve();
</code></pre>

<p>Le résultat</p>

<pre><code class="">j'attends
j'attends
j'attends
tout va bien
</code></pre>

<p>Pour l&#8217;instant rien de bien compliqué. On peut chainer les promises</p>

<pre><code class="php ">$promise  = $deferred-&gt;promise()-&gt;then(
    function () { echo "action 1 ok\n"; }
)-&gt;then(
    function () { echo "action 2 ok\n";}
)-&gt;then(
   function () { echo "action 3 ok\n";},
   function () { echo "une des actions n'est pas ok..\n";}
);

$deferred-&gt;resolve();
</code></pre>

<p>Le résultat
<code>
action 1 ok
action 2 ok
action 3 ok
</code></p>

<p>Essayons avec <code>deffered-&gt;reject()</code></p>

<p>Le résultat</p>

<pre><code>une des actions n'est pas ok..
</code></pre>

<p>Ajoutons un exception à la deuxième étape.
&#8220;` php
$promise  = $deferred->promise()->then(
    function () { echo &ldquo;action 1 ok\n&rdquo;; }
)->then(
    function () { throw new Exception();}
)->then(
   function () { echo &ldquo;action 3 ok\n&rdquo;;},
   function () { echo &ldquo;une des actions n&#8217;est pas ok..\n&rdquo;;}
);</p>

<pre><code>
Le résultat
</code></pre>

<p>action 1 ok
une des actions n&#8217;est pas ok..
&#8220;`</p>

<p>Ajoutons une exception dans le premier, et ajoutons un cas pour gérer l&#8217;erreur
&#8220;` php
$promise  = $deferred->promise()->then(
    function () { throw new \Exception(); }
)->then(
    function () { echo &ldquo;action 2 ok\n&rdquo;;},
    function () { echo &ldquo;l&#8217;action 1 pas ok mais on continue..\n&rdquo;;}
)->then(
   function () { echo &ldquo;action 3 ok\n&rdquo;;},
   function () { echo &ldquo;une des actions n&#8217;est pas ok..\n&rdquo;;}
);</p>

<p>$deferred->resolve();
&#8220;`</p>

<p>Le résultat
<code>
l'action 1 pas ok mais on continue..
action 3 ok
</code></p>

<p>Si on veux que l&#8217;erreur de l&#8217;action 1 se propage deux possibilités..</p>

<ul>
<li>supprimer le callback d&#8217;erreur de l&#8217;action 2</li>
<li>Ou relancer l&#8217;exception</li>
</ul>


<pre><code>$promise  = $deferred-&gt;promise()-&gt;then(
    function () { throw new \Exception(); }
)-&gt;then(
    function () { echo "action 2 ok\n";},
    function () { echo "l'action 1 pas ok et on stop le processus"; throw new \Exception();}
)-&gt;then(
   function () { echo "action 3 ok\n";},
   function () { echo "une des actions n'est pas ok..\n";}
);
</code></pre>

<p>Ce qui est intéressant dans les promises c&#8217;est que le code équivalent en procédural est pas génial.
<code>
 $result = doAction1();
try {
    $result = doAction1();
    if ($result) {
        $result2 = doAction2($result);
        if ($result2) {
            $result3 = doAction3($result3);
            return $result3;
        } else {
            throw new Exception();
        }
    } else {
        throw New Exception();
    }
} catch (..){
    echo "une des actions n'est pas ok"
}
</code></p>

<p>Devient
<code>
    $result = $doAction1()
        -&gt;then(function($result1){doAction2($result1);})
        -&gt;then(
            function($result2){doAction3($result2);},
            function() {echo "une des actions n'est pas ok"}
        );
</code></p>

<p>C&#8217;est mieux non ?</p>

<p>Dans un prochain article nous nous utiliserons ce que nous avons appris avec <a href="http://guzzle.readthedocs.org/en/latest/">Guzzle</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Workshops de javascript]]></title>
    <link href="http://mcamuzat.github.io/blog/2015/08/09/workshops-de-javascript/"/>
    <updated>2015-08-09T16:44:33+02:00</updated>
    <id>http://mcamuzat.github.io/blog/2015/08/09/workshops-de-javascript</id>
    <content type="html"><![CDATA[<p><em>Et si on essayait un workshop&hellip;</em></p>

<p>Les workshops de javascript sont des cours interactifs de javascript.</p>

<h2>Installation</h2>

<p>Pour installer le cours de Node.js c&#8217;est très simple. A condition d&#8217;avoir node.js installé.</p>

<pre><code>npm install -g learnyounode
learnyounode
</code></pre>

<p>Voila ce que vous devriez voir.</p>

<p>{% img center /images/workshop.png 585 397 &lsquo;screenshot de workshop&rsquo; &lsquo;On a un menu interactif&rsquo; %}</p>

<p>Lançons nous dans le premier exercice.</p>

<pre><code>
 LEARN YOU THE NODE.JS FOR MUCH WIN!
─────────────────────────────────────
 HELLO WORLD
 Exercise 1 of 13

Write a program that prints the text "HELLO WORLD" to the console (stdout).

-------------------------------------------------------------------------------

## HINTS

To make a Node.js program, create a new file with a .js extension and start writing JavaScript! Execute your program by running it with the
node command. e.g.:

    $ node program.js

You can write to the console in the same way as in the browser:

    console.log("text")

When you are done, you must run:

    $ learnyounode verify program.js

to proceed. Your program will be tested, a report will be generated, and the lesson will be marked 'completed' if you are successful.

-------------------------------------------------------------------------------

 » To print these instructions again, run: learnyounode print
 » To execute your program in a test environment, run: learnyounode run program.js
 » To verify your program, run: learnyounode verify program.js
 » For help run: learnyounode help
</code></pre>

<p>donc je resume on me demande de programmer un **Hello world&#8221;.</p>

<p>donc je crée un <code>hello.js</code></p>

<pre><code class="js">console.log('HELLO WORLD');
</code></pre>

<p>Je peux tester celui-ci avec un programme de test avec la commande suivante
<code>sh
$ learnyounode run hello.js
</code></p>

<p>Si je suis content du résultat alors je peux faire vérifier le programme par le logiciel.</p>

<pre><code class="sh">$ learnyounode verify program.js
</code></pre>

<p>Si le programme passe, le niveau est marquer comme <code>[COMPLETED]</code> et on peux passer au suivant.</p>

<p>Bon l&#8217;étape 1 n&#8217;est pas très compliqué passons à l&#8217;étape 2.</p>

<pre><code> LEARN YOU THE NODE.JS FOR MUCH WIN!
─────────────────────────────────────
 BABY STEPS
 Exercise 2 of 13

Write a program that accepts one or more numbers as command-line arguments and prints the sum of those numbers to the console (stdout).

-------------------------------------------------------------------------------

## HINTS

You can access command-line arguments via the global process object. The process object has an argv property which is an array containing the complete command-line. i.e. process.argv.

To get started, write a program that simply contains:

    console.log(process.argv)

Run it with node program.js and some numbers as arguments. e.g:

    $ node program.js 1 2 3

In which case the output would be an array looking something like:

    [ 'node', '/path/to/your/program.js', '1', '2', '3' ]

You'll need to think about how to loop through the number arguments so  you can output just their sum. The first element of the process.argv array is always 'node', and the second element is always the path to your program.js file, so you need to start at the 3rd element (index 2), adding each item to the total until you reach the end of the array.

Also be aware that all elements of process.argv are strings and you may need to coerce them into numbers. You can do this by prefixing the property with + or passing it to Number(). e.g. +process.argv[2] or Number(process.argv[2]).

learnyounode will be supplying arguments to your program when you run learnyounode verify program.js so you don't need to supply them yourself. To test your program without verifying it, you can invoke it with learnyounode run program.js. When you use run, you are invoking the test environment that learnyounode sets up for each exercise.

-------------------------------------------------------------------------------

 » To print these instructions again, run: learnyounode print
 » To execute your program in a test environment, run: learnyounode run program.js
 » To verify your program, run: learnyounode verify program.js
 » For help run: learnyounode help
</code></pre>

<p>Donc il s&#8217;agit de créer un programme qui prend les nombres en entrée et faire la somme à la fin.</p>

<p>Voici ma solution (atroce &hellip; )</p>

<pre><code class="js">var i = process.argv;
i.shift(); 
i.shift();// supprime les deux premiers arguments ('node', 'programme.js')
console.log(i.reduce(function(a,b){return a + Number(b)},0));
</code></pre>

<p>Le logiciel donne une implémentation beaucoup plus simple(pas difficile)
&#8220;` js
   var result = 0</p>

<pre><code>for (var i = 2; i &lt; process.argv.length; i++)
  result += Number(process.argv[i])

console.log(result)
</code></pre>

<p>&#8220;`</p>

<p>Etc etc ..</p>

<h2>Une liste de workshop.</h2>

<p>Le site officiel donne la liste suivante en module de base.</p>

<ul>
<li><a href="https://www.github.com/sethvincent/javascripting">javascripting</a> Apprendre les bases du javascript.</li>
<li><a href="https://www.github.com/jlord/git-it">git-it</a> pour apprendre Git et GitHub.</li>
<li><a href="https://www.github.com/jesstelford/scope-chains-closures">Scope Chains &amp; Closures</a> Comprendre les scopes, les closures etc..</li>
<li><a href="https://www.github.com/workshopper/learnyounode">learnyounode</a> les bases de node asynchronous i/o, http.</li>
<li><a href="https://github.com/npm/how-to-npm">How to npm</a> Comment créer des modules Npm</li>
<li><a href="https://www.github.com/substack/stream-adventure">stream-adventure</a> apprennez les streams et comment les composer avec <code>.pipe()</code>.</li>
</ul>


<h2>Mais il y en a plus.</h2>

<p>On peux apprendre un peu près n&#8217;importe quel technologie en pratique.</p>

<ul>
<li><a href="https://github.com/timoxley/functional-javascript-workshop">Functional Javascript</a> : Base de la programmation fonctionnelle en javascript.</li>
<li><a href="https://github.com/azat-co/expressworks">ExpressWorks</a>: Apprendre le framework Express.js.</li>
<li><a href="https://github.com/stevekane/promise-it-wont-hurt">Promise It Won&rsquo;t Hurt</a>:  Apprendre les promesses pour les opération asynchrone.</li>
<li><a href="https://github.com/bulkan/async-you">Async</a>:  La librairie Async.</li>
<li><a href="https://github.com/sporto/planetproto">Planet Proto</a>:  Comprendre l&#8217;héritage prototypal.</li>
<li><a href="https://github.com/finnp/test-anything">Test Anything</a>:  Comment tester son code</li>
<li><a href="https://github.com/evanlucas/learnyoumongo">learnyoumongo</a>:  Débuter avec MongoDB et node.js</li>
<li><a href="https://github.com/gl-modules/shader-school">Shader School</a>:  Comprendre les shaders.</li>
<li><a href="https://github.com/othiym23/bug-clinic">Bug Clinic</a>:  Apprendre de nouveaux outils et debugger plus facilement.</li>
<li><a href="https://github.com/alexmackey/IntroToWebGLWithThreeJS">Intro to WebGL</a>:  Débuter avec <a href="">three.js</a> et le WebGL.</li>
<li><a href="https://github.com/mdunisch/lololodash">LololoDash</a>: Apprendre Lo-Dash (fork de underscore)</li>
<li><a href="https://github.com/robertkowalski/learnyoucouchdb">learnyoucouchdb</a>:  Apprendre CouchDB.</li>
<li><a href="https://github.com/tako-black/learnyoureact">learnyoureact</a>:  Apprenez React.js.</li>
</ul>


<h2>Des liens</h2>

<ul>
<li>le <a href="http://nodeschool.io">site officiel</a> et la version <a href="http://nodeschool.io/fr-fr/">française</a></li>
<li>J&#8217;ai déjà parlé des <a href="/blog/2015/04/29/awesome-et-liste-de-liens/">awesome-list</a>. bien entendu elle existe pour les <a href="https://github.com/therebelrobot/awesome-workshopper">workshops</a>.</li>
</ul>


<h2>Conclusion</h2>

<p>Vous voulez apprendre le js, react.js, écrire des tests je crois que vous savez par ou commencer.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Processing et Souvenir]]></title>
    <link href="http://mcamuzat.github.io/blog/2015/07/17/processing-et-souvenir/"/>
    <updated>2015-07-17T22:52:27+02:00</updated>
    <id>http://mcamuzat.github.io/blog/2015/07/17/processing-et-souvenir</id>
    <content type="html"><![CDATA[<p>{% img center /images/voiture.png 499 300 &lsquo;Vrooum!!&rsquo; &lsquo;Screenshot du programme avec le micro&rsquo; %}</p>

<p>Aujourd&#8217;hui, je ressors un vieux code que j&#8217;avais écris pour le CNAM. Le sujet était faire que l&#8217;image à l&#8217;écran bouge quand on parle dans un microphone. Mais pas d&#8217;animation à la Winamp (j&#8217;ai des vieilles références :-) ou le player de Windows. J&#8217;avais donc programmé une voiture sur un circuit, pour le réalisme j&#8217;avais connecté un Wii-chuck via un Arduino pour faire le volant. Imaginez une personne avec un Wiichuk et un micro en train de faire &ldquo;Vrrrooum&rdquo; et vous aurez un idée de ma soutenance (qui s&#8217;est bien passée d&#8217;ailleurs).</p>

<p>Les conditions étaient :</p>

<ul>
<li>Utiliser un Micro</li>
<li>La langage imposé est Processing</li>
</ul>


<h2>Processing Késako</h2>

<p>Processing est une variante de Java en plus simple. C&#8217;est un langage destiné à faire des oeuvres d&#8217;arts numériques. Il est souvent enseigné en école d&#8217;art. Il vient avec son propre éditeur. à noter que les <a href="https://fr.wikipedia.org/wiki/Arduino">Arduinos</a> se programment aussi en processing.</p>

<p>{% img center /images/processing.png 499 533 &lsquo;Processing&rsquo; &lsquo;Screenshot de processing avec son interface&rsquo; %}</p>

<p>Il suffit d&#8217;implémenter deux méthodes :</p>

<pre><code>void setup() // sera appelé à l'initialisation
void draw() // sera appellé 30 à 50 fois par seconde
</code></pre>

<p>Un exemple très simple
&#8220;` java
void setup() {
  size(640, 360); //j&#8217;initialise la taille 640*
  stroke(255); // le trait est blanc
  fill(255); // remplissage de blanc
  background(0); // couleur de fond blanche</p>

<p>}</p>

<p>void draw() {
  // si la souris est appuyer
  if (mousePressed) {
     // ellipse x, y ,hauteur, largeur
    ellipse(mouseX, mouseY, 5, 5);
  }
}
&#8220;`</p>

<p>Appuyez sur la touche play</p>

<p>{% img center /images/processing_exemple.png 535 375 &lsquo;Processing&rsquo; &lsquo;le résultat&rsquo; %}</p>

<p>Je viens de faire un petit painbrush. C&#8217;est assez facile d&#8217;obtenir un truc plutôt joli avec assez peu de lignes de code. Il y a des librairies toutes prêtes pour la video, webcam.</p>

<p>Il y a de nombreux livres donc le <a href="http://www.amazon.com/Visualizing-Data-Explaining-Processing-Environment/dp/0596514557">Visualizing Data</a>. Pour 2007, le livre est impressionnant. On parle de traitement de donnée et acquisitions des données bien avant la mode du Big data.</p>

<h1>Installez Processing</h1>

<p>Nous allons d&#8217;abord installer Java si vous n&#8217;avez pas. J&#8217;installe le paquet officiel
<code>
sudo apt-get purge openjdk*    // Supprime opendjdk
sudo apt-get install software-properties-common   //ajout de librairie
sudo add-apt-repository ppa:webupd8team/java // ajout du depot
sudo apt-get update                 // et on met à jour les videos
sudo apt-get install oracle-java7-installer // On installe
sudo apt-get install oracle-java7-set-default // et on mets par défaut
</code></p>

<p>Puis nous allons installer Processing
On télécharge le binaire à l&#8217;<a href="https://processing.org/download/?processing">adresse officielle</a></p>

<p>Puis on décompresse
<code>
tar xf processing-*.tgz
sudo mkdir /usr/share/processing
sudo mv processing-* /usr/share/processing
</code>
Il n&#8217;y a plus qu&#8217;à lancer processing
<code>
sh /usr/share/processing/processing-2.2.1/processing
</code>
Vous devriez voir apparaitre l&#8217;interface</p>

<p>Faire marcher mon code:</p>

<ul>
<li>Il faut utiliser la librairie Ess pour analyser le signal (marrant c&#8217;était déja vieux à l&#8217;époque)</li>
<li>Aller sur le site <a href="http://www.tree-axis.com/Ess">suivant</a>.</li>
<li>Décompressez et copier le répertoire ESS dans /usr/share/processing/processing-2.2.1/modes/java/libraries/</li>
</ul>


<h2>Le code</h2>

<p>Il est disponible <a href="https://github.com/mcamuzat/processing-car">ici</a> sous Github. J&#8217;ai commenté la partie avec le Numchuck+Arduino (car peux de gens ont le matériel). A l&#8217;époque impossible de faire marcher la connection USB/Wiichuck sous Linux, j&#8217;ai passé la soutenance sous un vieux PC sous windows XP. Tout est mis dans le même fichier car j&#8217;avais pas trouver comment découper un projet. C&#8217;est d&#8217;ailleurs ce que je reproche un peu à Processing, c&#8217;est un langage simple pour débuter, mais faire un MVC ou un programme très complexe. Il faut quasiment tout refaire à la main.</p>

<h2>Quelques liens</h2>

<ul>
<li>le <a href="https://processing.org/">site officiel</a></li>
<li>Des <a href="http://www.openprocessing.org/">galeries interactives</a></li>
<li><a href="http://processingjs.org/">ProcessingJs</a> (fait par le programmeur de JQuery Jon Resig)</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[If Hemingway wrote javascript]]></title>
    <link href="http://mcamuzat.github.io/blog/2015/06/21/if-hemingway-wrote-javascript/"/>
    <updated>2015-06-21T19:06:54+02:00</updated>
    <id>http://mcamuzat.github.io/blog/2015/06/21/if-hemingway-wrote-javascript</id>
    <content type="html"><![CDATA[<p>Je suis tombé un peu par hasard sur ce livre &ldquo;If Hemingway Wrote JavaScript&rdquo;. Cela part de l&#8217;idée que tout les auteurs ont un certain style. Et que s&#8217;il devait programmer en javascript le résultat serait diffèrent. L&#8217;auteur est un expert du javascript.</p>

<p>On trouve dans les auteurs</p>

<ul>
<li>Ernest Hemingway</li>
<li>William Shakespeare</li>
<li>André Breton</li>
<li>Roberto Bolaño</li>
<li>Dan Brown</li>
<li>Jack Kerouac</li>
<li>Jane Austen</li>
<li>Samuel Johnson</li>
<li>Sir Arthur Conan Doyle</li>
<li>James Joyce</li>
<li>J.D. Salinger</li>
<li>Tupac Shakur</li>
<li>Virginia Woolf</li>
<li>Geoffrey Chaucer</li>
<li>Vladimir Nabokov</li>
<li>Jorge Luis Borges</li>
<li>Lewis Carroll</li>
<li>Douglas Adams</li>
<li>Charles Dickens</li>
<li>David Foster Wallace</li>
<li>Sylvia Plath</li>
<li>Italo Calvino</li>
<li>J.K. Rowling</li>
<li>Arundhati Roy</li>
<li>Franz Kafka</li>
</ul>


<p>Bien sur un livre en anglais implique plutôt de la littérature anglaise. Certain choix sont curieux Dan Brown (Da vinci code) entre Kerouac et Joyce, Voir Tupac (si si le rappeur). Je venais de lire le livre le plus connus de Borges.</p>

<p>On trouve 7-8 implémentation du Fibonnaci et autre factorielle. Vous allez apprendre plein de trucs sur le javascript, bien que je doute que cela serve. L&#8217;auteur montre des utilisations de <code>with</code> ou l&#8217;atroce mais absolument correct <code>Function('return this/4').call(2*2)</code>. Il y a toutes les subtilités du javascript qui sont évoquées : Héritage, scope, hoisting, variable, etc..</p>

<p>La présentation est classe. Je l&#8217;avais pas reconnu mais les dessins sont de Miran Lipovača. C&#8217;est l&#8217;auteur du magnifique <a href="http://learnyouahaskell.com">Learn You a Haskell for Great Good!</a> si vous ne connaissez pas foncer.</p>

<h2>En conclusion</h2>

<p>Un bouquin qui aime les écrivains et qui aime le javascript. Il vous faudra aimer un peu les deux pour apprécier le contenu. Je m&#8217;en sors pas trop mal, je connaissais la plupart des écrivains. Pour moi c&#8217;est une curiosité et j&#8217;adore ce genre de livre. J&#8217;aime beaucoup la présentation.</p>
]]></content>
  </entry>
  
</feed>
