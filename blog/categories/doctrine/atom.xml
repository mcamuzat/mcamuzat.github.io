<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: doctrine | Journal d'un panda.]]></title>
  <link href="http://mcamuzat.github.io/blog/categories/doctrine/atom.xml" rel="self"/>
  <link href="http://mcamuzat.github.io/"/>
  <updated>2015-11-11T17:52:18+01:00</updated>
  <id>http://mcamuzat.github.io/</id>
  <author>
    <name><![CDATA[mcamuzat]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Listes Chainées Iterator]]></title>
    <link href="http://mcamuzat.github.io/blog/2015/11/01/listes-chainees-iterator/"/>
    <updated>2015-11-01T19:46:40+01:00</updated>
    <id>http://mcamuzat.github.io/blog/2015/11/01/listes-chainees-iterator</id>
    <content type="html"><![CDATA[<p>Troisième partie sur la SPL et les listes chainées.</p>

<ul>
<li>partie 1 <a href="blog/2015/10/03/spl-surcharge-magique">SPL et surcharge</a></li>
<li>partie 2 <a href="blog/2015/10/10/liste-chainees-implementation">Implémentation</a></li>
</ul>


<p>Nous allons implémenter l&#8217;interface <code>ArrayAccess</code>. Donc notre liste chainée va se comporter comme un array.</p>

<p>Je vais rajouter deux méthodes. Attention les <code>Array</code> commencent traditionnellement à 0 d&#8217;où le <code>$this-&gt;count -1</code></p>

<ul>
<li><p>Supprimer le chainon N
&#8220;` php
 public function removeAtPosition($position)
 {
     if (!$this->validateInterval($position)) {
             throw new \Exception(&ldquo;L&#8217;index doit être valide&rdquo;);
     }</p>

<pre><code> if ($position == 0) {
     return $this-&gt;removeFirstValue();
 }

 if ($position  ==  $this-&gt;count -1 ) {
     return $this-&gt;removeLastValue();

 }
 $current = $this-&gt;first;
 $last = $current;
 for ($i = 0; $i &lt; $position; $i++) {
     $last = $current;
     $current = $current-&gt;getNext();
 }

 $last-&gt;setNext($current-&gt;getNext());

 return $this;
</code></pre>

<p> }
&#8220;`</p></li>
<li><p>Récupérer le chainon N
&#8220;` php
 public function getAtPosition($position)
 {
     if (!$this->validateInterval($position)) {
         throw new \Exception(&ldquo;L&#8217;index doit être numerique&rdquo;);
     }
     if ($position == 0) {
         return $this->first->getData();
     }</p>

<pre><code> if ($position == $this-&gt;count - 1) {
     return $this-&gt;last-&gt;getData();
 }

 $current = $this-&gt;first;
 for ($i = 0; $i &lt; $position; $i++) {
     $current = $current-&gt;getNext();
 }

 return $current-&gt;getData();
</code></pre>

<p> }</p></li>
</ul>


<pre><code>
Pour avoir le 9999 chainon,  il faut parcourir les 9998 chainons précédents.

Avec les deux méthodes précédentes. Il suffit d'implémenter les méthodes suivantes
</code></pre>

<pre><code>public function offsetSet($offset, $value) {
    if ($offset == null) {
        $this-&gt;insertAtEnd($value);
    } else {
        if (!$this-&gt;validateInterval($offset)) {
            throw new \Exception("L'index doit être valide");
        }
        $this-&gt;insertAtPosition($offset, $value);
    }
}

public function offsetExists($offset) {
    return $this-&gt;validInterval($offset);
}

public function offsetUnset($offset)
{
     return $this-&gt;removeAtPosition($offset);
}

public function offsetGet($offset)
{
    return $this-&gt;getAtPosition($offset);
}
</code></pre>

<pre><code>
Pour vérifier que les valeurs en entrée sont correctes j'utilise la fonction suivante 
</code></pre>

<pre><code>private function validateInterval($offset) {
    return (false !== filter_var(
        $offset,
        FILTER_VALIDATE_INT,
        array(
            'options' =&gt; array(
                'min_range' =&gt; 0,
                'max_range' =&gt; $this-&gt;count-1
            )
        )
    ));
}
</code></pre>

<pre><code>
Bon cela semble un peu abstrait, voici quelques exemples d'utilisations.
</code></pre>

<p>$list = new LinkedList();
$list[] = &ldquo;first&rdquo;;
$list[] = &ldquo;second&rdquo;;
$list[] = &ldquo;third&rdquo;;
//
var_dump(isset($list[1]));// => true
var_dump($list[1]); // => &ldquo;second&rdquo;
unset($list[1]);
var_dump($list[1]); // => third
<code>``
Nous avons une liste qui se comporte comme un array. c'est pratique, mais on ne peux pas faire de</code>foreach` dessus.. Enfin pas encore.</p>

<h2>Ajout de l&#8217;itérator</h2>

<p>Pour faire un itérator il faut implémenter l&#8217;interface suivante
<code>php
 Iterator extends Traversable {
/* Méthodes */
abstract public mixed current ( void )
abstract public scalar key ( void )
abstract public void next ( void )
abstract public void rewind ( void )
abstract public boolean valid ( void )
}
</code></p>

<p>Dans le cas de notre liste chainée cela n&#8217;est pas très compliqué.</p>

<pre><code class="php"> class LinkedList implements Countable, ArrayAccess, *Iterator* {
    .....   
    private $current;
    private $position = 0;
    ....

    public function current () {
        return $this-&gt;current-&gt;getData();
    }
    public function key () {
        return $this-&gt;position;

    }
    public function next () {
        $this-&gt;position++;
        $this-&gt;current = $this-&gt;current-&gt;getNext();

    }
    public function rewind () {
        $this-&gt;position = 0;
        $this-&gt;current = $this-&gt;first;

    }
    public function valid () {
        return $this-&gt;current !== null;
    }
</code></pre>

<p>Un petit code d&#8217;exemple</p>

<pre><code class="php">$list = new LinkedList();
//
$list[] = "first";
$list[] = "second";
$list[] = "third";
foreach($list as $key =&gt; $value) {
    var_dump("$key =&gt; $value");
}

// string(10) "0 =&gt; first"
// string(11) "1 =&gt; second"
// string(10) "2 =&gt; third"
</code></pre>

<p>Je peux a tout moment le retransformer en <code>array</code> grâce à la méthode <code>iterator_to_array($list)</code></p>

<pre><code class="php">
array(3) {
  [0] =&gt;
  string(5) "first"
  [1] =&gt;
  string(6) "second"
  [2] =&gt;
  string(5) "third"
}
</code></pre>

<p>Pour faire dans l&#8217;autre sens nous pouvons implémenter le constructor
<code>php
    public function __construct($input = null)
    {
        if ($input) {
            if (! (is_array($input) || $input instanceof Traversable)) {
                throw new \Exception("Un array ou Un iterator..");
            }
            foreach($input as $value) {
                $this-&gt;insertAtEnd($value);
            }
        }
    }
</code></p>

<p>Mon constructor prend un array ou un Objet qui implémente <code>Traversable</code> (en gros un Itérateur);</p>

<p>Quelques exemples
&#8220;` php
$list = new LinkedList(array(&ldquo;one&rdquo;, &ldquo;two&rdquo;, &ldquo;three&rdquo;));
foreach($list as $key => $value) {
    var_dump($value);
}
//string(3) &ldquo;one&rdquo;
//string(3) &ldquo;two&rdquo;
//string(5) &ldquo;three&rdquo;</p>

<p>$spl = New SplQueue();
$spl[] = &ldquo;travail1&rdquo;;
$spl[] = &ldquo;travail2&rdquo;;
$spl[] = &ldquo;travail3&rdquo;;
$list = new LinkedList($spl));
foreach($list as $key => $value) {
    var_dump($value);
}</p>

<p>// string(8) &ldquo;travail1&rdquo;
// string(8) &ldquo;travail2&rdquo;
// string(8) &ldquo;travail3&rdquo;</p>

<p>$linked = New LinkedList();
$linked[] = &ldquo;valeur 1&rdquo;;
$linked[] = &ldquo;valeur 2&rdquo;;
$linked[] = &ldquo;valeur 3&rdquo;;</p>

<p>$list = new LinkedList($linked);
foreach($list as $key => $value) {
    var_dump($value);
}
// string(9) &ldquo;valeur 1&rdquo;
// string(8) &ldquo;valeur 2&rdquo;
// string(8) &ldquo;valeur 3&rdquo;</p>

<p>&#8220;`</p>

<h2>En conclusion.</h2>

<p>Nous avons implémenter Les listes chainées avec toutes les méthodes. Mon exemple est un peu théorique. Mais je vous conseille de re-regarder les doctrines collections.</p>

<p>Merci de m&#8217;avoir lu.</p>
]]></content>
  </entry>
  
</feed>
