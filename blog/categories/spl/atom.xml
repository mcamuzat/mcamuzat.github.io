<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: spl | Journal d'un panda.]]></title>
  <link href="http://mcamuzat.github.io/blog/categories/spl/atom.xml" rel="self"/>
  <link href="http://mcamuzat.github.io/"/>
  <updated>2015-11-11T17:52:18+01:00</updated>
  <id>http://mcamuzat.github.io/</id>
  <author>
    <name><![CDATA[mcamuzat]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Listes Chainées Iterator]]></title>
    <link href="http://mcamuzat.github.io/blog/2015/11/01/listes-chainees-iterator/"/>
    <updated>2015-11-01T19:46:40+01:00</updated>
    <id>http://mcamuzat.github.io/blog/2015/11/01/listes-chainees-iterator</id>
    <content type="html"><![CDATA[<p>Troisième partie sur la SPL et les listes chainées.</p>

<ul>
<li>partie 1 <a href="blog/2015/10/03/spl-surcharge-magique">SPL et surcharge</a></li>
<li>partie 2 <a href="blog/2015/10/10/liste-chainees-implementation">Implémentation</a></li>
</ul>


<p>Nous allons implémenter l&#8217;interface <code>ArrayAccess</code>. Donc notre liste chainée va se comporter comme un array.</p>

<p>Je vais rajouter deux méthodes. Attention les <code>Array</code> commencent traditionnellement à 0 d&#8217;où le <code>$this-&gt;count -1</code></p>

<ul>
<li><p>Supprimer le chainon N
&#8220;` php
 public function removeAtPosition($position)
 {
     if (!$this->validateInterval($position)) {
             throw new \Exception(&ldquo;L&#8217;index doit être valide&rdquo;);
     }</p>

<pre><code> if ($position == 0) {
     return $this-&gt;removeFirstValue();
 }

 if ($position  ==  $this-&gt;count -1 ) {
     return $this-&gt;removeLastValue();

 }
 $current = $this-&gt;first;
 $last = $current;
 for ($i = 0; $i &lt; $position; $i++) {
     $last = $current;
     $current = $current-&gt;getNext();
 }

 $last-&gt;setNext($current-&gt;getNext());

 return $this;
</code></pre>

<p> }
&#8220;`</p></li>
<li><p>Récupérer le chainon N
&#8220;` php
 public function getAtPosition($position)
 {
     if (!$this->validateInterval($position)) {
         throw new \Exception(&ldquo;L&#8217;index doit être numerique&rdquo;);
     }
     if ($position == 0) {
         return $this->first->getData();
     }</p>

<pre><code> if ($position == $this-&gt;count - 1) {
     return $this-&gt;last-&gt;getData();
 }

 $current = $this-&gt;first;
 for ($i = 0; $i &lt; $position; $i++) {
     $current = $current-&gt;getNext();
 }

 return $current-&gt;getData();
</code></pre>

<p> }</p></li>
</ul>


<pre><code>
Pour avoir le 9999 chainon,  il faut parcourir les 9998 chainons précédents.

Avec les deux méthodes précédentes. Il suffit d'implémenter les méthodes suivantes
</code></pre>

<pre><code>public function offsetSet($offset, $value) {
    if ($offset == null) {
        $this-&gt;insertAtEnd($value);
    } else {
        if (!$this-&gt;validateInterval($offset)) {
            throw new \Exception("L'index doit être valide");
        }
        $this-&gt;insertAtPosition($offset, $value);
    }
}

public function offsetExists($offset) {
    return $this-&gt;validInterval($offset);
}

public function offsetUnset($offset)
{
     return $this-&gt;removeAtPosition($offset);
}

public function offsetGet($offset)
{
    return $this-&gt;getAtPosition($offset);
}
</code></pre>

<pre><code>
Pour vérifier que les valeurs en entrée sont correctes j'utilise la fonction suivante 
</code></pre>

<pre><code>private function validateInterval($offset) {
    return (false !== filter_var(
        $offset,
        FILTER_VALIDATE_INT,
        array(
            'options' =&gt; array(
                'min_range' =&gt; 0,
                'max_range' =&gt; $this-&gt;count-1
            )
        )
    ));
}
</code></pre>

<pre><code>
Bon cela semble un peu abstrait, voici quelques exemples d'utilisations.
</code></pre>

<p>$list = new LinkedList();
$list[] = &ldquo;first&rdquo;;
$list[] = &ldquo;second&rdquo;;
$list[] = &ldquo;third&rdquo;;
//
var_dump(isset($list[1]));// => true
var_dump($list[1]); // => &ldquo;second&rdquo;
unset($list[1]);
var_dump($list[1]); // => third
<code>``
Nous avons une liste qui se comporte comme un array. c'est pratique, mais on ne peux pas faire de</code>foreach` dessus.. Enfin pas encore.</p>

<h2>Ajout de l&#8217;itérator</h2>

<p>Pour faire un itérator il faut implémenter l&#8217;interface suivante
<code>php
 Iterator extends Traversable {
/* Méthodes */
abstract public mixed current ( void )
abstract public scalar key ( void )
abstract public void next ( void )
abstract public void rewind ( void )
abstract public boolean valid ( void )
}
</code></p>

<p>Dans le cas de notre liste chainée cela n&#8217;est pas très compliqué.</p>

<pre><code class="php"> class LinkedList implements Countable, ArrayAccess, *Iterator* {
    .....   
    private $current;
    private $position = 0;
    ....

    public function current () {
        return $this-&gt;current-&gt;getData();
    }
    public function key () {
        return $this-&gt;position;

    }
    public function next () {
        $this-&gt;position++;
        $this-&gt;current = $this-&gt;current-&gt;getNext();

    }
    public function rewind () {
        $this-&gt;position = 0;
        $this-&gt;current = $this-&gt;first;

    }
    public function valid () {
        return $this-&gt;current !== null;
    }
</code></pre>

<p>Un petit code d&#8217;exemple</p>

<pre><code class="php">$list = new LinkedList();
//
$list[] = "first";
$list[] = "second";
$list[] = "third";
foreach($list as $key =&gt; $value) {
    var_dump("$key =&gt; $value");
}

// string(10) "0 =&gt; first"
// string(11) "1 =&gt; second"
// string(10) "2 =&gt; third"
</code></pre>

<p>Je peux a tout moment le retransformer en <code>array</code> grâce à la méthode <code>iterator_to_array($list)</code></p>

<pre><code class="php">
array(3) {
  [0] =&gt;
  string(5) "first"
  [1] =&gt;
  string(6) "second"
  [2] =&gt;
  string(5) "third"
}
</code></pre>

<p>Pour faire dans l&#8217;autre sens nous pouvons implémenter le constructor
<code>php
    public function __construct($input = null)
    {
        if ($input) {
            if (! (is_array($input) || $input instanceof Traversable)) {
                throw new \Exception("Un array ou Un iterator..");
            }
            foreach($input as $value) {
                $this-&gt;insertAtEnd($value);
            }
        }
    }
</code></p>

<p>Mon constructor prend un array ou un Objet qui implémente <code>Traversable</code> (en gros un Itérateur);</p>

<p>Quelques exemples
&#8220;` php
$list = new LinkedList(array(&ldquo;one&rdquo;, &ldquo;two&rdquo;, &ldquo;three&rdquo;));
foreach($list as $key => $value) {
    var_dump($value);
}
//string(3) &ldquo;one&rdquo;
//string(3) &ldquo;two&rdquo;
//string(5) &ldquo;three&rdquo;</p>

<p>$spl = New SplQueue();
$spl[] = &ldquo;travail1&rdquo;;
$spl[] = &ldquo;travail2&rdquo;;
$spl[] = &ldquo;travail3&rdquo;;
$list = new LinkedList($spl));
foreach($list as $key => $value) {
    var_dump($value);
}</p>

<p>// string(8) &ldquo;travail1&rdquo;
// string(8) &ldquo;travail2&rdquo;
// string(8) &ldquo;travail3&rdquo;</p>

<p>$linked = New LinkedList();
$linked[] = &ldquo;valeur 1&rdquo;;
$linked[] = &ldquo;valeur 2&rdquo;;
$linked[] = &ldquo;valeur 3&rdquo;;</p>

<p>$list = new LinkedList($linked);
foreach($list as $key => $value) {
    var_dump($value);
}
// string(9) &ldquo;valeur 1&rdquo;
// string(8) &ldquo;valeur 2&rdquo;
// string(8) &ldquo;valeur 3&rdquo;</p>

<p>&#8220;`</p>

<h2>En conclusion.</h2>

<p>Nous avons implémenter Les listes chainées avec toutes les méthodes. Mon exemple est un peu théorique. Mais je vous conseille de re-regarder les doctrines collections.</p>

<p>Merci de m&#8217;avoir lu.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Listes chainées : implémentation]]></title>
    <link href="http://mcamuzat.github.io/blog/2015/10/10/liste-chainees-implementation/"/>
    <updated>2015-10-10T21:12:47+02:00</updated>
    <id>http://mcamuzat.github.io/blog/2015/10/10/liste-chainees-implementation</id>
    <content type="html"><![CDATA[<p>Dans la <a href="/blog/2015/10/03/spl-surcharge-magique/">partie 1</a> nous avons appris à surcharger le <code>count</code> ainsi que les différentes méthodes de <code>ArrayAccess</code>. Pour faire un exemple un peu plus concret, je vais impémenter les listes chainées. Les listes doublement chainée sont <strong>déja</strong> implémentées dans la SPL via <a href="http://php.net/manual/fr/class.spldoublylinkedlist.php">SplDoublyLinkedList</a>.</p>

<p>Le liste chainée (linked list en anglais) est une structure de donnée. Nous allons essayer d&#8217;implémenter une liste chainée en PHP. Cela nous permettra de comprendre l&#8217;idée. Nous allons implémenter l&#8217;interface <code>Countable</code>. (J&#8217;implémente <code>ArrayAccess</code> et <code>Iterator</code> dans le post suivant).</p>

<p>Une liste chainée est constituée de <code>Node</code> ou noeud/chainon.</p>

<p>Un node a deux propriétés.</p>

<ul>
<li>Sa valeurs</li>
<li>Le liens vers le noeud suivant</li>
</ul>


<p>En php</p>

<pre><code class="php">class Node {
    private $data;
    private $next;
    public function __construct($data, Node $next = null)
    {
        $this-&gt;data = $data;
        $this-&gt;next = $next;
    }
    public function setData($data)
    {
        $this-&gt;data = $data;
    }
    public function getData()
    {
        return $this-&gt;data;
    }

    public function getNext()
    {
        return $this-&gt;next;
    }

    public function setNext(Node $next = null)
    {
        $this-&gt;next = $next;
    }

}
</code></pre>

<p>pour créer une liste rien de bien compliqué.</p>

<pre><code class="php ">$noeud1 = new Node(12);
$noeud2 = new Node(99);
$noeud3 = new Node(37);
$noeud1-&gt;setNext($noeud2);
$neoud2-&gt;setNext($noeud3);
</code></pre>

<p>Résultat le dessin suivant (wikipedia)</p>

<p>{% img center /images/linked-list.png 408 41 &lsquo;Une liste chainée&rsquo; &lsquo;Une liste chainée %}</p>

<h2>Implementation de la liste</h2>

<p>Nous allons créer des méthodes pour ajouter simplement nos chainons.</p>

<pre><code class="php">class LinkedList implements Countable, ArrayAccess, Iterator {

    private $first;
    private $last;
    private $count = 0;
    ... 
    // pour l'iterateur
    private $current;
    private $position = 0;

    // Permet d'afficher le contenu de la chaine. 
    public function printMe() {
        $current = $this-&gt;first;
        while ($current-&gt;getNext()) {
            echo "-{$current-&gt;getData()}-";
            $current = $current-&gt;getNext();

        }
        echo $current-&gt;getData();
    }


}
</code></pre>

<p>Nous allons traquer le premier élément de la chaine (<code>$this-&gt;first</code>) et le dernier (<code>$this-&gt;last</code>)</p>

<h3>Ajout d&#8217;un chainon à la fin</h3>

<p>C&#8217;est assez simple.</p>

<ul>
<li>Créer un nouveau noeud</li>
<li>Récupérer le dernier chainon</li>
<li>Faire pointer la propriété <code>next</code> du dernier chainon vers notre nouveau noeud.</li>
<li>Notre nouveau noeud devient le dernier noeud.</li>
<li>On augmente la taille de 1</li>
</ul>


<p>en code cela donne
&#8220;` php
    public function insertAtEnd($data) {
        // nouveau noeud
        $node = new Node($data);
        // si la liste est vide
        if ($this->first == null) {
            $this->first = $node;
        }
        // on ajoute le liens vers le suivant
        if (!$this->last == null) {
            $this->last->setNext($node);
        }
    // notre nouveau noeud devient le dernier
        $this->last = $node;
        // on augmente la taille.
        $this->count++;
        return $this;
    }</p>

<pre><code>
Exemple
</code></pre>

<p>$list = new LinkedList();
$list->insertAtEnd(&ldquo;ha&rdquo;)->insertAtEnd(&ldquo;hi&rdquo;);
$list->printMe() // -ha-hi
&#8220;`</p>

<h3>Ajout d&#8217;un chainon au début</h3>

<p>C&#8217;est un peu près la même idée.</p>

<ul>
<li>Créer un nouveau noeud</li>
<li>Récupérer le premier noeud.</li>
<li>Notre noeud pointe vers le premier noeud.</li>
<li>On pointe le <code>first</code> vers notre nouveau noeud.</li>
</ul>


<p>En code
<code>php
    public function insertFirstValue($data)
    {
       $node = new Node($data, $this-&gt;first);
       $this-&gt;count++;
       // si la liste est vide
       if ($this-&gt;last == null) {
            $this-&gt;last = $this-&gt;first;
       }
       $this-&gt;first = $node;
       return $this;
    }
</code></p>

<p>Un exemple</p>

<pre><code>$list = new LinkedList();
$list-&gt;insertAtEnd("first")-&gt;insertFirstValue("second");
$list-&gt;printMe(); // -second-first
</code></pre>

<h3>Suppression d&#8217;un chainon au début.</h3>

<p>Il faut faire dans l&#8217;autre sens.</p>

<p>En code
&#8220;` php
    public function removeFirstValue() {
       if ($this->count == 0) {
            throw new \Exception(&lsquo;La liste est vide&rsquo;);
       }
       $value = $this->first->getData();
       $this->count&ndash;;
       $this->first = $this->first->getNext();
       // si la liste est vide , reinitialiser le last
       if ($this->first == null) {
           $this->last = null;
       }
       return $value;
    }
$list = new LinkedList();
$list->insertAtEnd(&ldquo;first&rdquo;)->insertAtEnd(&ldquo;second&rdquo;);
$list->printMe(); // -first-second
var_dump($list->removeFirstValue());
$list->printMe(); //</p>

<pre><code>
### Suppression d'un chainon à la fin

Comme le dernier chainon ne connait pas son prédécesseur. C'est beaucoup plus compliqué. On est obligé de repartir depuis le début. Donc pour supprimer le dernier chainon d'un liste d'un million de chainon, il nous faut parcourir les 1 millions de chainons.

En Code 
</code></pre>

<pre><code>public function RemoveLastValue()
{
    // cas particulier la liste est vide
    if ($this-&gt;count == 0) {
        throw new \Exception('la Liste est vide');
    }
    // Il n'y a qu'un noeud.
    if ($this-&gt;count == 1) {
        $value = $this-&gt;last-&gt;getData();
        $this-&gt;first = null;
        $this-&gt;last = null;
        $this-&gt;count == 0;
        return $this-&gt;value;
    }
    // On parcours tout les chainons jusqu'à l'avant-dernier
    $current = $this-&gt;first-&gt;getNext();
    $previous = $this-&gt;first;
    while ($current-&gt;getNext()) {
         $previous = $current;
         $current = $current-&gt;getNext();
    }
    // on supprime le liens
    $previous-&gt;setNext(null);
    // On déplace le last
    $this-&gt;last = $previous;
    // on décremente
    $this-&gt;count--;
    return $current-&gt;getData();
}
</code></pre>

<pre><code>
### Ajouter une valeurs au milieu de la chaine

Même punition que pour supprimer un lien à la fin de la liste. Si on a une liste de 1 Millions de chainons. Pour insérer à la position 99999, nous sommes obligés de parcourir les 99999 chainons. Et pour la suppression ce sera pareil..

{% img center /images/LinkedLists-addingnode.png 474 116 'Ajout d'un chainon' 'Ajout d'un chainon' %}
</code></pre>

<pre><code>public function insertAtPosition($position, $data)
{
    if ($position &lt;= 0) {
        return $this-&gt;insertFirstValue($data);
    }

    if ($position &gt;= $this-&gt;count) {
        return $this-&gt;insertAtEnd($data);
    }

    $current = $this-&gt;first;
    for ($i = 1; $i &lt; $position; $i++) {
        $current = $current-&gt;getNext();
    }

    $node = new Node($data, $current-&gt;getNext());
    $current-&gt;setNext($node);

    $this-&gt;count++;
    return $this;
}
</code></pre>

<pre><code>
## Implementer le `count`

Si vous avez lu le [post précédent]() il suffit d'ajouter une méthode `count`
</code></pre>

<pre><code>public function count()
{
    return $this-&gt;count;
}
</code></pre>

<pre><code>
## Des applications avec la Liste chainée.

Si on renomme la méthode `insertAtEnd($data)` par `enqueue($job)` et la méthode `removeFirstValue()` par `dequeue()`

On obtient une file d'attente ou une `Queue` en anglais.
</code></pre>

<p>$fileAttente = new LinkedList();
$fileAttente->enqueue(&ldquo;job1&rdquo;)->enqueue(&ldquo;job2&rdquo;);
var_dump($fileAttente->dequeue()); // job1
// je rajoute un travail
$fileAttente->enqueue(&ldquo;OtherJob&rdquo;);
var_dump($fileAttente->dequeue()); // job2
var_dump($fileAttente->dequeue()); // OtherJob</p>

<pre><code>Si on renomme la méthode `insertFirstValue` en `push` et la méthode `removeFirstValue()` par `pop()` On obtient une Stack.

Voici le code pour inverser un array sans utiliser `array_reverse`
</code></pre>

<p>$list1 = array(1,2,3,4,5);
$stack = new LinkedList();
foreach ($list as $value) {
    $stack->push($value);
}
$list2 = array();
while (stack->count()) {
    $list2[] = $stack->pop(); <br/>
}
var_dump($list2) //[5,4,3,2,1];
&#8220;`</p>

<h2>Conclusion</h2>

<p>Un ancien livre est titré</p>

<blockquote><blockquote><p>Algorithms + Data Structures = Programs</p></blockquote></blockquote>

<p>On a tendance en language php à penser tout en Object et en Array. Parfois la façon dont on représente nos données est importante.</p>

<ul>
<li>Certaines opérations comme ajouter un lien au début/fin de la chaine sont très peu couteuses (une étape) on parle de complexité O(1);</li>
<li>supprimer un lien à la fin de la liste par contre prend N étapes On dit que la complexité est de O(N)</li>
</ul>


<p>Pour résoudre ce problème on a inventé les listes doublements chainées. Voir le dessin (Wikipédia);</p>

<p>{% img center /images/Doubly-linked-list.png 610 41 &lsquo;doubles listes chainée&rsquo; &lsquo;double liste chainée&rsquo; %}</p>

<p>Cela prend beaucoup plus de mémoire, mais on simplifie beaucoup l&#8217;ajout et la suppression au début et à la fin de liste. par contre la recherche dans une liste chainée est toujours aussi longue.</p>

<p>Mon post sur les <a href="blog/2015/08/29/stacks-structures-meconnues/">Stack</a>.</p>

<p>Dans le post suivant on implémentera les méthodes de <code>ArrayAccess</code> et <code>Iterator</code>, ce qui nous permettra de faire des <code>foreach</code> ou <code>isset($list[2])</code> etc ..</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SPL surcharge magique]]></title>
    <link href="http://mcamuzat.github.io/blog/2015/10/03/spl-surcharge-magique/"/>
    <updated>2015-10-03T17:17:33+02:00</updated>
    <id>http://mcamuzat.github.io/blog/2015/10/03/spl-surcharge-magique</id>
    <content type="html"><![CDATA[<p>Nous allons repartir sur la <a href="http://php.net/manual/fr/book.spl.php">SPL</a>.</p>

<p>Je vais parler des différentes méthodes amusantes à surcharger.</p>

<h2>Count</h2>

<p>Soit la classe suivante</p>

<pre><code class="php">class BadCounter implements countable{
    public function count() {
        return 42;
    }
}

$counter = new BadCounter();

var_dump(count($counter));// int(42)
</code></pre>

<p>On peux surcharger la méthode <code>count</code>. C&#8217;est d&#8217;ailleurs le cas dans le cas du <a href="http://doctrine-orm.readthedocs.org/en/latest/tutorials/pagination.html">Paginator</a> de doctrine.</p>

<pre><code class="php">
$dql = "SELECT p, c FROM BlogPost p JOIN p.comments c";
$query = $entityManager-&gt;createQuery($dql)
                       -&gt;setFirstResult(0)
                       -&gt;setMaxResults(10);

$paginator = new Paginator($query);

count($paginator) // nombre de lignes dans la base
</code></pre>

<h2>Les ArrayObjects</h2>

<p>On peut aussi changer toutes les méthodes pour un tableau.</p>

<ul>
<li><code>isset(counter['valeur'])</code></li>
<li><code>unset(counter['valeur'])</code></li>
<li><code>counter['valeur'] = 3</code></li>
<li><code>counter[] = 3</code></li>
<li><code>counter['valeur']</code></li>
</ul>


<pre><code class="php">
class GeekCounter implements Countable, ArrayAccess {
    public function count() {
        return 42;
    }
    public function offsetSet($offset, $value) {
        if (is_null($offset)) {
            echo("on ajoute $value \n");

        } else {
            echo("on change la clé $offset par $value \n");
        }
    }

    public function offsetExists($offset) {
        echo("on teste la clé  $offset \n");
        return true;
    }

    public function offsetUnset($offset) {
        echo("on unset la clé $offset \n");
    }

    public function offsetGet($offset) {
        echo("on me demande la clé $offset \n");
        return 42;
    }
}

$counter = new GeekCounter();

var_dump(isset($counter["IdontCare"]));
var_dump($counter["IdontCare"]);
unset($counter["IdontCare"]);
$counter[] = 3;
$counter["IdontCare"] = 3;
</code></pre>

<pre><code class="php">on teste la clé  IdontCare 
bool(true)
on me demande la clé IdontCare 
int(42)
on unset la clé IdontCare 
on ajoute 3 
on change la clé IdontCare par 3 
</code></pre>

<p>On trouve la même idée dans les collections de doctrine.(l&#8217;interface <code>Collection</code> n&#8217;est qu&#8217;une surcharge);</p>

<p>Si on ne souhaite pas tout implémenter il suffit de surcharger la Classe <code>ArrayObject</code></p>

<p>Par exemple:
&#8220;` php
class ZooDeBeauval extends ArrayObject {
    public function offsetSet($offset, $value) {
        if (!in_array($value, array(&ldquo;Panda&rdquo;, &ldquo;Koala&rdquo;, &ldquo;Otarie&rdquo;))) {
            echo &ldquo;non cet animal $value n&#8217;est pas autorisé&rdquo;;
        } else {
            parent::offsetSet($offset, $value);
        }</p>

<pre><code>}
</code></pre>

<p>}</p>

<pre><code>Un exemple
</code></pre>

<p>$zoo = new ZooParcDeBeauval();
$zoo[] = &lsquo;Panda&rsquo;;
$zoo[] = &lsquo;Koala&rsquo;;</p>

<p>echo &ldquo;liste :  &rdquo;.implode(&lsquo;, &rsquo;, iterator_to_array($zoo)) . PHP_EOL;
$zoo[] = &lsquo;Lama&rsquo;;
&#8220;`</p>

<p>le résultat</p>

<pre><code class="php">liste :  Panda, Koala
non cet animal Lama n'est pas autorisé
</code></pre>

<p>Pour les <code>foreach</code> j&#8217;ai déjà parlé des iterators et des <a href="blog/2015/09/06/php-yield-les-generateurs/">générateurs</a>.</p>

<h2>Conclusion</h2>

<p>Maintenant les interfaces <code>ArrayAccess</code> et <code>Countable</code> n&#8217;ont plus de secrets pour vous. Nous verrons dans un prochain Post les listes chainées. L&#8217;avantage de ces méthode est que l&#8217;on obtient une structure qui se comporte comme un <code>array</code> mais avec une occupation mémoire moindre.</p>

<p>Dans un prochain post, je vais parler des listes chainées et des différentes structure de la SPL (j&#8217;ai déja parlé de la <a href="blog/2015/08/29/stacks-structures-meconnues/">SplStack</a>)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Les stacks des structures méconnues]]></title>
    <link href="http://mcamuzat.github.io/blog/2015/08/29/stacks-structures-meconnues/"/>
    <updated>2015-08-29T16:34:41+02:00</updated>
    <id>http://mcamuzat.github.io/blog/2015/08/29/stacks-structures-meconnues</id>
    <content type="html"><![CDATA[<h2>Introduction</h2>

<p>Je vais parler de <code>SplStack</code> une structure de donnée qui fait partie de La SPL (pour <strong>S</strong>tandart <strong>P</strong>HP <strong>L</strong>ibrairie). Nous allons voir trois façons de nous servir de cette structure.</p>

<h2>Les Stacks ou Piles</h2>

<p>La pile n&#8217;a que deux opérations.</p>

<ul>
<li>Empiler ou Push On ajoute une donnée sur le haut de la pile.</li>
<li>Dépiler ou Pop On retire une donnée du haut de la pile.</li>
</ul>


<p>Il n&#8217;y a que le haut de la pile qui est visible. La pile est une mémoire LIFO (<strong>L</strong>ast <strong>I</strong>n <strong>F</strong>irst <strong>O</strong>ut).</p>

<p>Quelques exemples.</p>

<pre><code class="php">$pile = new SplStack(); // la pile est vide []
$pile-&gt;push(34) // [34]
$pile-&gt;push(45) // [34, 45]
$value = $pile-&gt;pop() // [34]
$pile-&gt;push('a') // [34, 'a']
$value = $pile-&gt;top() // $value = 'a' pile [34, 'a']
</code></pre>

<p>On peux utiliser les array comme des piles avec <code>array_pop</code> et <code>array_push</code>. Mais depuis PHP 5.0 il existe une Classe tout faite <code>SplStack</code></p>

<h2>Premiere application la machine à pile</h2>

<p>Il faut d&#8217;abord que je vous parle de la notation polonaise inverse. (RPN en anglais pour <strong>R</strong>everse <strong>P</strong>olish <strong>N</strong>otation).
<code>1 + 3</code> devient <code>1 3 +</code>. Pour faire simple je mets l&#8217;opérateur à la fin.</p>

<p>des exemples un peu plus complexe.</p>

<p> <code>1 + 2 * 3</code> devient <code>2 3 * 1 +</code> et <code>( 1 + 3 ) * ( 3 - 4 )</code> devient <code>1 3 + 3 4 - *</code></p>

<p>C&#8217;est un peu compliqué comme notation (en tout cas pas naturelle) mais nous allons voir que l&#8217;algorithme pour le calcul est très simple.</p>

<p>Voici l&#8217;algorithme :</p>

<ul>
<li>Si l&#8217;entrée est un entier : je l&#8217;empile</li>
<li>Si c&#8217;est une opération : je dépile deux valeurs, je fais l&#8217;opération et j&#8217;empile le résultat</li>
</ul>


<p>Un exemple</p>

<pre><code class="">soit 1 3 + 3 4 - * 
# je prend la premiere valeur "1" c'est un chiffre je l'empile
ma pile [ *1* ] 
# je prend la seconde valeur "3" c'est un chiffre je l'empile
ma pile [ 1 *3* ]
# je prend la valeurs 3 c'est une operation "+", je depile deux valeurs d'abords "3" puis "1". je fais l'addition. "4" que j'empile
ma pile [ *4* ]
# je prend la quatrieme valeur "3" c'est un chiffre j'empile
ma pile [ 4 *3* ]
# la cinquieme valeurs est un chiffre
ma pile [ 4 3 *4*]
# la sixieme valeur est une opération. je dépile deux valeurs "4" et "3" que je soustrait et je rempile
ma pile [ 4 *-1*]
# la septième valeur est une opération je dépile "-1" et "4" que je multiplie
ma pile ["-4"]
</code></pre>

<p>L&#8217;avantage de la notation est qu&#8217;elle n&#8217;a pas besoin de parenthèse. Il n&#8217;y pas d&#8217;ambigüité <code>( 1 + 3 ) * ( 3 - 4 )</code> est différent de  <code>1 + 3 * 3 - 4</code>.</p>

<p>L&#8217;implémentation est simple</p>

<pre><code class="php">function execute(array $ops)
{
    $stack = new \SplStack();

    foreach ($ops as $op) {
        if (is_numeric($op)) {
            $stack-&gt;push((int) $op);
            continue;
        }

        switch ($op) {
            case '+':
                $stack-&gt;push($stack-&gt;pop() + $stack-&gt;pop());
                break;
            case '-':
                $n = $stack-&gt;pop();
                $stack-&gt;push($stack-&gt;pop() - $n);
                break;
            case '*':
                $stack-&gt;push($stack-&gt;pop() * $stack-&gt;pop());
                break;
            case '/':
                $n = $stack-&gt;pop();
                $stack-&gt;push($stack-&gt;pop() / $n);
                break;
            default:
                throw new \InvalidArgumentException(sprintf('Invalid operation: %s', $op));
                break;
        }
    }

    return $stack-&gt;top();
}
</code></pre>

<p>essayons notre exemple.</p>

<pre><code class="php">var_dump(execute(explode(' ', '1 3 + 3 4 - *');
int(-4)
</code></pre>

<p>Félicitation nous venons d&#8217;implémenter notre première machine à pile. La plus célèbre est la <code>Java Virtual Machine</code>. Il existe aussi des langages qui sont basé sur la notion de pile, le plus célèbre est le <a href="https://fr.wikipedia.org/wiki/Forth_%28langage%29">Forth</a> et le <a href="https://fr.wikipedia.org/wiki/PostScript">Postscript</a>(si si le format de adobe). L&#8217;avantage des machines à pile est qu&#8217;elle n&#8217;utilise aucun autre registre que la pile.</p>

<h2>Le Shunting-yard de Dijkstra</h2>

<p>Je présente une version simplifié. <em>Shunting-yard</em> peut se traduire en <strong>Aiguillage</strong>. Il permet d&#8217;évaluer une expression mathématique.</p>

<p>Soit la chaîne suivante:</p>

<pre><code class="php">var_dump($calculate(explode(' ', '( ( 1 + 3 ) * ( 3 - 4 ) )')));

# int(-4)
</code></pre>

<ul>
<li>Il y a des parenthèses partout</li>
<li>L&#8217;arité des fonction est 2:  l&#8217;arité est le nombre d&#8217;argument par exemple 1 + 2 est d&#8217;arité 2 deux arguments. L&#8217;algorithme que je présente est incapable de faire <code>1 + 2 + 3</code> mais fera très bien <code>(1 + ( 2 + 3 ))</code>.</li>
</ul>


<p>Voici l&#8217;algorithme:</p>

<ul>
<li>Si parenthèse ouvrante:  je passe</li>
<li>Si c&#8217;est une opération <code>+</code>, <code>-</code>, <code>/</code>, <code>*</code>:  Je stocke dans une pile l&#8217;opération.</li>
<li>Si c&#8217;est un chiffre : je stocke dans une pile de valeurs</li>
<li>Si c&#8217;est une parenthèse fermante: Je dépile une opération et je dépile deux arguments. Je fais l&#8217;opération avec mes deux arguments et je remets le résultats dans ma pile.</li>
</ul>


<p>Voici le code</p>

<pre><code>function calculate(array $input)
{
    $operators = new SplStack();
    $values = new SplStack();

    foreach ($input as $token) {
        switch ($token) {
        case "(":
            break;
        case "+":
        case "-":
        case "*":
        case "/":
            $operators-&gt;push($token);
            break;
        case ")":
            $op = $operators-&gt;pop();
            $value = $values-&gt;pop();
            switch ($op) {
            case "+":
                $value = $values-&gt;pop() + $value;
                break;
            case "-":
                $value = $values-&gt;pop() - $value;
                break;
            case "*":
                $value = $values-&gt;pop() * $value;
                break;
            case "/":
                $value = $values-&gt;pop() / $value;
                break;
            }
            $values-&gt;push($value);
            break;
        default:
            $values-&gt;push($token);

        }

    }
    return $values-&gt;top();
}
</code></pre>

<p>On utilise deux piles. Une pour les opérations, Une pour les valeurs
je propose de faire le même exemple que plus haut
je vais représenter les deux piles et l&#8217;entrée actuelle</p>

<pre><code>operators :  [] values:  []  expression : ( ( 1 + 3 ) * ( 3 - 4 ) )

# '(' on ignore

operators [] values []  expression : ( 1 + 3 ) * ( 3 - 4 ) )

# '(' on ignore
operators [] values []  expression: 1 + 3 ) * ( 3 - 4 ) )

# '1' on ajoute dans values
operators [] values [*1*] expression:  + 3 ) * ( 3 - 4 ) )

# '+' on ajoute dans opérator
operators [*+*] values [1] expression: 3 ) * ( 3 - 4 ) )

# '3' on ajoute dans value
operators [*+*] values [1, *3*] expression: ) * ( 3 - 4 ) )

# ')' on dépile deux valeur de value et on depile une valeurs de l'operators et on empile le résultats dans values
operators [] values [4] expression:  * ( 3 - 4 ) )`

# '*' on ajoute dans opérator 
operators [*] values [4] expression:  ( 3 - 4 ) )

# '(' on ignore
operators [*] values [4] expression:  3 - 4 ) )

# '3' on ajoute dans values 
operators [*] values [4 *3*] expression:  - 4 ) )

# '-' on ajoute dans operators
operators [*, *-*] values [4 3] expression:  4 ) )

# '4' on ajoute dans values 
operators [*, ] values [4 3 4] expression:  ) )

# ')' on dépile deux valeur de value et on depile une valeur de operators et on empile le résultat dans values
operators [*] values [4 -1] expression:  )

# ')' on dépile deux valeur de values et on depile une valeur de operators et on empile le résultat dans values
operators [] values [-4] expression: 
</code></pre>

<p>On se rend compte que cette algorithme très simple permet de calculer toutes les expressions que l&#8217;on passe du moment qu&#8217;elles sont bien formées.</p>

<pre><code class="php">$expression = "( ( 1 + 3 ) * ( 3 - 4 ) )"
var_dump(calculate(explode(" ", $expression)));
</code></pre>

<p>Félicitation vous venez d&#8217;écrire votre premier interpréteur.</p>

<p>la version originale prend en compte la priorité des opérations (cela rend certaines parenthèses inutiles) c&#8217;est un peu plus complexe, mais pas tant que cela.</p>

<h2>Exemple 3 conversion vers RPN</h2>

<p>Nous allons utiliser notre pile pour traduire notre expression vers la RPN.</p>

<p>C&#8217;est à dire  <code>( ( 1 + 3 ) * ( 3 - 4 ) )</code> -> <code>1 3 + 3 4 - *</code></p>

<p>Voici l&#8217;algorithme.</p>

<ul>
<li>Si l&#8217;entrée est un parenthèse ouvrante :  je passe</li>
<li>Si c&#8217;est une opération : je stocke cela dans une pile</li>
<li>Si c&#8217;est un entier : Je pousse cela dans une file d&#8217;attente</li>
<li>Si c&#8217;est une parenthèse fermante : je vide la pile dans la file d&#8217;attente.</li>
</ul>


<pre><code>function transformate(array $input)
{
    $stack = new SplStack();
    $output = new SplQueue();

    foreach ($input as $token) {
        switch ($token) {
        case "(":
            break;
        case "+":
        case "-":
        case "*":
        case "/":
            $stack-&gt;push($token);
            break;
        case ")":
            while(count($stack)&gt; 0 &amp;&amp; $stack-&gt;top()) {
                $output-&gt;enqueue($stack-&gt;pop());
            }
            break;
        default:
            $output-&gt;enqueue($token);
        }
    }
    return iterator_to_array($output);
}
</code></pre>

<p>regardons avec le même exemple</p>

<pre><code>stack :  [] output:  []  expression : ( ( 1 + 3 ) * ( 3 - 4 ) )

# '(' on ignore

stack : [] output: []  expression : ( 1 + 3 ) * ( 3 - 4 ) )

# '(' on ignore
stack :  [] output []  expression: 1 + 3 ) * ( 3 - 4 ) )

# '1' on ajoute dans output
stack: [] output [1] expression:  + 3 ) * ( 3 - 4 ) )

# '+' on ajoute dans la stack
stack: [*+*] output [1] expression: 3 ) * ( 3 - 4 ) )

# '3' on ajoute dans output
stack: [*+*] output [1, *3*] expression: ) * ( 3 - 4 ) )

# ')' on vide stack dans outputs
stack: [] output [ 1, 3, *+*] expression:  * ( 3 - 4 ) )`

# '*' on ajoute dans la stack
stack: [*] output [1 , 3 , +] expression:  ( 3 - 4 ) )

# '(' on ignore
stack: [*] output [1, 3, +] expression:  3 - 4 ) )

# '3' on ajoute dans output.
stack: [*] output [1, 3, +, *3*] expression:  - 4 ) )

# '-' on ajoute dans la stack
stack: [*, *-*] output [1, 3, +, 3] expression:  4 ) )

# '4' on ajoute dans output.
stack: [*,-] output [1, 3, +, 3, *4*] expression:  ) )

# ')' on depile la stack dans output, on dépile d'abords - puis *
stack: [] output [1, 3, +, 3, 4, -, *] expression:  )

# ')' on re depile la stack mais ici elle est déja vide. 
</code></pre>

<p>Il suffit de transformer en array <code>$output</code> pour avoir le résultats suivants
<code>( ( 1 + 3 ) * ( 3 - 4 ) )</code> -> <code>1 3 + 3 4 - *</code></p>

<h2>Tous ensemble.</h2>

<p>Je ne resiste pas au plaisir d&#8217;utiliser l&#8217;instruction tabou du php <code>eval()</code></p>

<blockquote><p>If eval() is the answer, you&rsquo;re almost certainly asking the wrong question. &ndash; Rasmus Lerdorf, BDFL of PHP</p></blockquote>

<pre><code>$operation = "( ( 1 + 3 ) * ( 3 - 4 ) )";
$input = explode(" ", $operation);
var_dump(calculate($input));
var_dump(execute(transformate($input)));
var_dump($value = eval("return ($operation);"));
</code></pre>

<p>Nous avons sans surprise le même résultat
<code>
int(-4)
int(-4)
int(-4)
</code></p>

<h2>En conclusion</h2>

<ul>
<li>Nous avons créé une <em>VM</em> Notre machine à pile.</li>
<li>Nous avons crée un <em>interpréteur</em>:  notre algorithme de shunting-yard</li>
<li>Nous avons fait un traducteur de notre expression vers notre machine à pile. C&#8217;est un <em>compilateur</em>.</li>
<li>La notion de pile existe partout, on parle de pile d&#8217;appel (<em>stack-frame</em>), de dépassement de la pile (<em>stack overflow</em>), <code>git stash</code> est aussi un stockage en pile.</li>
</ul>


<h2>Des références.</h2>

<ul>
<li>L&#8217;algorithme simplifie viens du livre <a href="http://www.amazon.fr/dp/032157351X">Algorithms</a> de Sedgewick (j&#8217;ai traduis du Java vers Php)</li>
<li>L&#8217;exemple le plus complet sur les stacks-machine est <a href="https://igor.io/archive.html">Igor.io</a> la série est superbe, l&#8217;auteur explique vraiment bien.</li>
<li>L&#8217;article de wikipedia sur le <a href="https://en.wikipedia.org/wiki/Shunting-yard_algorithm">shunting-yard</a> Les illustrations montrent bien la notion d&#8217;aiguillage.</li>
<li><a href="https://fr.wikipedia.org/wiki/Edsger_Dijkstra">Edsger W. Dijkstra</a> est surtout connus pour son algorithme sur le plus court chemin. Mais c&#8217;est une légende de l&#8217;informatique. A voir si vous ne connaissez pas.</li>
</ul>

]]></content>
  </entry>
  
</feed>
