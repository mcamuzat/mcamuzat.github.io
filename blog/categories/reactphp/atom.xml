<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Reactphp | Mon blog perso.]]></title>
  <link href="http://mcamuzat.github.io/blog/categories/reactphp/atom.xml" rel="self"/>
  <link href="http://mcamuzat.github.io/"/>
  <updated>2015-09-13T21:47:34+02:00</updated>
  <id>http://mcamuzat.github.io/</id>
  <author>
    <name><![CDATA[mcamuzat]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Yield PHP Co-routine]]></title>
    <link href="http://mcamuzat.github.io/blog/2015/09/13/yield-php-co-routine/"/>
    <updated>2015-09-13T20:31:37+02:00</updated>
    <id>http://mcamuzat.github.io/blog/2015/09/13/yield-php-co-routine</id>
    <content type="html"><![CDATA[<p>Nous allons continuer sur le <em>yield</em> <a href="/blog/2015/09/06/php-yield-les-generateurs/">partie1</a></p>

<p>Nous avons vu la fonction xrange qui permet de générer un million de valeurs pour un coup très faible en mémoire.</p>

<p>Mais il y a mieux ! On peux envoyer des valeurs dans le générateur
&#8220;` php
&lt;?php
function generateAnimal() {
    $input = (yield &lsquo;Panda&rsquo;);
    var_dump(&ldquo;j&#8217;ai reçu $input&rdquo;);
    $input = (yield &lsquo;Lama&rsquo;);
    var_dump(&ldquo;j&#8217;ai reçu $input&rdquo;);
}</p>

<p>$gen = generateAnimal();
var_dump($gen->current());// string(5) &ldquo;Panda&rdquo;
var_dump($gen->send(&lsquo;Canard&rsquo;));//string(16) &ldquo;j&#8217;ai recu Canard&rdquo;
                               //string(4) &ldquo;Lama&rdquo;
var_dump($gen->send(&lsquo;Poney&rsquo;)); // j&#8217;ai recus Poney.
&#8220;`</p>

<p>Si j&#8217;avais fais deux fois <code>-&gt;next()</code>  au lieux de <code>-&gt;send()</code></p>

<pre><code class="php">$gen = generateAnimal();
var_dump($gen-&gt;current());// string(5) "Panda"
var_dump($gen-&gt;next());//string(16) "j'ai recu NULL"
                               //string(4) "Lama"
var_dump($gen-&gt;next()); // j'ai recus NULL.
</code></pre>

<h2>Les Co-routines</h2>

<p>Une co-routine est une fonction qui peut se suspendre en reprendre quand on le souhaite.</p>

<p>Nous allons faire une classe <code>Task</code>  pour mieux comprendre.</p>

<pre><code class="php">class Task
{
    protected $generator;

    protected $firstCall = true;

    public function __construct(Generator $generator)
    {
        $this-&gt;generator = $generator;
    }

    public function run()
    {
        if ($this-&gt;firstCall) {
            $this-&gt;generator-&gt;current();
        } else {
            $this-&gt;generator-&gt;next();
        }

        $this-&gt;firstCall = false;
    }

    public function finished()
    {
        return !$this-&gt;generator-&gt;valid();
    }
}
</code></pre>

<p>J&#8217;ai besoin d&#8217;un Runner</p>

<pre><code class="php">
class Runner
{
    public function __construct(Task $task)
    {
        $this-&gt;task = $task;
    }

    public function run()
    {
        while (!$this-&gt;task-&gt;finished()) {
            $this-&gt;task-&gt;run();
        }
    }
}
</code></pre>

<p>Un petit code d&#8217;exemple</p>

<pre><code>function task1() {
    for ($i = 1; $i &lt;= 10; ++$i) {
        echo "This is task 1 iteration $i.\n";
        yield;
    }
}

$task = new Task(task1());
$runner = new Runner($task);
$runner-&gt;run();
</code></pre>

<p>Cela donne</p>

<pre><code>This is task 1 iteration 1.
This is task 1 iteration 2.
This is task 1 iteration 3.
This is task 1 iteration 4.
This is task 1 iteration 5.
This is task 1 iteration 6.
This is task 1 iteration 7.
This is task 1 iteration 8.
This is task 1 iteration 9.
This is task 1 iteration 10.
</code></pre>

<p>J&#8217;ai un objet Task qui appelle une fonction et qui rend la main à chaque itération. Cela semble compliqué pour une seule tache. Mais modifions le code pour avoir plusieurs taches.</p>

<pre><code>class Scheduler
{
    protected $queue;

    public function __construct()
    {
        $this-&gt;queue = new SplQueue();
    }

    public function enqueue(Task $task)
    {
        $this-&gt;queue-&gt;enqueue($task);
    }

    public function run()
    {
        while (!$this-&gt;queue-&gt;isEmpty()) {
            $task = $this-&gt;queue-&gt;dequeue();
            $task-&gt;run();

            if (!$task-&gt;finished()) {
                $this-&gt;enqueue($task);
            }
        }
    }
}
</code></pre>

<p>Bon toute la magie est faite grâce à la <code>SplQueue</code> qui est une file d&#8217;attente. J&#8217;ajoute dans la file d&#8217;attente toutes les taches.</p>

<p>Je prend une tache de la file d&#8217;attente. Je l&#8217;exécute avec <code>-&gt;run()</code>, si la tache n&#8217;est pas finie, je la remets dans la file d&#8217;attente.</p>

<p>Reprenons un code d&#8217;exemple</p>

<pre><code class="php">function task1() {
    for ($i = 1; $i &lt;= 10; ++$i) {
        echo "This is task 1 iteration $i.\n";
        yield;
    }
}

function task2() {
    for ($i = 1; $i &lt;= 5; ++$i) {
        echo "This is task 2 iteration $i.\n";
        yield;
    }
}

$task1 =  new Task(task1());
$task2 = new Task(task2());
$scheduler = new Scheduler();
$scheduler-&gt;enqueue($task1);
$scheduler-&gt;enqueue($task2);
$scheduler-&gt;run();
</code></pre>

<p>Le résultat.</p>

<pre><code>This is task 1 iteration 1.
This is task 2 iteration 1.
This is task 1 iteration 2.
This is task 2 iteration 2.
This is task 1 iteration 3.
This is task 2 iteration 3.
This is task 1 iteration 4.
This is task 2 iteration 4.
This is task 1 iteration 5.
This is task 2 iteration 5.
This is task 1 iteration 6.
This is task 1 iteration 7.
This is task 1 iteration 8.
This is task 1 iteration 9.
This is task 1 iteration 10.
</code></pre>

<p>On voit que j&#8217;exécute en parallèle toutes mes deux taches.</p>

<h2>En conclusion</h2>

<p>Il existe deux librairies qui utilise ce concept</p>

<ul>
<li><a href="https://github.com/icicleio/icicle">Icicle</a></li>
<li><a href="https://github.com/recoilphp/recoil">recoil</a></li>
</ul>


<p>Cette façon d&#8217;implémenter est assez curieuse. Car le code ne ressemble pas au code classique asynchrone avec des callbacks et autre événements. Si on regarde bien cela ressemble beaucoup a du code synchrone. Elle est inspirée du <code>C#</code> <code>async/wait</code>. On a l&#8217;impression que cela ressemble a du code synchrone où on ajoute des <code>yield</code> un peu partout. (en simplifiant beaucoup..)</p>

<p>Il y a peu de documentation et d&#8217;exemple sur le sujet.</p>

<ul>
<li>la référence est ce post de <a href="http://nikic.github.io">Nikic</a>: <a href="https://nikic.github.io/2012/12/22/Cooperative-multitasking-using-coroutines-in-PHP.html">Cooperative multitasking using coroutines (in PHP!)</a></li>
<li>Une version légèrement simplifié dont je me suis inspiré pour le code <a href="https://medium.com/@assertchris/co-operative-php-multitasking-ce4ef52858a0">Co-operative PHP Multitasking</a></li>
</ul>


<p>Je vais essayer de continuer avec le yield et repartir sur les promises.</p>

<p>Merci de m&#8217;avoir lu.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Les Promises Et Php via ReactPhp]]></title>
    <link href="http://mcamuzat.github.io/blog/2015/09/05/les-promises-et-php-via-react/"/>
    <updated>2015-09-05T19:10:10+02:00</updated>
    <id>http://mcamuzat.github.io/blog/2015/09/05/les-promises-et-php-via-react</id>
    <content type="html"><![CDATA[<p>Les promises sont une alternative plus puissante au Callback. Relativement peu connues au début. Elle sont maintenant en standard dans beaucoup de langage javascript ES6, python 3.2, java. Où via des librairies comme <a href="https://github.com/reactphp/promise">react/promise</a> pour php</p>

<p>Une promise représente une valeur donc le résultat n&#8217;est pas encore connu.
Quand le résultat est connu,  la promise a 3 états possibles</p>

<ul>
<li><strong>Pending</strong> ou <strong>Unfulfillled</strong>  en Attente..</li>
<li><strong>Resolved</strong> ou <strong>fulfillled</strong>  Succès</li>
<li><strong>Rejected</strong> ou <strong>Failed</strong>  Erreur.</li>
</ul>


<p>Un <em>Deffered</em> représente un travail qui n&#8217;est pas encore fini. Donc un <em>Deferred</em> possède une promise (une valeur pas encore connues).</p>

<p>Quand la valeur est connue, la promesse utilise un <em>handler</em> (en général <code>-&gt;then()</code>) qui lui-même renvoie une promise. L&#8217;intérêt est que les promises sont chainables.</p>

<p>Mais essayons quelques exemples qui seront un peu plus parlant.</p>

<p>Pour ce faire nous allons d&#8217;abord installer <a href="https://github.com/reactphp/promise">react/promises</a></p>

<pre><code class="php">&lt;?php
require __DIR__.'/vendor/autoload.php';

// On crée un travail
$deferred = new React\Promise\Deferred();

// On veux la promise
$promise  = $deferred-&gt;promise()-&gt;then(
    function () { echo "tout va bien \n"; },
    function () { echo "tout va mal \n"; },
    function () { echo "j'attends\n "; }
);


// Le travail est un succes, on résoud la promise
$deferred-&gt;resolve(); 
</code></pre>

<p>Voici ce que j&#8217;obtiens si je lance le programme.</p>

<pre><code class="php">tout va bien
</code></pre>

<p>Si je remplace <code>$deferred-&gt;resolve()</code> par <code>$deferred-&gt;reject()</code>. Le travail n&#8217;as pas marché. J&#8217;obtiens</p>

<pre><code class="php">Tout va mal
</code></pre>

<p>La syntaxe de <code>then</code> est</p>

<pre><code class="php">then(callable $onFulfilled = null, callable $onRejected = null, callable $onProgress = null)
</code></pre>

<ul>
<li>Si l&#8217;action est un succès, On résous la promise en appelant la fonction <code>$onFulfilled</code>.</li>
<li>L&#8217;action n&#8217;est pas bonne, On rejette la promise avec <code>$onRejected</code>.</li>
<li>Si l&#8217;action est en cours , On appelle <code>$onProgress</code>.</li>
</ul>


<p>A noter qu&#8217;une promise une fois qu&#8217;elle est résolue ou rejetée ne peut plus être réutilisée sauf dans le cas du <code>pending</code></p>

<pre><code class="php">$promise-&gt;notify();
$promise-&gt;notify();
$promise-&gt;notify();
$promise-&gt;resolve();
</code></pre>

<p>Le résultat</p>

<pre><code class="">j'attends
j'attends
j'attends
tout va bien
</code></pre>

<p>Pour l&#8217;instant rien de bien compliqué. On peut chainer les promises</p>

<pre><code class="php ">$promise  = $deferred-&gt;promise()-&gt;then(
    function () { echo "action 1 ok\n"; }
)-&gt;then(
    function () { echo "action 2 ok\n";}
)-&gt;then(
   function () { echo "action 3 ok\n";},
   function () { echo "une des actions n'est pas ok..\n";}
);

$deferred-&gt;resolve();
</code></pre>

<p>Le résultat
<code>
action 1 ok
action 2 ok
action 3 ok
</code></p>

<p>Essayons avec <code>deffered-&gt;reject()</code></p>

<p>Le résultat</p>

<pre><code>une des actions n'est pas ok..
</code></pre>

<p>Ajoutons un exception à la deuxième étape.
&#8220;` php
$promise  = $deferred->promise()->then(
    function () { echo &ldquo;action 1 ok\n&rdquo;; }
)->then(
    function () { throw new Exception();}
)->then(
   function () { echo &ldquo;action 3 ok\n&rdquo;;},
   function () { echo &ldquo;une des actions n&#8217;est pas ok..\n&rdquo;;}
);</p>

<pre><code>
Le résultat
</code></pre>

<p>action 1 ok
une des actions n&#8217;est pas ok..
&#8220;`</p>

<p>Ajoutons une exception dans le premier, et ajoutons un cas pour gérer l&#8217;erreur
&#8220;` php
$promise  = $deferred->promise()->then(
    function () { throw new \Exception(); }
)->then(
    function () { echo &ldquo;action 2 ok\n&rdquo;;},
    function () { echo &ldquo;l&#8217;action 1 pas ok mais on continue..\n&rdquo;;}
)->then(
   function () { echo &ldquo;action 3 ok\n&rdquo;;},
   function () { echo &ldquo;une des actions n&#8217;est pas ok..\n&rdquo;;}
);</p>

<p>$deferred->resolve();
&#8220;`</p>

<p>Le résultat
<code>
l'action 1 pas ok mais on continue..
action 3 ok
</code></p>

<p>Si on veux que l&#8217;erreur de l&#8217;action 1 se propage deux possibilités..</p>

<ul>
<li>supprimer le callback d&#8217;erreur de l&#8217;action 2</li>
<li>Ou relancer l&#8217;exception</li>
</ul>


<pre><code>$promise  = $deferred-&gt;promise()-&gt;then(
    function () { throw new \Exception(); }
)-&gt;then(
    function () { echo "action 2 ok\n";},
    function () { echo "l'action 1 pas ok et on stop le processus"; throw new \Exception();}
)-&gt;then(
   function () { echo "action 3 ok\n";},
   function () { echo "une des actions n'est pas ok..\n";}
);
</code></pre>

<p>Ce qui est intéressant dans les promises c&#8217;est que le code équivalent en procédural est pas génial.
<code>
 $result = doAction1();
try {
    $result = doAction1();
    if ($result) {
        $result2 = doAction2($result);
        if ($result2) {
            $result3 = doAction3($result3);
            return $result3;
        } else {
            throw new Exception();
        }
    } else {
        throw New Exception();
    }
} catch (..){
    echo "une des actions n'est pas ok"
}
</code></p>

<p>Devient
<code>
    $result = $doAction1()
        -&gt;then(function($result1){doAction2($result1);})
        -&gt;then(
            function($result2){doAction3($result2);},
            function() {echo "une des actions n'est pas ok"}
        );
</code></p>

<p>C&#8217;est mieux non ?</p>

<p>Dans un prochain article nous nous utiliserons ce que nous avons appris avec <a href="http://guzzle.readthedocs.org/en/latest/">Guzzle</a>.</p>
]]></content>
  </entry>
  
</feed>
