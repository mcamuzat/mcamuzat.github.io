<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Vim | Mon blog perso.]]></title>
  <link href="http://mcamuzat.github.io/blog/categories/vim/atom.xml" rel="self"/>
  <link href="http://mcamuzat.github.io/"/>
  <updated>2015-08-04T22:00:40+02:00</updated>
  <id>http://mcamuzat.github.io/</id>
  <author>
    <name><![CDATA[mcamuzat]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[PHP Code Sniffer Mise en Place]]></title>
    <link href="http://mcamuzat.github.io/blog/2015/08/01/php-code-sniffer-mise-en-place/"/>
    <updated>2015-08-01T18:33:12+02:00</updated>
    <id>http://mcamuzat.github.io/blog/2015/08/01/php-code-sniffer-mise-en-place</id>
    <content type="html"><![CDATA[<h2>Qualité de code et php</h2>

<p>Dans ce post nous allons voir les logiciels qui permettent de respecter les standards de code en PHP.</p>

<p>En pratique il n&#8217;y en a que 2.</p>

<ul>
<li><a href="https://github.com/squizlabs/PHP_CodeSniffer">CodeSniffer</a></li>
<li><a href="http://cs.sensiolabs.org/">PHP Coding Standards Fixer</a></li>
</ul>


<h2>CodeSniffer</h2>

<p>Il y a différentes normes de codage :  les plus connus sont la <a href="http://www.php-fig.org/psr/psr-1/">psr-1</a> et la <a href="http://www.php-fig.org/psr/psr-2/">psr-2</a>. La psr-2 hérite de la psr-1. Mais certain Framework ont leur propres méthodes d&#8217;indentations. On peux personnaliser d&#8217;ailleurs les différentes règles. Les gouts et les couleurs de chacun sur le code est subjectif. L&#8217;intérêt de suivre les recommandations est que cela dépassionne le débat. Cela passe CodeSniffer ou cela ne passe pas. Pour participer au projet Open-source, il faut suivre la norme.</p>

<p>La norme est pointilleuse sur les commentaires aussi. Si pas de commentaire pas de validation. On est quasiment forcer d&#8217;écrire la documentation. Cela a parfois un effet pervers ou le programmeur remplit sans trop réfléchir pour faire passer code sniffer.</p>

<p>Très souvent on ajoute un <em>hook</em> sur les commits de git. Lorsque on commite, git déclenche le logiciel, si un des fichiers n&#8217;est pas valide CodeSniffer on refuse de commiter. C&#8217;est assez peu contraignant quand la codebase est déjà indentée. (quoique parfois cela tombe vraiment au mauvais moment).En général on vérifie seulement sur les fichiers modifiés. Re-indenter tout le projet est souvent trop compliqué, trop long et un peu suicidaire si vous avez des rebases et des merges.</p>

<h2>Installation de CodeSniffer</h2>

<p>Deux possibilités</p>

<h3>Dans le projet</h3>

<p>via une dépendance au projet en l&#8217;ajoutant dans le <code>composer.json</code></p>

<pre><code class="json">{
    "require-dev": {
        "squizlabs/php_codesniffer": "2.*"
    }
}
</code></pre>

<p>Alors dans le projet
<code>sh
./vendor/bin/phpcs -h
</code></p>

<p>Personnellement je définie toujours un répertoire <code>bin</code> par défaut</p>

<pre><code class="json">    "config": {
        "bin-dir": "bin"
    },
</code></pre>

<p>Ainsi la commande précédente devient</p>

<pre><code class="sh">bin/phpcs 
</code></pre>

<h3>Installation globale</h3>

<p>Soit l&#8217;installer de manière globale</p>

<pre><code>composer global require "squizlabs/php_codesniffer=*"
</code></pre>

<p>Attention si vous utilisez Composer de manière globale ne pas oublier de rajouter dans votre <code>$PATH</code>
<code>
export PATH=~/.composer/vendor/bin:$PATH
</code></p>

<h3>Ajoutez les reglès symfony</h3>

<p>par défaut phpcs vient avec les règles suivantes</p>

<ul>
<li><a href="http://www.php-fig.org/psr/psr-1/">psr-1</a></li>
<li><a href="http://www.php-fig.org/psr/psr-2/">psr-2</a></li>
<li><a href="https://github.com/squizlabs/PHP_CodeSniffer/tree/master/CodeSniffer/Standards/Squiz">Squiz</a></li>
<li><a href="http://framework.zend.com/manual/1.12/fr/coding-standard.html">Zend</a></li>
<li><a href="https://pear.php.net/manual/en/standards.php">Pear</a></li>
<li><a href="https://github.com/squizlabs/PHP_CodeSniffer/tree/master/CodeSniffer/Standards/PHPCS">Phpcs</a></li>
</ul>


<p>Il manque Symfony..</p>

<p>Voici une méthode simple (mais pas la méthode officielle) si vous voulez l&#8217;installer de manière globale. Je rajoute dans le répertoire <code>Standards</code> un répertoire <code>Symfony2</code></p>

<pre><code>$ composer global require "squizlabs/php_codesniffer=*"
$ cd ~/.composer/vendor/squizlabs/php_codesniffer/CodeSniffer/Standards
$ git clone git@github.com:escapestudios/Symfony2-coding-standard.git Symfony2
</code></pre>

<p>On vérifie que les règles symfony2 sont bien installées</p>

<pre><code>phpcs -i
</code></pre>

<p>Symfony2 en défaut. Ainsi pas besoin de préciser <code>--standard=Symfony2</code></p>

<pre><code>phpcs --config-set default_standard Symfony2
</code></pre>

<h3>Php-cbf</h3>

<p>Code sniffer est capable de corriger certaines fautes tout seul. Encore une fois essayer de faire au fur et à mesure. Le commit d&#8217;indentation avec 500 fichiers modifiés est un calvaire à gérer si vous faite des revues de codes ou pire un rebase.</p>

<p>La syntaxe est la même que phpcs.
<code>
php-cbf src/
</code></p>

<h2>Php-cs-fixer</h2>

<p>Écris par <a href="http://sensiolabs.com/">Sensio</a> les créateurs de <a href="http://symfony.com/">Symfony</a>. Ce logiciel fixe automatiquement l&#8217;indentation et différentes règles. L&#8217;avantage est qu&#8217;il est simple à installer pas besoin de cloner d&#8217;autre dépôt.</p>

<h2>Avoir tout les outils via docker.</h2>

<p>J&#8217;ai déjà présenté les différentes méthodes avec <a href="https://github.com/jolicode/docker-images/tree/master/languages/php/phaudit">phaudit</a> ans cette article <a href="/blog/2015/04/18/dockers-et-ci/">ici</a></p>

<h2>Méthode par rapport à git</h2>

<p>Pour lancer une vérification avant chaque commit
Il suffit de créer un fichier <code>pre-commit.sh</code> dans le répertoire <code>.git/hook</code>. Il y a plein d&#8217;exemples sur le net. Je n&#8217;ai pas d&#8217;exemple à partager. Le code ne m&#8217;appartient plus..</p>

<h2>Installation sous VIM.</h2>

<p>C&#8217;est très simple Il faut installer le plugin <a href="https://github.com/scrooloose/syntastic">syntastic</a>. C&#8217;est un plugin qui gère un peu près tout les formats possibles.</p>

<p>Code-sniffer doit être installé de manière <strong>globale</strong></p>

<p>Il suffit de rajouter cette ligne dans votre <code>.vimrc</code></p>

<pre><code>let g:syntastic_php_checkers=['php', 'phpcs']
</code></pre>

<p>A chaque fois que l&#8217;on enregistre le fichier, le plugin lance automatiquement d&#8217;abord <code>php</code> pour vérifier que le fichier est valide, puis <code>phpcs</code>.</p>

<p>Le résultat est très intuitif on a une flèche <code>&gt;</code> à chaque ligne qui pose problème. Il suffit de passer le curseur pour connaitre l&#8217;erreur. Enfin un screenshot sera plus clair.</p>

<p><img class="center" src="/images/syntastic.png" width="600" height="212" title="&lsquo;Screenshot de syntastic&rsquo; &lsquo;syntastic&rsquo;" ></p>

<h2>Conclusion</h2>

<p>Respecter la norme psr-2 ou autre n&#8217;est pas très compliqué, avec l&#8217;habitude c&#8217;est même plutôt facile. Il est plus facile de d&#8217;intervenir sur un code propre. Sur la mise en place, on a vu qu&#8217;il y a deux possibilités soit des warning dans le code soit une correction automatique. Je ne suis pas <em>fan</em> pas la correction automatique. Je ne veux pas que le logiciel prennent des décisions pour moi.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Vim Et Debbuger]]></title>
    <link href="http://mcamuzat.github.io/blog/2015/07/05/vim-et-debbuger/"/>
    <updated>2015-07-05T17:12:57+02:00</updated>
    <id>http://mcamuzat.github.io/blog/2015/07/05/vim-et-debbuger</id>
    <content type="html"><![CDATA[<h2>Introduction</h2>

<p>Je vais montrer aujourd&#8217;hui comment interfacer Vim et xdebug pour debugger du php.</p>

<ul>
<li>Installer xdebug</li>
<li>Paramétrer xdebug</li>
<li>Présentation de deux plugins <strong>Vdebug</strong> et <strong>DBGPavim</strong></li>
<li>Comment installer les deux plugin avec</li>
</ul>


<h2>Installer xdebug</h2>

<p>Je connais deux méthodes</p>

<p>Utiliser PECL</p>

<pre><code>sudo pecl install xdebug
</code></pre>

<p>il faut alors ajouter dans votre <code>php.ini</code> la ligne suivante</p>

<pre><code>zend_extension=/usr/lib/php5/20090626/xdebug.so
</code></pre>

<p>Ou plus propre rajouter dans un nouveau fichier  <code>/etc/php5/apache2/conf.d/xdebug.ini</code> et pareil pour la ligne de commande <code>/etc/php5/cli/conf.d/xdebug.ini</code></p>

<p>utiliser apt-get sous Ubuntu
<code>
sudo apt-get install php5-xdebug
</code>
sur mon Ubuntu, les fichier conf.d était déjà crée</p>

<h2>Paramétrer xdebug pour le debugger</h2>

<p>Il faut rajouter les lignes suivantes le <code>xdebug.ini</code></p>

<pre><code>xdebug.remote_enable=on
xdebug.remote_handler=dbgp
xdebug.remote_host=localhost
xdebug.remote_port=9000
</code></pre>

<p>Puis aller sur l&#8217;url en ajoutant
<code>
http://monsite.com/?XDEBUG_SESSION_START=1
</code>
Il y a des plugins Firefox et Chrome qui s&#8217;occupe de cela.</p>

<p>Pour que le debugger soit lancer par défaut. Vous pouvez rajouter la ligne suivante</p>

<pre><code class="ini">xdebug.remote_autostart=1
</code></pre>

<p>Pour tester en ligne de commande.</p>

<pre><code class="sh">php -dxdebug.remote_autostart=1 test.php
</code></pre>

<p>un simple script bash fait l&#8217;affaire. <code>php-debug</code></p>

<pre><code class="sh">#!/bin/bash
/usr/bin/php -dxdebug.remote_autostart=1 "$@"
</code></pre>

<h2>Les plugins VIM</h2>

<p>Je vais pas trop insister sur comment installer un plugin sous Vim. Ce n&#8217;est pas très compliqué. Il faut passer par un gestionnaire de plugin (la gestion des plugins par défaut dans Vim n&#8217;est pas pratique)</p>

<h2> Vdebug</h2>

<h3>Utilisation</h3>

<ul>
<li>appuyer sur <code>&lt;F5&gt;</code></li>
<li>vous avez 20 seconde pour lancer le script ou aller sur le serveur apache.</li>
<li>Une fois le signal capturé</li>
</ul>


<h3>Liste des raccourcis claviers</h3>

<p><img class="center" src="/images/VDebug.png" width="600" height="375" title="&lsquo;Vdebug&rsquo; &lsquo;Screenshot de VDebug&rsquo;" ></p>

<ul>
<li><code>&lt;F5&gt;</code>: start/run (to next breakpoint/end of script)</li>
<li><code>&lt;F2&gt;</code>: step over</li>
<li><code>&lt;F3&gt;</code>: step into</li>
<li><code>&lt;F4&gt;</code>: step out</li>
<li><code>&lt;F6&gt;</code>: stop debugging</li>
<li><code>&lt;F7&gt;</code>: detach script from debugger</li>
<li><code>&lt;F9&gt;</code>: run to cursor</li>
<li><code>&lt;F10&gt;</code>: toggle line breakpoint</li>
<li><code>&lt;F11&gt;</code>: show context variables (e.g. after &ldquo;eval&rdquo;)</li>
<li><code>&lt;F12&gt;</code>: evaluate variable under cursor</li>
<li><code>:VdebugEval &lt;code&gt;</code>: evaluate some code and display the result</li>
<li><code>&lt;Leader&gt;e</code>: evaluate the expression under visual highlight and display the result</li>
</ul>


<p>La touche <code>&lt;Leader&gt;</code> est par défault <code>\</code> sur un clavier anglais. <code>&lt;Leader&gt;e</code> correspond à <code>\e</code>. Pas simple à taper sur un clavier azerty. la touche <code>&lt;Leader&gt;</code> est réglable grâce à cette configuration du <code>.vimrc</code></p>

<pre><code>let mapleader = ","
</code></pre>

<p>Sur mon poste, je tape <code>,e</code></p>

<h3>Un avis</h3>

<p>Marche plutôt bien, mais par défaut Le debugger commence au début du script et pas au premier breakpoint.</p>

<p>Il faut rajouter cette ligne dans votre <code>.vimrc</code>.</p>

<pre><code>let g:vdebug_options["break_on_open"]=0
</code></pre>

<p>L&#8217;histoire des 20 secondes pour se connecter est un peu frustrante.</p>

<p>Par contre le code python est super propre.</p>

<h2>DBGPavim</h2>

<p><img class="center" src="/images/DBGPAVIM.png" width="600" height="375" title="&lsquo;DBGPavim&rsquo; &lsquo;Screenshot de DBGPavim&rsquo;" ></p>

<p>Ce plugin résout les deux problèmes de Vdebug (aucune limitation de temps, démarre au premier point d&#8217;arrêt). Je le trouve moins intuitif. Mais il est visiblement plus puissant, il gère plusieurs sessions.</p>

<p>Sur les screenshots la différence est plutôt minime.</p>

<p>Les touches sont un peu près les mêmes.</p>

<h2>Installations sous vim</h2>

<p>Suivant le plugin que vous avez choisi</p>

<p>Par <a href="https://github.com/tpope/vim-pathogen">Pathogen</a>:
<code>
git clone git://github.com/joonty/vdebug.git bundle/vdebug
ou
git://github.com/joonty/vdebug.git brookhong/DBGPavim.git
</code></p>

<p>Ou avec les submodules de Git</p>

<pre><code>git submodule add git://github.com/joonty/vdebug.git bundle/vdebug
# ou 
git submodule add git://github.com/brookhong/DBGPavim.git bundle/DBGPavim
</code></pre>

<p>Ajouter cette ligne à votre <code>.vimrc</code></p>

<p>par <a href="https://github.com/gmarik/Vundle.vim">Vundle</a>
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Bundle &ldquo;joonty/vdebug&rdquo;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h1&gt;ou&lt;/h1&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;Bundle &lsquo;brookhong/DBGPavim&rsquo;</span></code></pre></td></tr></table></div></figure></p>

<p>par <a href="https://github.com/Shougo/neobundle.vim">NeoBundle</a> :
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>NeoBundle &ldquo;joonty/vdebug&rdquo;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h1&gt;ou&lt;/h1&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;NeoBundle &lsquo;brookhong/DBGPavim&rsquo;</span></code></pre></td></tr></table></div></figure></p>

<h2>En conclusion</h2>

<p>Le debugger c&#8217;est chouette et cela rends un peu obsolète ce bon vieux <code>var_dump(); die();</code></p>

<p>D&#8217;ailleurs sur le <code>var_dump</code>. Il est plus simple de taper cette commande directement.</p>

<pre><code>die(var_dump($foo));
</code></pre>

<p>Enfin sur les versions récentes de Symfony la commande <code>dump()</code> est pratique.</p>

<p>Je vais reparler de xdebug. J&#8217;ai plein d&#8217;astuce à partager.</p>

<h2>Des liens</h2>

<ul>
<li><a href="https://github.com/joonty/vdebug">Vdebug</a></li>
<li><a href="https://github.com/brookhong/DBGPavim">DBGPAVIM</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Less Is More Et BASH]]></title>
    <link href="http://mcamuzat.github.io/blog/2015/06/28/less-is-more-et-bash/"/>
    <updated>2015-06-28T19:19:59+02:00</updated>
    <id>http://mcamuzat.github.io/blog/2015/06/28/less-is-more-et-bash</id>
    <content type="html"><![CDATA[<h2>less comme tail -f</h2>

<p>On peux utiliser <code>less</code> pour suivre et parser les logs avec la commande</p>

<pre><code>less +F nom_du_fichier
</code></pre>

<p>Ou tout simplement appuyer sur <code>F</code> quand le fichier est ouvert avec <code>less</code>.</p>

<p>Less est compatible avec les raccourcis VI donc les commandes suivantes marchent</p>

<pre><code>gg # debut du fichier
G # fin du fichier
/ #recherche
&amp; #affiche seulement les lignes qui contiennent le mot 
h,j,k,l les directions
</code></pre>

<p>les touche suivantes marche aussi avec <code>man</code></p>

<p>Je vous conseille ce post sur les <a href="blog/2015/03/08/comprendre-les-raccourcis-claviers-de-vi-slash-vim/">mouvement vi</a></p>

<h2>Éditer une ligne de commande trop complexe</h2>

<p>Si on souhaite récupérer la commande actuelle sous BASH. C&#8217;est <code>Ctrl x + Ctrl e</code>. Cela ouvre la commande actuelle dans <code>vi</code> ou votre éditeur par défaut <code>$EDITOR</code> enregistrer et quitter.</p>

<h2>Copier/Coller dans bash</h2>

<ul>
<li>Coupe toute la ligne : <code>Ctrl u</code></li>
<li>Coupe à droite du curseur: <code>Ctrl k</code></li>
<li>Coller <code>Ctrl y</code></li>
</ul>


<h3>Cas d&#8217;utilisation</h3>

<pre><code>vim /etc/hosts (oups j'ai oublié le sudo..)
&lt;Ctrl u&gt; sudo &lt;Ctrl k&gt;
</code></pre>

<h1>Annuler dans Bash</h1>

<p>C&#8217;est <code>Ctrl _</code></p>

<h1>En conclusion</h1>

<p>Les raccourcis claviers <code>Ctrl _</code> et <code>Ctrl y</code> sont des raccourcis claviers de emacs.</p>

<p>Bien qu&#8217;utilisateur Vim, j&#8217;aime beaucoup Emacs. Notamment le <code>org-mode</code>. Emacs est supérieur à Vim. (plus de mode, plus de personnalisation, une véritable interaction en REPL pour les langage type lisp). Il y a une tendance à utiliser Emacs avec le Evil-mode (ce qui en gros rajoute les raccourcis claviers de vim dans Emacs). Mais je pas encore passé le cap.</p>

<p>Il est possible de passer son BASH en Vi-mode avec la commande suivante. Personnellement j&#8217;aime pas.</p>

<pre><code>set -o vi
</code></pre>

<p>L&#8217;article <a href="http://www.catonmat.net/blog/bash-vi-editing-mode-cheat-sheet/">suivant</a> aide un peu. Mais ce n&#8217;est pas évident de dé-apprendre les raccourcis claviers.</p>

<h1>Quelques liens</h1>

<ul>
<li><a href="https://github.com/jlevy/the-art-of-command-line">the art of the command line</a></li>
<li><a href="http://www.commandlinefu.com">commandlinefu</a></li>
<li><a href="http://orgmode.org/index.html">org-mode</a></li>
<li><a href="http://www.emacswiki.org/emacs/Evil">evil-mode</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Copier Coller Dans Vim]]></title>
    <link href="http://mcamuzat.github.io/blog/2015/05/30/copier-coller-dans-vim/"/>
    <updated>2015-05-30T23:23:37+02:00</updated>
    <id>http://mcamuzat.github.io/blog/2015/05/30/copier-coller-dans-vim</id>
    <content type="html"><![CDATA[<h2>Pour commencer : comment sélectionner sous vim</h2>

<h3>solution n°1 : utiliser la souris</h3>

<p>tapez :
<code>bash
set mouse=a
</code>
vous pouvez sélectionnez avec la souris. Pour copier appuyer sur <code>y</code> comme <strong>y</strong>ank</p>

<h3>solution n°2 : utiliser le mode visuel</h3>

<p>avec la touche <code>v</code> ou <code>V</code> pour utiliser la ligne entière. Puis les flèches ou les <a href="/blog/2015/03/08/comprendre-les-raccourcis-claviers-de-vi-slash-vim/">mouvements</a></p>

<h3>solution n°3 : utiliser les touches mouvements</h3>

<p>Quelques exemples:</p>

<ul>
<li><code>y3w</code> copier trois mots (<strong>y</strong>ank <strong>3</strong> words)</li>
<li><code>yG</code> copier jusqu&#8217;à la fin du fichier (<strong>y</strong>ank fin</li>
<li><code>y5j</code> copier 5 lignes vers le bas (<strong>y</strong> <strong>5</strong> lignes vers le bas <code>j</code>)</li>
<li><code>yi(</code> pour copier le texte entre parenthèse (<strong>y</strong>ank <strong>i</strong>nside <code>(</code>)</li>
</ul>


<p>Pour coller on utilise la touche <code>p</code> pour <strong>p</strong>aste ou <code>P</code> (colle avant le curseur)</p>

<h2>Les presse-papiers sous vi ou les registres</h2>

<p>La notion de presse-papier est appelle registre dans Vi.</p>

<p>Pour voir l&#8217;état des registres (et si il ne fallait retenir qu&#8217;une seule commande..)</p>

<pre><code class="bash">:register ou :reg
</code></pre>

<p>Vous devez voir quelques choses dans le genre:</p>

<pre><code>"" dernier texte )
"0 dernier texte copié
... les dix derniers textes copiés
"9 ..  
"a contenu du registre "a" (s'il existe)
...
"% noms du fichier
". dernier texte inséré
"/ dernier texte recherché
": derniere commande.
</code></pre>

<ul>
<li>Pour coller le texte contenue dans le registre <code>a</code> il faut taper<code>"ap</code> pour le registre <code>"a</code> + <code>p</code> paste.</li>
<li>Pour copier le texte dans le registre a c&#8217;est <code>"ay</code></li>
<li>Avec les mouvements de vi <code>"ay3w</code> dans le registre a (<code>"a</code>) copier (<code>y</code> comme <em>yank</em>) 3 mots (3w pour 3 words).</li>
</ul>


<p>Un registre intéressant le registre <code>+</code> ou le registre <code>*</code> les deux registres sont associés au clipboard de Linux ou celui de windows.</p>

<h2>Pour résumer</h2>

<ul>
<li>Pour voir les registres. Il suffit de taper <code>:register</code>.</li>
<li>Pour coller un registre c&#8217;est <code>"&lt;nom du registre&gt;p</code>.</li>
<li>Pour copier c&#8217;est <code>"&lt;nom du registre&gt;y(+mouvement)</code>.</li>
<li>Le registre <code>+</code> est le presse-papier de windows ou linux. Pour copier/coller du presse-papier il suffit de taper <code>"+p</code> et <code>"+y</code>.</li>
<li>On a 26 presse-papiers de <code>a</code> à <code>z</code> personnellement j&#8217;en ai rarement utilisé plus de deux registres en même temps.</li>
</ul>


<p>Nous reparlerons des registres avec les macros dans un prochain post.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Je Joue Donc Je Programme]]></title>
    <link href="http://mcamuzat.github.io/blog/2015/05/04/je-joue-donc-je-programme/"/>
    <updated>2015-05-04T22:32:00+02:00</updated>
    <id>http://mcamuzat.github.io/blog/2015/05/04/je-joue-donc-je-programme</id>
    <content type="html"><![CDATA[<p>Il existe des jeux vidéos pour apprendre à programmer. Voici quelques exemples.</p>

<h2>VimAdventure</h2>

<p><img class="center" src="/images/vimadventures.jpg" width="600" height="339" title="&lsquo;Vim adventure&rsquo; &lsquo;Vim adventure&rsquo;" >
<a href="http://vim-adventures.com/">Vim adventure</a> permet d&#8217;apprendre les touches de Vim de manière ludique. Personnellement j&#8217;ai beaucoup joué à <a href="http://crawl.develz.org/wordpress/">Dungeon Crawl</a> qui utilise les touches <code>h</code>, <code>j</code>, <code>k</code>, <code>l</code></p>

<h2>Ruby</h2>

<p>Ruby warrior existe en deux versions:
<img class="center" src="/images/ruby-warrior.png" width="600" height="288" title="&lsquo;Ruby warrior&rsquo; &lsquo;Ruby warrior&rsquo;" ></p>

<p>En ligne de commande <a href="https://github.com/ryanb/ruby-warrior">ruby-warrior</a></p>

<p>Le but est ici d&#8217;écrire L&#8217;AI du héros. Cela commence relativement simplement. Au début pas besoin de if, else, object mais les niveaux se corsent vraiment (je dirai que jusqu&#8217;au 6 c&#8217;est relativement tranquille)</p>

<p>Depuis il existe une version web. Beaucoup plus accessible et jolie
<a href="https://www.bloc.io/ruby-warrior#/">ruby-warrior</a></p>

<h2>Javascript</h2>

<h3>Untrusted</h3>

<p><img class="center" src="/images/untrusted.jpg" width="600" height="339" title="&lsquo;Untrusted&rsquo; &lsquo;Untrusted&rsquo;" >
pour passer les niveaux, il faut atteindre le terminal et commencer à hacker le js. C&#8217;est vraiment malin.
<a href="http://alexnisnevich.github.io/untrusted/">untrusted</a></p>

<h3>Elevator Saga</h3>

<p><img class="center" src="/images/elevator-saga.png" width="600" height="288" title="&lsquo;Elevator Saga&rsquo; &lsquo;Elevator Saga&rsquo;" ></p>

<p>Quoi de plus passionnant que simulation d&#8217;ascenseur.On passe assez facilement le niveau 1. Cela se complique vraiment avec le niveau deux et les objectifs.
<a href="http://play.elevatorsaga.com/">elevator-saga</a></p>

<h3>CodeCombat</h3>

<p><a href="http://codecombat.com/">CodeCombat</a>
Diriger un petit combattant, Un peu la même idée que ruby-warror, mais l&#8217;interface est très belle. Il y a du multi-joueurs</p>

<h2>Multi-plateforme</h2>

<p><img class="center" src="/images/codingame.jpg" width="600" height="375" title="&lsquo;Coding game&rsquo; &lsquo;Coding game&rsquo;" ></p>

<p><a href="http://www.codingame.com">Codingame</a>. L&#8217;interface est magnifique, vous pouvez choisir le langage (il y a une vingtaine de langage PHP, Js, Haskell, Bash, C). les exercices sont assez variés. C&#8217;est plus des katas de programmation.</p>

<h2>Le SQL</h2>

<p><img class="center" src="/images/schemaverse.png" width="450" height="131" title="&lsquo;Schemaverse&rsquo; &lsquo;Schemaverse&rsquo;" ></p>

<p><a href="https://schemaverse.com/">Schemaverse</a>
Un jeux video en prosgresSQL pur. Il y a même une histoire. C&#8217;est assez compliqué.</p>

<h2>Les Regex</h2>

<ul>
<li><a href="http://regexone.com/">regex one</a> Une bonne introduction.</li>
<li><a href="https://regex.alf.nu/">regex.alf.nu</a>. Cela commence doucement, mais les dernières sont très très compliquées.</li>
<li><a href="http://www.postcrashgames.com/finitris/">finitris</a>.Un vieux Jeux que j&#8217;avais noté, c&#8217;est dommage que la prise en main soit affreuse et que le zoom soit péter (control+molette est votre ami)</li>
</ul>


<h3>Des jeux Flash</h3>

<p>Bon je sais que ce n&#8217;est pas super récent.</p>

<p>Tout les jeux Zacktronics</p>

<ul>
<li><a href="http://www.zachtronics.com/spacechem/">SpaceChem</a> (payant et j&#8217;ai pas essayé).</li>
<li><a href="http://www.zachtronics.com/kohctpyktop-engineer-of-the-people/">Kohctpyktop</a> quasiment injouable. mais c&#8217;est de cette facon que sont fait les portes logiques et les microprocesseurs.</li>
<li><a href="http://www.zachtronics.com/the-codex-of-alchemical-engineering/">Codex of Alchemical Engineering</a> assembler des molécules.</li>
<li><a href="http://www.zachtronics.com/ruckingenur-ii/">Ruckingenur</a> voila comment on fait du Reverse Engineering des circuits électroniques (sous windows).</li>
</ul>


<p>Et aussi</p>

<ul>
<li><a href="http://pleasingfungus.com/Manufactoria/">manufactoria</a> facbrique de robots et BDD (il suffit de faire passer le scénario).</li>
</ul>


<h2>En conclusion</h2>

<p>j&#8217;ai vraiment beaucoup aimé et joué à <a href="http://alexnisnevich.github.io/untrusted/">untrusted</a> et <a href="https://www.bloc.io/ruby-warrior#/">ruby-warrior</a></p>

<p>J&#8217;ai probablement oublié d&#8217;autres jeux.</p>
]]></content>
  </entry>
  
</feed>
