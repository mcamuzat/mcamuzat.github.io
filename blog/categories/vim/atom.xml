<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Vim | Mon blog perso.]]></title>
  <link href="http://mcamuzat.github.io/blog/categories/vim/atom.xml" rel="self"/>
  <link href="http://mcamuzat.github.io/"/>
  <updated>2015-08-23T18:53:48+02:00</updated>
  <id>http://mcamuzat.github.io/</id>
  <author>
    <name><![CDATA[mcamuzat]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Gmail Vim Mêmes Raccourcis]]></title>
    <link href="http://mcamuzat.github.io/blog/2015/08/08/gmail-vim-memes-raccourcis/"/>
    <updated>2015-08-08T18:52:17+02:00</updated>
    <id>http://mcamuzat.github.io/blog/2015/08/08/gmail-vim-memes-raccourcis</id>
    <content type="html"><![CDATA[<h2>Les raccourcis de Gmail ressemblent à vi.</h2>

<p><em>Résumé : appuyer sur <code>?</code> dans gmail pour avoir le tableau complet, les raccourcis claviers suivant ne sont pas activés par défaut</em></p>

<p>Le titre est un peu exagéré.. Je vais essayer de montrer que la <em>philosophie</em> est un peu la même.</p>

<p>Mais sur Vi On utilise les flèches de direction <code>h</code>, <code>j</code>, <code>k</code>, <code>l</code> pour <code>gauche</code>, <code>bas</code>, <code>haut</code>, <code>droite</code> pour se déplacer (enfin surtout <code>j</code> et <code>k</code>). Et bien les touches <code>j</code>(bas)  et <code>k</code>(haut) marchent pareilles sous Gmail.</p>

<p>Pour chercher sous Vi on utilise la touche <code>/</code> , essayez sous Gmail et vous aller directement dans la barre de recherche.</p>

<h2>Une lettre = une idée..</h2>

<p>Comme dans vi ou <code>w</code> signifie <strong>w</strong>ord, <code>d</code> signifie <strong>d</strong>elete, <code>u</code> <strong>u</strong>ndo on retrouve la même idée.</p>

<p>Par exemple <code>c</code> est l&#8217;abréviation de <strong>c</strong>omposer.</p>

<ul>
<li><code>c</code> pour <strong>c</strong>ompose Nouveau message</li>
<li><code>n</code> signifie <strong>n</strong>ext Message suivant</li>
<li><code>p</code> signifie <strong>p</strong>revious Message précédent.</li>
<li><code>r</code> pour reply <strong>r</strong>eply Répondre</li>
<li><code>a</code> pour tous <strong>a</strong>ll. Repondre à tous</li>
<li><code>f</code> pour transférer <strong>f</strong>orward.</li>
<li><code>o</code> pour ouvrir le conversation.</li>
</ul>


<h2>La lettre en majuscule = la version minuscule en plus forte</h2>

<p>Dans vi <code>i</code> insere du texte, <code>I</code> insere au début de la ligne, <code>a</code> ajoute du texte , <code>A</code> ajoute le texte à la fin de la ligne.</p>

<ul>
<li><code>C</code> compose un nouveau message dans une nouvelle fenêtre</li>
<li><code>R</code> Répondre dans une nouvelle fenêtre</li>
<li><code>A</code> Répondre à tous dans une nouvelle fenêtre.</li>
<li><code>F</code> Transférer dans une nouvelle fenêtre.</li>
</ul>


<h2>Une lettre = un pictogramme.</h2>

<p>Sous Vi certaine lettre sont des pictogrammes. Par exemple la touche <code>'</code> représente le marque page.</p>

<p>Je n&#8217;ai encore jamais parlé des marques pages sous vi pour faire simple</p>

<ul>
<li>Ouvrez un fichier texte très long</li>
<li>Allez vers le mileu du fichier  appuyer sur <code>m</code> puis <code>a</code></li>
<li>Re-deplacez vous et appuyer sur <code>m</code> puis <code>b</code>.</li>
<li>tapez <code>'a</code> vous ramene ou point a et <code>'b</code> au point b, <code>d'a</code> (effacer jusqu&#8217;au marque-page a)</li>
</ul>


<p><img class="center" src="/images/quote.png" width="431" height="174" title="&lsquo;Le guillement est une pictogramme de marques-pages&rsquo; &lsquo;le guillemet est le pictogramme du marque-page&rsquo;" ></p>

<p>La lettre <code>=</code> est le pictogramme de deux lignes indentées. Quand j&#8217;appuie sur <code>=</code> j&#8217;indente le texte.</p>

<p><img class="center" src="/images/indentation.png" width="600" height="276" title="&lsquo;Indentation&rsquo; &lsquo;Pour indenter on utilise la touche = &rsquo;" ></p>

<p>La lettre <code>z</code> correspond au repli de texte</p>

<p><img class="center" src="/images/repli.png" width="600" height="230" title="&lsquo;z = repli de texte ;&rsquo; &lsquo;Pour plier déplier le texte on utilise la touche z&rsquo;" ></p>

<ul>
<li><code>z</code> + <code>c</code> pour replier (c = close)</li>
<li><code>z</code> + <code>o</code> pour deplier (o = open)</li>
<li><code>z</code> + <code>a</code> pour alterner.</li>
</ul>


<p><img class="center" src="/images/plier.png" width="595" height="214" title="&lsquo;z = repli de texte&rsquo; &lsquo;Pour plier déplier le texte on utilise la touche z&rsquo;" ></p>

<p>Sous gmail, c&#8217;est encore la même idée.  la touche <code>x</code> correspond à une checkbox. appuyer sur x pour sélectionner la conversation. le <code>#</code> correspond à supprimer, le <code>!</code> à SPAM!!!.</p>

<p><img class="center" src="/images/checkanddelete.png" width="543" height="193" title="&lsquo;le x est le pictogramme d'un checkbox&rsquo; &lsquo;Mon terminal`" ></p>

<h2>Le cas de <code>*</code></h2>

<p>Pour tout selectionner tout les fichiers textes on utilise la commande <code>*.txt</code></p>

<ul>
<li><code>*</code> puis <code>a</code> : Sélectionner toutes les conversations</li>
<li><code>*</code> puis <code>n</code> : Désélectionner toutes les conversations</li>
<li><code>*</code> puis <code>r</code> : Sélectionner les conversations lues</li>
<li><code>*</code> puis <code>u</code> : Sélectionner les conversations non lues</li>
<li><code>*</code> puis <code>s</code> : Sélectionner les conversations dont le suivi est activé</li>
<li><code>*</code> puis <code>t</code> : Sélectionner les conversations dont le suivi n’est pas activé</li>
</ul>


<p>puis après:</p>

<ul>
<li><code>e</code> : Archiver</li>
<li><code>m</code> : Ignorer la conversation</li>
<li><code>!</code> : Signaler comme spam</li>
<li><code>#</code> : Supprimer</li>
<li><code>z</code> : Annuler la dernière action</li>
<li><code>I</code> : Marquer comme lu</li>
<li><code>U</code> : Marquer comme non lu</li>
<li><code>+</code> ou <code>=</code> : Marquer comme important</li>
<li><code>-</code> : Marquer comme non important</li>
</ul>


<h2>Une lettre = Un verbe</h2>

<p>la lettre g signifie <strong>g</strong>o</p>

<ul>
<li><code>g</code> puis <code>i</code> : Ouvrir la boîte de réception (<strong>i</strong>nput)</li>
<li><code>g</code> puis <code>s</code> : Ouvrir les conversations dont le suivi est activé</li>
<li><code>g</code> puis <code>t</code> : Ouvrir le dossier &ldquo;Messages envoyés&rdquo;</li>
<li><code>g</code> puis <code>d</code> : Ouvrir le dossier &ldquo;Brouillons&rdquo; (<strong>d</strong>raft)</li>
<li><code>g</code> puis <code>a</code> : Ouvrir le dossier &ldquo;Tous les messages&rdquo;</li>
<li><code>g</code> puis <code>c</code> : Ouvrir le dossier &ldquo;Contacts&rdquo;</li>
</ul>


<h2>Conclusion</h2>

<p>A mon travail, on utilise Gmail, Je recois beaucoup de mail (BitBucket, Hipchat, Slack, Redmine, Jira, Wordpress, Meetup, Ovh). J&#8217;avoue que des que j&#8217;ai décidé de traiter les mails via raccourcis clavier, j&#8217;ai trouvé cela assez pratique.</p>

<p>On peux retrouver un tableau qui résume tout en tapant &ldquo;?&rdquo; dans Gmail.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PHP Code Sniffer Mise en Place]]></title>
    <link href="http://mcamuzat.github.io/blog/2015/08/01/php-code-sniffer-mise-en-place/"/>
    <updated>2015-08-01T18:33:12+02:00</updated>
    <id>http://mcamuzat.github.io/blog/2015/08/01/php-code-sniffer-mise-en-place</id>
    <content type="html"><![CDATA[<h2>Qualité de code et php</h2>

<p>Dans ce post nous allons voir les logiciels qui permettent de respecter les standards de code en PHP.</p>

<p>En pratique il n&#8217;y en a que 2.</p>

<ul>
<li><a href="https://github.com/squizlabs/PHP_CodeSniffer">CodeSniffer</a></li>
<li><a href="http://cs.sensiolabs.org/">PHP Coding Standards Fixer</a></li>
</ul>


<h2>CodeSniffer</h2>

<p>Il y a différentes normes de codage :  les plus connus sont la <a href="http://www.php-fig.org/psr/psr-1/">psr-1</a> et la <a href="http://www.php-fig.org/psr/psr-2/">psr-2</a>. La psr-2 hérite de la psr-1. Mais certain Framework ont leur propres méthodes d&#8217;indentations. On peux personnaliser d&#8217;ailleurs les différentes règles. Les gouts et les couleurs de chacun sur le code est subjectif. L&#8217;intérêt de suivre les recommandations est que cela dépassionne le débat. Cela passe CodeSniffer ou cela ne passe pas. Pour participer au projet Open-source, il faut suivre la norme.</p>

<p>La norme est pointilleuse sur les commentaires aussi. Si pas de commentaire pas de validation. On est quasiment forcer d&#8217;écrire la documentation. Cela a parfois un effet pervers ou le programmeur remplit sans trop réfléchir pour faire passer code sniffer.</p>

<p>Très souvent on ajoute un <em>hook</em> sur les commits de git. Lorsque on commite, git déclenche le logiciel, si un des fichiers n&#8217;est pas valide CodeSniffer on refuse de commiter. C&#8217;est assez peu contraignant quand la codebase est déjà indentée. (quoique parfois cela tombe vraiment au mauvais moment).En général on vérifie seulement sur les fichiers modifiés. Re-indenter tout le projet est souvent trop compliqué, trop long et un peu suicidaire si vous avez des rebases et des merges.</p>

<h2>Installation de CodeSniffer</h2>

<p>Deux possibilités</p>

<h3>Dans le projet</h3>

<p>via une dépendance au projet en l&#8217;ajoutant dans le <code>composer.json</code></p>

<pre><code class="json">{
    "require-dev": {
        "squizlabs/php_codesniffer": "2.*"
    }
}
</code></pre>

<p>Alors dans le projet
<code>sh
./vendor/bin/phpcs -h
</code></p>

<p>Personnellement je définie toujours un répertoire <code>bin</code> par défaut</p>

<pre><code class="json">    "config": {
        "bin-dir": "bin"
    },
</code></pre>

<p>Ainsi la commande précédente devient</p>

<pre><code class="sh">bin/phpcs 
</code></pre>

<h3>Installation globale</h3>

<p>Soit l&#8217;installer de manière globale</p>

<pre><code>composer global require "squizlabs/php_codesniffer=*"
</code></pre>

<p>Attention si vous utilisez Composer de manière globale ne pas oublier de rajouter dans votre <code>$PATH</code>
<code>
export PATH=~/.composer/vendor/bin:$PATH
</code></p>

<h3>Ajoutez les reglès symfony</h3>

<p>par défaut phpcs vient avec les règles suivantes</p>

<ul>
<li><a href="http://www.php-fig.org/psr/psr-1/">psr-1</a></li>
<li><a href="http://www.php-fig.org/psr/psr-2/">psr-2</a></li>
<li><a href="https://github.com/squizlabs/PHP_CodeSniffer/tree/master/CodeSniffer/Standards/Squiz">Squiz</a></li>
<li><a href="http://framework.zend.com/manual/1.12/fr/coding-standard.html">Zend</a></li>
<li><a href="https://pear.php.net/manual/en/standards.php">Pear</a></li>
<li><a href="https://github.com/squizlabs/PHP_CodeSniffer/tree/master/CodeSniffer/Standards/PHPCS">Phpcs</a></li>
</ul>


<p>Il manque Symfony..</p>

<p>Voici une méthode simple (mais pas la méthode officielle) si vous voulez l&#8217;installer de manière globale. Je rajoute dans le répertoire <code>Standards</code> un répertoire <code>Symfony2</code></p>

<pre><code>$ composer global require "squizlabs/php_codesniffer=*"
$ cd ~/.composer/vendor/squizlabs/php_codesniffer/CodeSniffer/Standards
$ git clone git@github.com:escapestudios/Symfony2-coding-standard.git Symfony2
</code></pre>

<p>On vérifie que les règles symfony2 sont bien installées</p>

<pre><code>phpcs -i
</code></pre>

<p>Symfony2 en défaut. Ainsi pas besoin de préciser <code>--standard=Symfony2</code></p>

<pre><code>phpcs --config-set default_standard Symfony2
</code></pre>

<h3>Php-cbf</h3>

<p>Code sniffer est capable de corriger certaines fautes tout seul. Encore une fois essayer de faire au fur et à mesure. Le commit d&#8217;indentation avec 500 fichiers modifiés est un calvaire à gérer si vous faite des revues de codes ou pire un rebase.</p>

<p>La syntaxe est la même que phpcs.
<code>
php-cbf src/
</code></p>

<h2>Php-cs-fixer</h2>

<p>Écris par <a href="http://sensiolabs.com/">Sensio</a> les créateurs de <a href="http://symfony.com/">Symfony</a>. Ce logiciel fixe automatiquement l&#8217;indentation et différentes règles. L&#8217;avantage est qu&#8217;il est simple à installer pas besoin de cloner d&#8217;autre dépôt.</p>

<h2>Avoir tout les outils via docker.</h2>

<p>J&#8217;ai déjà présenté les différentes méthodes avec <a href="https://github.com/jolicode/docker-images/tree/master/languages/php/phaudit">phaudit</a> ans cette article <a href="/blog/2015/04/18/dockers-et-ci/">ici</a></p>

<h2>Méthode par rapport à git</h2>

<p>Pour lancer une vérification avant chaque commit
Il suffit de créer un fichier <code>pre-commit.sh</code> dans le répertoire <code>.git/hook</code>. Il y a plein d&#8217;exemples sur le net. Je n&#8217;ai pas d&#8217;exemple à partager. Le code ne m&#8217;appartient plus..</p>

<h2>Installation sous VIM.</h2>

<p>C&#8217;est très simple Il faut installer le plugin <a href="https://github.com/scrooloose/syntastic">syntastic</a>. C&#8217;est un plugin qui gère un peu près tout les formats possibles.</p>

<p>Code-sniffer doit être installé de manière <strong>globale</strong></p>

<p>Il suffit de rajouter cette ligne dans votre <code>.vimrc</code></p>

<pre><code>let g:syntastic_php_checkers=['php', 'phpcs']
</code></pre>

<p>A chaque fois que l&#8217;on enregistre le fichier, le plugin lance automatiquement d&#8217;abord <code>php</code> pour vérifier que le fichier est valide, puis <code>phpcs</code>.</p>

<p>Le résultat est très intuitif on a une flèche <code>&gt;</code> à chaque ligne qui pose problème. Il suffit de passer le curseur pour connaitre l&#8217;erreur. Enfin un screenshot sera plus clair.</p>

<p><img class="center" src="/images/syntastic.png" width="600" height="212" title="&lsquo;Screenshot de syntastic&rsquo; &lsquo;syntastic&rsquo;" ></p>

<h2>Conclusion</h2>

<p>Respecter la norme psr-2 ou autre n&#8217;est pas très compliqué, avec l&#8217;habitude c&#8217;est même plutôt facile. Il est plus facile de d&#8217;intervenir sur un code propre. Sur la mise en place, on a vu qu&#8217;il y a deux possibilités soit des warning dans le code soit une correction automatique. Je ne suis pas <em>fan</em> pas la correction automatique. Je ne veux pas que le logiciel prennent des décisions pour moi.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Vim Et Debbuger]]></title>
    <link href="http://mcamuzat.github.io/blog/2015/07/05/vim-et-debbuger/"/>
    <updated>2015-07-05T17:12:57+02:00</updated>
    <id>http://mcamuzat.github.io/blog/2015/07/05/vim-et-debbuger</id>
    <content type="html"><![CDATA[<h2>Introduction</h2>

<p>Je vais montrer aujourd&#8217;hui comment interfacer Vim et xdebug pour debugger du php.</p>

<ul>
<li>Installer xdebug</li>
<li>Paramétrer xdebug</li>
<li>Présentation de deux plugins <strong>Vdebug</strong> et <strong>DBGPavim</strong></li>
<li>Comment installer les deux plugin avec</li>
</ul>


<h2>Installer xdebug</h2>

<p>Je connais deux méthodes</p>

<p>Utiliser PECL</p>

<pre><code>sudo pecl install xdebug
</code></pre>

<p>il faut alors ajouter dans votre <code>php.ini</code> la ligne suivante</p>

<pre><code>zend_extension=/usr/lib/php5/20090626/xdebug.so
</code></pre>

<p>Ou plus propre rajouter dans un nouveau fichier  <code>/etc/php5/apache2/conf.d/xdebug.ini</code> et pareil pour la ligne de commande <code>/etc/php5/cli/conf.d/xdebug.ini</code></p>

<p>utiliser apt-get sous Ubuntu
<code>
sudo apt-get install php5-xdebug
</code>
sur mon Ubuntu, les fichier conf.d était déjà crée</p>

<h2>Paramétrer xdebug pour le debugger</h2>

<p>Il faut rajouter les lignes suivantes le <code>xdebug.ini</code></p>

<pre><code>xdebug.remote_enable=on
xdebug.remote_handler=dbgp
xdebug.remote_host=localhost
xdebug.remote_port=9000
</code></pre>

<p>Puis aller sur l&#8217;url en ajoutant
<code>
http://monsite.com/?XDEBUG_SESSION_START=1
</code>
Il y a des plugins Firefox et Chrome qui s&#8217;occupe de cela.</p>

<p>Pour que le debugger soit lancer par défaut. Vous pouvez rajouter la ligne suivante</p>

<pre><code class="ini">xdebug.remote_autostart=1
</code></pre>

<p>Pour tester en ligne de commande.</p>

<pre><code class="sh">php -dxdebug.remote_autostart=1 test.php
</code></pre>

<p>un simple script bash fait l&#8217;affaire. <code>php-debug</code></p>

<pre><code class="sh">#!/bin/bash
/usr/bin/php -dxdebug.remote_autostart=1 "$@"
</code></pre>

<h2>Les plugins VIM</h2>

<p>Je vais pas trop insister sur comment installer un plugin sous Vim. Ce n&#8217;est pas très compliqué. Il faut passer par un gestionnaire de plugin (la gestion des plugins par défaut dans Vim n&#8217;est pas pratique)</p>

<h2> Vdebug</h2>

<h3>Utilisation</h3>

<ul>
<li>appuyer sur <code>&lt;F5&gt;</code></li>
<li>vous avez 20 seconde pour lancer le script ou aller sur le serveur apache.</li>
<li>Une fois le signal capturé</li>
</ul>


<h3>Liste des raccourcis claviers</h3>

<p><img class="center" src="/images/VDebug.png" width="600" height="375" title="&lsquo;Vdebug&rsquo; &lsquo;Screenshot de VDebug&rsquo;" ></p>

<ul>
<li><code>&lt;F5&gt;</code>: start/run (to next breakpoint/end of script)</li>
<li><code>&lt;F2&gt;</code>: step over</li>
<li><code>&lt;F3&gt;</code>: step into</li>
<li><code>&lt;F4&gt;</code>: step out</li>
<li><code>&lt;F6&gt;</code>: stop debugging</li>
<li><code>&lt;F7&gt;</code>: detach script from debugger</li>
<li><code>&lt;F9&gt;</code>: run to cursor</li>
<li><code>&lt;F10&gt;</code>: toggle line breakpoint</li>
<li><code>&lt;F11&gt;</code>: show context variables (e.g. after &ldquo;eval&rdquo;)</li>
<li><code>&lt;F12&gt;</code>: evaluate variable under cursor</li>
<li><code>:VdebugEval &lt;code&gt;</code>: evaluate some code and display the result</li>
<li><code>&lt;Leader&gt;e</code>: evaluate the expression under visual highlight and display the result</li>
</ul>


<p>La touche <code>&lt;Leader&gt;</code> est par défault <code>\</code> sur un clavier anglais. <code>&lt;Leader&gt;e</code> correspond à <code>\e</code>. Pas simple à taper sur un clavier azerty. la touche <code>&lt;Leader&gt;</code> est réglable grâce à cette configuration du <code>.vimrc</code></p>

<pre><code>let mapleader = ","
</code></pre>

<p>Sur mon poste, je tape <code>,e</code></p>

<h3>Un avis</h3>

<p>Marche plutôt bien, mais par défaut Le debugger commence au début du script et pas au premier breakpoint.</p>

<p>Il faut rajouter cette ligne dans votre <code>.vimrc</code>.</p>

<pre><code>let g:vdebug_options["break_on_open"]=0
</code></pre>

<p>L&#8217;histoire des 20 secondes pour se connecter est un peu frustrante.</p>

<p>Par contre le code python est super propre.</p>

<h2>DBGPavim</h2>

<p><img class="center" src="/images/DBGPAVIM.png" width="600" height="375" title="&lsquo;DBGPavim&rsquo; &lsquo;Screenshot de DBGPavim&rsquo;" ></p>

<p>Ce plugin résout les deux problèmes de Vdebug (aucune limitation de temps, démarre au premier point d&#8217;arrêt). Je le trouve moins intuitif. Mais il est visiblement plus puissant, il gère plusieurs sessions.</p>

<p>Sur les screenshots la différence est plutôt minime.</p>

<p>Les touches sont un peu près les mêmes.</p>

<h2>Installations sous vim</h2>

<p>Suivant le plugin que vous avez choisi</p>

<p>Par <a href="https://github.com/tpope/vim-pathogen">Pathogen</a>:
<code>
git clone git://github.com/joonty/vdebug.git bundle/vdebug
ou
git://github.com/joonty/vdebug.git brookhong/DBGPavim.git
</code></p>

<p>Ou avec les submodules de Git</p>

<pre><code>git submodule add git://github.com/joonty/vdebug.git bundle/vdebug
# ou 
git submodule add git://github.com/brookhong/DBGPavim.git bundle/DBGPavim
</code></pre>

<p>Ajouter cette ligne à votre <code>.vimrc</code></p>

<p>par <a href="https://github.com/gmarik/Vundle.vim">Vundle</a>
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Bundle &ldquo;joonty/vdebug&rdquo;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h1&gt;ou&lt;/h1&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;Bundle &lsquo;brookhong/DBGPavim&rsquo;</span></code></pre></td></tr></table></div></figure></p>

<p>par <a href="https://github.com/Shougo/neobundle.vim">NeoBundle</a> :
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>NeoBundle &ldquo;joonty/vdebug&rdquo;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h1&gt;ou&lt;/h1&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;NeoBundle &lsquo;brookhong/DBGPavim&rsquo;</span></code></pre></td></tr></table></div></figure></p>

<h2>En conclusion</h2>

<p>Le debugger c&#8217;est chouette et cela rends un peu obsolète ce bon vieux <code>var_dump(); die();</code></p>

<p>D&#8217;ailleurs sur le <code>var_dump</code>. Il est plus simple de taper cette commande directement.</p>

<pre><code>die(var_dump($foo));
</code></pre>

<p>Enfin sur les versions récentes de Symfony la commande <code>dump()</code> est pratique.</p>

<p>Je vais reparler de xdebug. J&#8217;ai plein d&#8217;astuce à partager.</p>

<h2>Des liens</h2>

<ul>
<li><a href="https://github.com/joonty/vdebug">Vdebug</a></li>
<li><a href="https://github.com/brookhong/DBGPavim">DBGPAVIM</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Less Is More Et BASH]]></title>
    <link href="http://mcamuzat.github.io/blog/2015/06/28/less-is-more-et-bash/"/>
    <updated>2015-06-28T19:19:59+02:00</updated>
    <id>http://mcamuzat.github.io/blog/2015/06/28/less-is-more-et-bash</id>
    <content type="html"><![CDATA[<h2>less comme tail -f</h2>

<p>On peux utiliser <code>less</code> pour suivre et parser les logs avec la commande</p>

<pre><code>less +F nom_du_fichier
</code></pre>

<p>Ou tout simplement appuyer sur <code>F</code> quand le fichier est ouvert avec <code>less</code>.</p>

<p>Less est compatible avec les raccourcis VI donc les commandes suivantes marchent</p>

<pre><code>gg # debut du fichier
G # fin du fichier
/ #recherche
&amp; #affiche seulement les lignes qui contiennent le mot 
h,j,k,l les directions
</code></pre>

<p>les touche suivantes marche aussi avec <code>man</code></p>

<p>Je vous conseille ce post sur les <a href="blog/2015/03/08/comprendre-les-raccourcis-claviers-de-vi-slash-vim/">mouvement vi</a></p>

<h2>Éditer une ligne de commande trop complexe</h2>

<p>Si on souhaite récupérer la commande actuelle sous BASH. C&#8217;est <code>Ctrl x + Ctrl e</code>. Cela ouvre la commande actuelle dans <code>vi</code> ou votre éditeur par défaut <code>$EDITOR</code> enregistrer et quitter.</p>

<h2>Copier/Coller dans bash</h2>

<ul>
<li>Coupe toute la ligne : <code>Ctrl u</code></li>
<li>Coupe à droite du curseur: <code>Ctrl k</code></li>
<li>Coller <code>Ctrl y</code></li>
</ul>


<h3>Cas d&#8217;utilisation</h3>

<pre><code>vim /etc/hosts (oups j'ai oublié le sudo..)
&lt;Ctrl u&gt; sudo &lt;Ctrl k&gt;
</code></pre>

<h1>Annuler dans Bash</h1>

<p>C&#8217;est <code>Ctrl _</code></p>

<h1>En conclusion</h1>

<p>Les raccourcis claviers <code>Ctrl _</code> et <code>Ctrl y</code> sont des raccourcis claviers de emacs.</p>

<p>Bien qu&#8217;utilisateur Vim, j&#8217;aime beaucoup Emacs. Notamment le <code>org-mode</code>. Emacs est supérieur à Vim. (plus de mode, plus de personnalisation, une véritable interaction en REPL pour les langage type lisp). Il y a une tendance à utiliser Emacs avec le Evil-mode (ce qui en gros rajoute les raccourcis claviers de vim dans Emacs). Mais je pas encore passé le cap.</p>

<p>Il est possible de passer son BASH en Vi-mode avec la commande suivante. Personnellement j&#8217;aime pas.</p>

<pre><code>set -o vi
</code></pre>

<p>L&#8217;article <a href="http://www.catonmat.net/blog/bash-vi-editing-mode-cheat-sheet/">suivant</a> aide un peu. Mais ce n&#8217;est pas évident de dé-apprendre les raccourcis claviers.</p>

<h1>Quelques liens</h1>

<ul>
<li><a href="https://github.com/jlevy/the-art-of-command-line">the art of the command line</a></li>
<li><a href="http://www.commandlinefu.com">commandlinefu</a></li>
<li><a href="http://orgmode.org/index.html">org-mode</a></li>
<li><a href="http://www.emacswiki.org/emacs/Evil">evil-mode</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Copier Coller Dans Vim]]></title>
    <link href="http://mcamuzat.github.io/blog/2015/05/30/copier-coller-dans-vim/"/>
    <updated>2015-05-30T23:23:37+02:00</updated>
    <id>http://mcamuzat.github.io/blog/2015/05/30/copier-coller-dans-vim</id>
    <content type="html"><![CDATA[<h2>Pour commencer : comment sélectionner sous vim</h2>

<h3>solution n°1 : utiliser la souris</h3>

<p>tapez :
<code>bash
set mouse=a
</code>
vous pouvez sélectionnez avec la souris. Pour copier appuyer sur <code>y</code> comme <strong>y</strong>ank</p>

<h3>solution n°2 : utiliser le mode visuel</h3>

<p>avec la touche <code>v</code> ou <code>V</code> pour utiliser la ligne entière. Puis les flèches ou les <a href="/blog/2015/03/08/comprendre-les-raccourcis-claviers-de-vi-slash-vim/">mouvements</a></p>

<h3>solution n°3 : utiliser les touches mouvements</h3>

<p>Quelques exemples:</p>

<ul>
<li><code>y3w</code> copier trois mots (<strong>y</strong>ank <strong>3</strong> words)</li>
<li><code>yG</code> copier jusqu&#8217;à la fin du fichier (<strong>y</strong>ank fin</li>
<li><code>y5j</code> copier 5 lignes vers le bas (<strong>y</strong> <strong>5</strong> lignes vers le bas <code>j</code>)</li>
<li><code>yi(</code> pour copier le texte entre parenthèse (<strong>y</strong>ank <strong>i</strong>nside <code>(</code>)</li>
</ul>


<p>Pour coller on utilise la touche <code>p</code> pour <strong>p</strong>aste ou <code>P</code> (colle avant le curseur)</p>

<h2>Les presse-papiers sous vi ou les registres</h2>

<p>La notion de presse-papier est appelle registre dans Vi.</p>

<p>Pour voir l&#8217;état des registres (et si il ne fallait retenir qu&#8217;une seule commande..)</p>

<pre><code class="bash">:register ou :reg
</code></pre>

<p>Vous devez voir quelques choses dans le genre:</p>

<pre><code>"" dernier texte )
"0 dernier texte copié
... les dix derniers textes copiés
"9 ..  
"a contenu du registre "a" (s'il existe)
...
"% noms du fichier
". dernier texte inséré
"/ dernier texte recherché
": derniere commande.
</code></pre>

<ul>
<li>Pour coller le texte contenue dans le registre <code>a</code> il faut taper<code>"ap</code> pour le registre <code>"a</code> + <code>p</code> paste.</li>
<li>Pour copier le texte dans le registre a c&#8217;est <code>"ay</code></li>
<li>Avec les mouvements de vi <code>"ay3w</code> dans le registre a (<code>"a</code>) copier (<code>y</code> comme <em>yank</em>) 3 mots (3w pour 3 words).</li>
</ul>


<p>Un registre intéressant le registre <code>+</code> ou le registre <code>*</code> les deux registres sont associés au clipboard de Linux ou celui de windows.</p>

<h2>Pour résumer</h2>

<ul>
<li>Pour voir les registres. Il suffit de taper <code>:register</code>.</li>
<li>Pour coller un registre c&#8217;est <code>"&lt;nom du registre&gt;p</code>.</li>
<li>Pour copier c&#8217;est <code>"&lt;nom du registre&gt;y(+mouvement)</code>.</li>
<li>Le registre <code>+</code> est le presse-papier de windows ou linux. Pour copier/coller du presse-papier il suffit de taper <code>"+p</code> et <code>"+y</code>.</li>
<li>On a 26 presse-papiers de <code>a</code> à <code>z</code> personnellement j&#8217;en ai rarement utilisé plus de deux registres en même temps.</li>
</ul>


<p>Nous reparlerons des registres avec les macros dans un prochain post.</p>
]]></content>
  </entry>
  
</feed>
