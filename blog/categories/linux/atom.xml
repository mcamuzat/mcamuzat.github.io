<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Linux | Mon blog perso.]]></title>
  <link href="http://mcamuzat.github.io/blog/categories/linux/atom.xml" rel="self"/>
  <link href="http://mcamuzat.github.io/"/>
  <updated>2015-06-01T21:48:02+02:00</updated>
  <id>http://mcamuzat.github.io/</id>
  <author>
    <name><![CDATA[mcamuzat]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Copier Coller Dans Vim]]></title>
    <link href="http://mcamuzat.github.io/blog/2015/05/30/copier-coller-dans-vim/"/>
    <updated>2015-05-30T23:23:37+02:00</updated>
    <id>http://mcamuzat.github.io/blog/2015/05/30/copier-coller-dans-vim</id>
    <content type="html"><![CDATA[<h2>Pour commencer : comment sélectionner sous vim</h2>

<h3>solution n°1 : utiliser la souris</h3>

<p>tapez :
<code>bash
set mouse=a
</code>
vous pouvez sélectionnez avec la souris. Pour copier appuyer sur <code>y</code> comme <strong>y</strong>ank</p>

<h3>solution n°2 : utiliser le mode visuel</h3>

<p>avec la touche <code>v</code> ou <code>V</code> pour utiliser la ligne entière. Puis les flèches ou les <a href="/blog/2015/03/08/comprendre-les-raccourcis-claviers-de-vi-slash-vim/">mouvements</a></p>

<h3>solution n°3 : utiliser les touches mouvements</h3>

<p>Quelques exemples:</p>

<ul>
<li><code>y3w</code> copier trois mots (<strong>y</strong>ank <strong>3</strong> words)</li>
<li><code>yG</code> copier jusqu&#8217;à la fin du fichier (<strong>y</strong>ank fin</li>
<li><code>y5j</code> copier 5 lignes vers le bas (<strong>y</strong> <strong>5</strong> lignes vers le bas <code>j</code>)</li>
<li><code>yi(</code> pour copier le texte entre parenthèse (<strong>y</strong>ank <strong>i</strong>nside <code>(</code>)</li>
</ul>


<p>Pour coller on utilise la touche <code>p</code> pour <strong>p</strong>aste ou <code>P</code> (colle avant le curseur)</p>

<h2>Les presse-papiers sous vi ou les registres</h2>

<p>La notion de presse-papier est appelle registre dans Vi.</p>

<p>Pour voir l&#8217;état des registres (et si il ne fallait retenir qu&#8217;une seule commande..)</p>

<pre><code class="bash">:register ou :reg
</code></pre>

<p>Vous devez voir quelques choses dans le genre:</p>

<pre><code>"" dernier texte )
"0 dernier texte copié
... les dix derniers textes copiés
"9 ..  
"a contenu du registre "a" (s'il existe)
...
"% noms du fichier
". dernier texte inséré
"/ dernier texte recherché
": derniere commande.
</code></pre>

<ul>
<li>Pour coller le texte contenue dans le registre <code>a</code> il faut taper<code>"ap</code> pour le registre <code>"a</code> + <code>p</code> paste.</li>
<li>Pour copier le texte dans le registre a c&#8217;est <code>"ay</code></li>
<li>Avec les mouvements de vi <code>"ay3w</code> dans le registre a (<code>"a</code>) copier (<code>y</code> comme <em>yank</em>) 3 mots (3w pour 3 words).</li>
</ul>


<p>Un registre intéressant le registre <code>+</code> ou le registre <code>*</code> les deux registres sont associés au clipboard de Linux ou celui de windows.</p>

<h2>Pour résumer</h2>

<ul>
<li>Pour voir les registres. Il suffit de taper <code>:register</code>.</li>
<li>Pour coller un registre c&#8217;est <code>"&lt;nom du registre&gt;p</code>.</li>
<li>Pour copier c&#8217;est <code>"&lt;nom du registre&gt;y(+mouvement)</code>.</li>
<li>Le registre <code>+</code> est le presse-papier de windows ou linux. Pour copier/coller du presse-papier il suffit de taper <code>"+p</code> et <code>"+y</code>.</li>
<li>On a 26 presse-papiers de <code>a</code> à <code>z</code> personnellement j&#8217;en ai rarement utilisé plus de deux registres en même temps.</li>
</ul>


<p>Nous reparlerons des registres avec les macros dans un prochain post.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Docker-machine]]></title>
    <link href="http://mcamuzat.github.io/blog/2015/05/09/docker-machine/"/>
    <updated>2015-05-09T18:29:45+02:00</updated>
    <id>http://mcamuzat.github.io/blog/2015/05/09/docker-machine</id>
    <content type="html"><![CDATA[<h2>Introduction</h2>

<p>Nous allons voir <a href="https://docs.docker.com/machine/">docker-machine</a>. Docker-machine permet de simplifier l&#8217;installation/gestion/déploiement de Docker.</p>

<h2>Installation</h2>

<p>Tout d&#8217;abord il faut connaitre votre architecture <code>x86_64</code>ou <code>i386</code>.</p>

<p>La commande classique est <code>uname -a</code>.</p>

<p>Puis télécharger l&#8217;exécutable via <code>curl</code></p>

<p>Sous linux.
<code>bash
curl -L https://github.com/docker/machine/releases/download/v0.2.0/docker-machine_linux-amd64 &gt; docker-machine
sudo mv docker-machine /usr/local/bin/docker-machine
</code></p>

<p>Puis le marquer comme exécutable.
<code>bash
sudo chmod +x /usr/local/bin/docker-machine
</code></p>

<p>Testons notre application.
<code>bash
docker-machine -v
</code></p>

<p>Enfin vous avez besoin d&#8217;avoir <a href="https://www.virtualbox.org/wiki/Downloads">Virtual-Box</a></p>

<h2>Mise en route.</h2>

<p>Voici la commande pour tout lancer</p>

<pre><code class="bash">docker-machine create --driver virtualbox dev
</code></pre>

<p>Cette ligne demande à docker-machine de créer une environnement que l&#8217;on appelle <strong>dev</strong> qui sera sur Virtual-box.
docker-machine va télécharger une iso (boot2docker) contenant docker. Et lancer Virtualbox.</p>

<p>Jusqu&#8217;à maintenant on avait installé docker sur notre ordi local.
Ici on installe docker sur une VM.
Toutes les commandes seront passer de manière transparente à la machine virtuelle.
L&#8217;avantage de cette méthode est que tout le monde utilise la même iso virtuelle (boot2docker). Il n&#8217;y a moins le risque du &ldquo;chez moi ça marche&rdquo; qui est une remarque au combien rageante.</p>

<p>Je veux travailler sur mon environnement de dev</p>

<pre><code>eval "$(docker-machine env dev)"
</code></pre>

<p>Toutes mes commandes sont directement envoyées sur la vm à distance
<code>
docker run busybox echo hello
</code></p>

<p>Je peux rajouter un environnement (ici <strong>prod</strong>)
<code>
docker-machine create --driver amazon prod --les options qui vont bien..
</code></p>

<p>Il suffit de changer l&#8217;environnement pour automatiquement déployer sur Amazon.
<code>
eval "$(docker-machine env prod)"
</code></p>

<p>Plein de drivers sont fournis:</p>

<ul>
<li><a href="https://docs.docker.com/machine/#amazon-web-services">Amazon Web Services</a></li>
<li><a href="https://docs.docker.com/machine/#digital-ocean">Digital Ocean</a></li>
<li><a href="https://docs.docker.com/machine/#google-compute-engine">Google Compute Engine</a></li>
<li><a href="https://docs.docker.com/machine/#ibm-softlayer">IBM Softlayer</a></li>
<li><a href="https://docs.docker.com/machine/#microsoft-azure">Microsoft Azure</a></li>
<li><a href="https://docs.docker.com/machine/#microsoft-hyper-v">Microsoft Hyper-V</a></li>
<li><a href="https://docs.docker.com/machine/#openstack">Openstack</a></li>
<li><a href="https://docs.docker.com/machine/#rackspace">Rackspace</a></li>
<li><a href="https://docs.docker.com/machine/#oracle-virtualbox">Oracle VirtualBox</a></li>
<li><a href="https://docs.docker.com/machine/#vmware-fusion">VMware Fusion</a></li>
<li><a href="https://docs.docker.com/machine/#vmware-vcloud-air">VMware vCloud Air</a></li>
<li><a href="https://docs.docker.com/machine/#vmware-vsphere">VMware vSphere</a></li>
</ul>


<h2>L&#8217;avantage de docker-machine</h2>

<ul>
<li>Simplifie l&#8217;installation. il n&#8217;y a que docker-machine à installer. Arès docker-machine s&#8217;occupe de tout installer. (il installe docker sur un vm/instance)</li>
<li>Simplifie le déploiement, il suffit de changer l&#8217;environnement</li>
<li>Enfin il s&#8217;interface avec docker-swarm (qui permet de gérer plusieurs nodes de Dockers).</li>
</ul>


<h2>En conclusion</h2>

<p>Le slogan &ldquo;a way to get from zero to Docker&rdquo; est plutôt juste.</p>

<ul>
<li>Cela simplifie beaucoup l&#8217;installation sous windows (pas testé :-)).</li>
<li>Et harmonise les environnements de dev (tout le monde utilise la même iso)</li>
<li>Facilite le déploiement. Il n&#8217;y a pas a se soucier si c&#8217;est du Amazon/OpenStack/Azure..</li>
</ul>


<p>Dans un prochain post nous allons essayer de voir docker-swarm.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Docker Et Dockerfile]]></title>
    <link href="http://mcamuzat.github.io/blog/2015/04/26/docker-et-dockerfile/"/>
    <updated>2015-04-26T19:44:44+02:00</updated>
    <id>http://mcamuzat.github.io/blog/2015/04/26/docker-et-dockerfile</id>
    <content type="html"><![CDATA[<h2>Introduction</h2>

<p>Je continue dans mon exploration de Docker, aujourd&#8217;hui nous allons voir comment automatiser la création d&#8217;un container à l&#8217;aide d&#8217;un <code>Dockerfile</code>.</p>

<p>Nous allons créer un container pour <a href="http://jonas.nitro.dk/tig/">tig</a>.. C&#8217;est un interface git qui marche sous un terminal. Pour moi, c&#8217;est un magnifique outil de travail. Je m&#8217;en sers très souvent (surtout la vue de status (touche <code>S</code>) puis <code>u</code> pour ajouter, <code>!</code> pour reverter, <code>C</code> pour commit, <code>e</code> pour lancer mon éditeur (Bien entendu Vim)</p>

<p>Nous allons faire</p>

<ul>
<li>L&#8217;installation à la main</li>
<li>Puis écrire le <code>Dockerfile</code> qui automatise la partie 1</li>
<li>Optimiser un peu celui-ci en utilisant une autre distribution</li>
<li>Faire des commit sous Github, puis sous DockerHub</li>
</ul>


<h2>Création du container à la main</h2>

<p>Je commence avec une Ubuntu que je lance en mode interactif.</p>

<pre><code class="sh">docker run -it ubuntu:14.10
</code></pre>

<p>Je mets à jour ma distribution
<code>
apt-get update
</code></p>

<p>J&#8217;installe tig (il est dans les dépôts officiels)</p>

<pre><code class="sh">apt-get install -y tig
</code></pre>

<p>A cause du <code>apt-get update</code> Ubuntu a téléchargé toutes les sources des dépôts dans le répertoire <code>var/lib/apt/lists/</code> pour ne pas alourdir le container je vais effacer celui-ci
<code>
rm -rf /var/lib/apt/lists/*
</code></p>

<p>Je lance <code>tig</code>
<code>
root@0a475b7fbed7:/# tig
tig: Not a git repository
</code></p>

<p>Il n&#8217;y a pas de dépot git à la racine c&#8217;est normal.</p>

<p>je quitte mon container et je liste</p>

<pre><code>docker ps -a
CONTAINER ID        IMAGE                                         COMMAND                CREATED             STATUS                            PORTS                                                                         NAMES
0a475b7fbed7        ubuntu:14.10                                  "/bin/bash"            13 minutes ago      Exited (130) About a minute ago
</code></pre>

<p>Je vais le committer.
<code>
docker commit -m "add tig" -a "mcamuzat" admiring_yonath mcamuzat/tig:v1
</code></p>

<p>Je vais le relancer avec la commande suivante.
<code>
docker run -t -i -v `pwd`:/project mcamuzat/tig:v1
</code></p>

<p>En gros j&#8217;ai crée un lien symbolique qui pointe le répertoire courant de mon ordinateur vers le répertoire <code>project</code> du container.</p>

<p>je me place dans le répertoire project.
<code>
cd /project
</code></p>

<p>et je lance tig
<code>
tig
</code></p>

<p>Si dans le répertoire courant il y a un dépôt git. Normalement l&#8217;interface de Tig apparait.</p>

<p>Voila j&#8217;ai placé tig dans un container.</p>

<h2>Automatisation via un DockerFile.</h2>

<p>On se place dans un répertoire vide</p>

<p>Je crée un fichier <code>DockerFile</code> avec le contenu suivant</p>

<pre><code>FROM ubuntu:14.10
MAINTAINER Marc Camuzat &lt;marco@crans.org&gt;
RUN apt-get update \
    &amp;&amp; apt-get install -y mysql-client \
    &amp;&amp; rm -rf /var/lib/apt/lists/*
WORKDIR /project
VOLUME  /project
ENTRYPOINT ["tig"]
</code></pre>

<p><code>WORKDIR</code> et <code>VOLUME</code> indique à Docker que le répertoire par défault est <code>project</code> et que l&#8217;on lance tig</p>

<p>On va maintenant demander à docker de <em>builder</em> l&#8217;image à l&#8217;aide de la commande suivante</p>

<pre><code>docker build -t mcamuzat/tig:v2 .
</code></pre>

<p>On attend un peu.. Et on relance
<code>
docker run -t -i -v `pwd`:/project mcamuzat/tig:v2
</code></p>

<p>C&#8217;est beaucoup plus rapide.</p>

<h2>Optimisons la taille.</h2>

<p>Quand je liste mon image via la commande suivante</p>

<pre><code>REPOSITORY              TAG                     IMAGE ID            CREATED             VIRTUAL SIZE
mcamuzat/tig            v2                      103a05c16a2b        3 minutes ago       234.6 MB
</code></pre>

<p>Mon container fait 234 méga ! C&#8217;est beaucoup pour un simple utilitaire.
pour simplifier je vais utiliser une autre distribution <a href="https://www.alpinelinux.org/">alpine-linux</a> (que je ne connaissais pas ..) et le dockerhub <a href="https://registry.hub.docker.com/u/gliderlabs/alpine/">suivant</a> qui réduit la distribution à 5 méga !</p>

<p>Voici mon <code>DockerFile</code></p>

<pre><code>FROM gliderlabs/alpine:3.1
RUN apk --update add tig
WORKDIR /project
VOLUME  /project
ENTRYPOINT ["tig"]
</code></pre>

<p>Je relance un build.</p>

<pre><code>docker build -t mcamuzat/tig:v3 .
</code></pre>

<p>Maintenant mon container ne fait plus que 24 Méga !</p>

<h2>Publions sous Github</h2>

<p>Nous allons créer un nouveau dépôt avec un README.</p>

<p>Que je vais cloner.
<code>
git clone https://github.com/mcamuzat/tig-docker.git
</code></p>

<p>Je vais ajouter mon DockerFile, Commiter et Pusher
<code>
git add Dockerfile
git commit -m"initial commit"
git push origin master
</code></p>

<p>Et c&#8217;est tout.</p>

<p>Résultat <a href="https://github.com/mcamuzat/tig-docker">ici</a></p>

<h2>Publions sur DockerHub</h2>

<p>Je pars du principe que vous avez un compte sur DockerHub.</p>

<ul>
<li>Cliquer sur le bouton <code>Add Repository-&gt;Automated Build</code></li>
<li>choisir Github.</li>
<li>Puis On va vous demander de relier votre compte DockerHub à Github.</li>
<li>DockerHub va vous demander quel projet vous souhaitez builder automatiquement.</li>
</ul>


<p>Résultat <a href="https://registry.hub.docker.com/u/mcamuzat/tig/">ici</a></p>

<h2>Conclusion</h2>

<p>Le Dockerfile sert à automatiser la création d&#8217;image. il est plus simple de stocker le <code>Dockerfile</code> que le container (puisque Dockerhub s&#8217;occupe de faire build)</p>

<p>J&#8217;ai crée mon premier dépôt. Ce n&#8217;est pas très compliqué. Dans un prochain article, je vais essayer d&#8217;expérimenter <code>docker compose</code>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Docker Je Débute]]></title>
    <link href="http://mcamuzat.github.io/blog/2015/04/12/docker-je-debute/"/>
    <updated>2015-04-12T22:25:27+02:00</updated>
    <id>http://mcamuzat.github.io/blog/2015/04/12/docker-je-debute</id>
    <content type="html"><![CDATA[<h2>Docker</h2>

<p>Suite à une présentation à une conférence. J&#8217;ai commencé à m&#8217;y mettre. J&#8217;écris ce post en tant que grand débutant..</p>

<p>Docker est une solution de virtualisation d&#8217;instance, plus précisément de container. Il y a pas mal de différence avec les différentes visualisations de Virtual box/Xen/VmWare. On isole juste les process et le file-system. Ce qui fait que l&#8217;on consomme très peu de processeurs.</p>

<h2>Installation</h2>

<p>Installer docker n&#8217;est pas très compliqué sous ubuntu 14.04.</p>

<pre><code class="bash">sudo apt-get install docker.io
</code></pre>

<p>Et c&#8217;est tout !</p>

<p>Pour éviter de préfixer <code>sudo</code> à chaque commande il est plus facile d&#8217;ajouter son utilisateur au group docker.</p>

<pre><code class="bash">sudo addgroup &lt;votre user&gt; docker
</code></pre>

<h2>Hello world sous docker</h2>

<p>Lancer docker</p>

<pre><code>docker run ubuntu:14.04 /bin/echo 'Hello world'
</code></pre>

<p>Cette commande fait plusieurs choses:</p>

<ul>
<li>si l&#8217;image <code>ubuntu:14.04</code> n&#8217;existe pas, elle va la télécharger.</li>
<li>Puis on lance le container</li>
<li>Puis on exécute echo &lsquo;Hello world&rsquo;</li>
</ul>


<p>D&#8217;ailleurs si on relance la même commande, on constate que l&#8217;image est déjà sur le disque dur.</p>

<p>la commande prend moins d&#8217;une seconde. Pourtant on a chargé un container et lancer une commande !</p>

<p>Essayons la commande suivante
<code>
docker run ubuntu:14.04 - it /bin/bash
root@b2634b81c3dc:/#
</code></p>

<p>Nous avons un bash intéractif. <code>-i</code> mode interactif, et <code>-t</code> affiche un pseudo terminal</p>

<p>Il faut comprendre que  dès que la commande principale est finie, l&#8217;instance aussi. Dans le cas <code>Echo 'Hello World'</code> la commande se finit de suite. Dans le cas de <code>/bin/bash</code> On spécifie le mode interactif. Donc l&#8217;instance continue tant que l&#8217;on a pas quitté le bash.</p>

<p>Ouvrons un nouveau terminal
<code>
docker ps
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES
b2634b81c3dc        ubuntu:14.04        /bin/bash           43 seconds ago      Up 42 seconds                           sharp_archimedes
</code>
On voit que mon image est toujours en cours.</p>

<p>La commande docker ps affiche tout les containers allumés pour afficher tout les containers allumés pendant la session. C&#8217;est <code>dockers ps -a</code></p>

<p>On peux inspecter une instance avec la commande
<code>
docker inspect sharp_archimedes
docker inspect b2634b81c3dc
</code>
Cela renvoie un json.</p>

<p>On peux aussi lister les images disponibles via la commande</p>

<pre><code>docker images
</code></pre>

<p>Vous voulez télécharger des images
<code>
docker pull centos
</code></p>

<p>Vous cherchez une images particulières
<code>
docker search php56
</code></p>

<p>La liste des images disponibles est disponible sur <a href="https://hub.docker.com/">Docker Hub</a> . D&#8217;ailleurs Dockers est très couplé avec DockerHub. DockerHub est un le GitHub pour Docker. On peux très bien faire du Git sans GitHub. C&#8217;est la même chose pour docker.</p>

<p>Docker et Git partage aussi la notion de commit et de push.</p>

<p>relancons notre instance
<code>
docker run -it ubuntu:14.04 /bin/bash
root@f5882f7f608d:/#
</code></p>

<p>Installons un paquet au hasard
<code>
sudo apt-get install vim
</code></p>

<p>On quitte <code>Exit</code></p>

<p>puis on commit
<code>sh
sudo docker commit f5882f7f608do marc/vim
4f177bd27a9ff0f6dc2a830403925b5360bfe0b93d476f7fc3231110e7f71b1c
</code></p>

<p>Si je liste les images.
<code>sh
docker images
</code></p>

<p>je vois apparaitre mon <code>marc/vim</code></p>

<p>Je peux ainsi réutiliser mon container ainsi
<code>sh
sudo docker run -it marc/vim vim
</code></p>

<p>On peux ainsi se créer ses propres containers. Mais c&#8217;est un peu laborieux. Docker utilise des <code>DockerFile</code> pour automatiser le process. Cela fera un prochain post</p>

<h2>Résumé des commandes</h2>

<ul>
<li><code>docker run -i -t ubuntu:14.10 /bin/bash</code> lance en mode interactif et un terminal avec la commande Bash.</li>
<li><code>docker run -i -t ubuntu:14.10 'hello world'</code></li>
<li><code>docker ps</code> liste les containers en cours.</li>
<li><code>docker ps -a</code> liste tout les containers.</li>
<li><code>docker images</code> liste toutes les images.</li>
<li><code>docker pull centos</code> pour télécharger une image (tout les images officielles sont sur le <a href="https://hub.docker.com/">Hub</a></li>
<li><code>docker inspect uuid</code> affiche les informations sur l&#8217;instance.</li>
<li><code>docker commit uuid name</code>pour commiter.</li>
</ul>


<h2>Conclusion</h2>

<p>Bon j&#8217;avoue que je débute depuis 2 jours.  Ce qui m&#8217;impressionne dans Docker c&#8217;est la vitesse (moins d&#8217;une seconde pour démarrer). C&#8217;est plutôt simple d&#8217;utilisation. La notion de commit a l&#8217;air sympa (Même si au fond c&#8217;est l&#8217;équivalent d&#8217;un snapshot sous vmware). J&#8217;espère pouvoir faire mon premier dépôt sous DockerHub bientôt.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Comprendre La Ligne De Commande De Vi]]></title>
    <link href="http://mcamuzat.github.io/blog/2015/03/30/comprendre-la-ligne-de-commande-de-vi/"/>
    <updated>2015-03-30T22:36:21+02:00</updated>
    <id>http://mcamuzat.github.io/blog/2015/03/30/comprendre-la-ligne-de-commande-de-vi</id>
    <content type="html"><![CDATA[<p>Sous Vi quand on appuie sur <code>:</code> on a la ligne de commande</p>

<p>Tout le monde connaît
<code>
:wq // quitter et enregistrer
:q! // quitter sans enregistrer et sans confirmation !
</code></p>

<p>Mais en pratique il existe plein de commandes.</p>

<p>Par exemple :</p>

<pre><code>:1,10d 
</code></pre>

<p>efface la ligne 1 à 10 (<code>d</code> = delete)</p>

<pre><code>:1,10m 10
</code></pre>

<p>bouge les lignes de 1 à 10 de 10 ligne (ici <code>m</code> = move)</p>

<dl>
<dt>le &ldquo;pattern&rdquo; est toujours le même</dt>
<dt>&#8220;`</dt>
<dd>(début, fin)action
<code>``
| mouvements | traduction|
| ------------- |:-------------:|
|</code>1,10<code>     | entre la ligne 1 et  la ligne 1 à 10 |
|</code>.,10<code>     |</code>.<code>signifie la ligne actuelle      |
|</code>10,$<code>|</code>$<code>signifie la dernière ligne|
|</code>/mot1/,/mot2/<code>| entre le</code>mot1<code>et le</code>mot2<code>|
|</code>., +5<code>| entre la ligne actuelle (</code>.<code>) et les 5 lignes suivantes|
|</code>%` | tout le fichier|</dd>
</dl>

<p>quelques actions</p>

<table>
<thead>
<tr>
<th>racourcci</th>
<th> traduction</th>
</tr>
</thead>
<tbody>
<tr>
<td> <code>d</code> </td>
<td> comme <strong>d</strong>elete</td>
</tr>
<tr>
<td> <code>j</code> </td>
<td> comme <strong>j</strong>oin</td>
</tr>
<tr>
<td><code>sort</code></td>
<td> trier (sort) les lignes</td>
</tr>
<tr>
<td><code>w</code></td>
<td> pour enregistrer</td>
</tr>
<tr>
<td><code>y</code></td>
<td> comme yank</td>
</tr>
</tbody>
</table>


<h2>le plus connu substitute</h2>

<p>vous avez souvent vu cette syntaxe dans les commits <code>s/mot1/mot2</code></p>

<p>ici <code>s</code> signifie <strong>substitute</strong>.</p>

<p>par exemple
<code>
:%s/mot1/mot2/g
</code>
va remplacer le mot 1 par le mot 2
le <code>g</code> active le flag <code>global</code> et remplace si le mot apparait deux fois.</p>

<p>par exemple
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$mot1 = $mot1 + 1;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;// s/mot1/mot2
</span><span class='line'>$mot2 = $mot1 + 1 ; // on ne change que le premier mot&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;// s/mot1/mot2/g
</span><span class='line'>$mot2 = $mot2 + 1 // tout les mots</span></code></pre></td></tr></table></div></figure></p>

<h2>Encore un peu plus loin</h2>

<p>la commande suivante permet de grouper les mots
<code>
:g/mot/ #donne toute les lignes contenant mot
</code>
<code>g</code> ici signifie <strong>g</strong>roup</p>

<p>On peut chaîner les differentes actions
par exemple
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>:g/pattern/s/mot/mot2/g # toutes les lignes qui contiennent le pattern, remplace mot1 par mot2.&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;:g/pattern/d # efface toute les lignes qui contiennent le pattern suivant&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;:g/pattern/p # &lsquo;print toutes lignes qui contienne le pattern suivant</span></code></pre></td></tr></table></div></figure></p>

<p>la derniere ligne est la plus connue. pattern est le plus souvent une <em>regex</em> donc la traduction <code>g/regex/p</code> ->donne la commande <code>grep</code> sous linux.</p>

<p>en faite, toutes les commandes que j&#8217;ai données proviennent de <code>sed</code>. mais ce n&#8217;est pas un hasard. <code>vi</code> est l&#8217;abbreviation de <strong>V</strong>isual <strong>I</strong>nteraction of Sed. un <em>sed interactif</em>.</p>

<p>J&#8217;espère que cela vous fera apprecier <code>sed</code> comme <code>vi</code>. on peut rester très longtemps sur toutes les commandes.</p>

<p>j&#8217;avais expliqué dans un précédent articles les mouvements en mode normal sont
&#8220;`
Action + Nombre de fois + Mouvement</p>

<p>Exemple:
d5w # <em>d</em>elete <em>5</em> word
yG  # copier jusqu&#8217;à la fin du fichier (G)
=4j # indenter (=) 4 lignes vers le bas
di( # efface entre les parenthèses <em>d</em>elete <em>i</em>nside (</p>

<dl>
<dt>Dans le mode commande</dt>
<dd>début, fin action</dd>
</dl>

<p>:%d # efface tout le fichier
:1,10y # copie dans le presse-papier la ligne 1 à 10
:%s/include_one/require_once/gc</p>

<pre><code>
Il me reste à vous parler des buffers et des macros. et on aura presque fait le tour de la magie de `vi`.

##une commande de la vrai vie
</code></pre>

<p>:%s/\s+$//
<code>``
sur tout le fichier (</code>%<code>) remplace(</code>s<code>) un ou plus(</code>+<code>) espaces (</code>\s<code>) à la fin de la ligne (</code>$`) par du vide. cette commande supprime les espaces vides à la fin des lignes..</p>
]]></content>
  </entry>
  
</feed>
