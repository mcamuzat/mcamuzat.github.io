<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Php | Mon blog perso.]]></title>
  <link href="http://mcamuzat.github.io/blog/categories/php/atom.xml" rel="self"/>
  <link href="http://mcamuzat.github.io/"/>
  <updated>2015-04-26T20:05:47+02:00</updated>
  <id>http://mcamuzat.github.io/</id>
  <author>
    <name><![CDATA[mcamuzat]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Dockers Et CI]]></title>
    <link href="http://mcamuzat.github.io/blog/2015/04/18/dockers-et-ci/"/>
    <updated>2015-04-18T18:13:48+02:00</updated>
    <id>http://mcamuzat.github.io/blog/2015/04/18/dockers-et-ci</id>
    <content type="html"><![CDATA[<h2>Introduction</h2>

<p>je continue sur ma découverte de Docker. Je vais parler de deux containers</p>

<ul>
<li><a href="https://github.com/jolicode/docker-images/tree/master/languages/php/phaudit">phaudit</a>  pour faire de la qualité de code</li>
<li><a href="https://github.com/jolicode/JoliCi">JoliCi</a> pour l&#8217;intégration continu</li>
</ul>


<h2>Faire de la qualité avec Docker</h2>

<p>Il y a un container fourni par <a href="https://github.com/jolicode/docker-images/tree/master/languages/php/phaudit">phaudit</a> qui contient déjà des outils pour auditer le code.</p>

<p>Voici la ligne de commande pour l&#8217;installer
<code>
docker pull jolicode/phaudit
</code></p>

<p>Et je me place dans mon répertoire projet</p>

<h3>Listes des programmes</h3>

<ul>
<li><a href="http://github.com/sebastianbergmann/phploc">PHPLoc</a> <code>phploc</code> donne le nombre de ligne, le nombre de classes etc ..</li>
</ul>


<pre><code>docker run -t -i -v `pwd`:/project jolicode/phaudit phploc src
Directories                                         10
Files                                               91

Size
  Lines of Code (LOC)                             7295
  Comment Lines of Code (CLOC)                    3228 (44.25%)
  Non-Comment Lines of Code (NCLOC)               4067 (55.75%)
  Logical Lines of Code (LLOC)                     774 (10.61%)
    Classes                                        711 (91.86%)
      Average Class Length                           8
        Minimum Class Length                         0
        Maximum Class Length                        67
      Average Method Length                          1
        Minimum Method Length                        0
</code></pre>

<ul>
<li><a href="http://phpmd.org/">PHP Mess Detector</a> <code>phpmd</code> donne un retour sur la qualité du code (nommage des variables etc..)</li>
</ul>


<pre><code>phaudit phpmd . text naming
/project/src/Allmy/Protocol/LineReceiver.php:38 Avoid variables with short names like $b. Configured minimum length is 3.
/project/src/Allmy/Reactor/StreamSelectReactor.php:32   Avoid variables with short names like $id. Configured minimum length is 3.
/project/src/Allmy/Reactor/StreamSelectReactor.php:43   Avoid variables with short names like $id. Configured minimum length is 3.
/project/src/Allmy/Reactor/StreamSelectReactor.php:53   Avoid variables with short names like $id. Configured minimum length is 3.
...
...
</code></pre>

<ul>
<li><a href="http://pear.php.net/PHP_CodeSniffer">PHP_CodeSniffer</a>  <code>phpcs</code> erreur de convention de code (Psr-..) et  <code>phpcbf</code>pour les fixer automatiquement</li>
</ul>


<pre><code>docker run -t -i -v `pwd`:/project jolicode/phaudit phpcs src/Allmy/Reactor/StreamSelectReactor.php
FILE: /project/src/Allmy/Reactor/StreamSelectReactor.php
----------------------------------------------------------------------
FOUND 85 ERRORS AND 3 WARNINGS AFFECTING 63 LINES
----------------------------------------------------------------------
   2 | ERROR   | [ ] Missing file doc comment
  11 | ERROR   | [ ] Missing class doc comment
  15 | ERROR   | [ ] Private member variable "timers" must be
.....
.....
.....
 275 | ERROR   | [ ] Parameter tags must be grouped together in a doc
</code></pre>

<ul>
<li><a href="http://github.com/sebastianbergmann/phpcpd">PHP Copy/Paste Detector</a> <code>phpcpd</code> détecte les copier/coller</li>
</ul>


<pre><code class="">
docker run -t -i -v `pwd`:/project jolicode/phaudit phpcpd src
Found 2 exact clones with 101 duplicated lines in 4 files:

  - /project/src/Allmy/Stream/Factory.php:9-53
    /project/src/Allmy/Internet/Factory.php:9-53

  - /project/src/Allmy/Transport/TcpServer.php:9-66
    /project/src/Allmy/Socket/Server.php:9-66

1.38% duplicated lines out of 7295 total lines of code.
</code></pre>

<p>d&#8217;autre commandes que je connais un peu moins</p>

<ul>
<li><p><a href="http://pdepend.org/">PHP_Depend</a> <code>pdepend</code> donnes des analyses, dépendences, complexités etc..</p></li>
<li><p><a href="http://github.com/sebastianbergmann/phpdcd">PHP Dead Code Detector</a> <code>phpdcd</code> détecte le code qui semble ne pas servir.</p></li>
<li><p><a href="http://www.phpmetrics.org/">PhpMetrics</a> <code>phpmetrics</code> donnes des métriques (Je ne connais pas)
<code>
docker run -t -i -v `pwd`:/project jolicode/phaudit phpmetrics --report-cli .
</code></p></li>
<li><a href="http://cs.sensiolabs.org/">PHP Coding Standards Fixer</a> as <code>php-cs-fixer</code> une autre commandes pour fixer le code par <a href="http://cs.sensiolabs.org/">Sensio</a></li>
</ul>


<p>L&#8217;astuce est de se créer l&#8217;alias suivant
<code>
alias phaudit="docker run --rm -ti \
    -v \`pwd\`:/project \
    jolicode/phaudit"
</code></p>

<p>alors les lignes de commandes précédentes deviennent plus simple
<code>
phaudit phpmd . text naming
</code></p>

<h2>Tester sur toutes les versions de php</h2>

<p>Fait par la même équipe.</p>

<p>il est possible de faire une intégration continue en local. Il va lancer les builds en testant toutes versions de php spécifié dans un fichier <code>yml</code>.</p>

<p>L&#8217;installation est très simple il suffit de télécharger le <code>.phar</code> à l&#8217;url <a href="https://github.com/jolicode/JoliCi/releases">suivante</a>
<code>
wget url du fichier phar
</code></p>

<p>il faut créer un fichier <code>.travis.yml</code> voici les lignes à ajouter pour un projet en php
<code>yml
language: php
php:
  - "5.5"
  - "5.4"
  - "5.3"
</code>
puis la commande suivante:</p>

<pre><code>php jolici.phar run
Creating builds...
3 builds created

Running job php = 5.5

PHPUnit 3.7.38 by Sebastian Bergmann.

Configuration read from /home/project/phpunit.xml.dist

......

Time: 106 ms, Memory: 3.50Mb

OK (6 tests, 34 assertions)

Running job php = 5.4

PHPUnit 3.7.38 by Sebastian Bergmann.

Configuration read from /home/project/phpunit.xml.dist

......

Time: 131 ms, Memory: 3.50Mb

OK (6 tests, 34 assertions)

Running job php = 5.3

PHPUnit 3.7.38 by Sebastian Bergmann.

Configuration read from /home/project/phpunit.xml.dist

......

Time: 7 ms, Memory: 6.25Mb

OK (6 tests, 34 assertions)
</code></pre>

<p>En ajoutant un fichier <code>.yml</code> et sans installer aucune version de php, je peux tester sur trois plateformes mon code. C&#8217;est vraiment impressionnant.</p>

<h2>Conclusion</h2>

<p>Nous avons vus ensemble deux applications très simples qui permettent d&#8217;intégrer Docker dans notre workflow.</p>

<p>Merci à l&#8217;équipe <a href="http://jolicode.com/">JoliCode</a>  pour ces deux outils.</p>

<p>Je me suis inspiré de la présentation suivante.
<a href="http://slides.com/jeremyderusse/docker-dev#/5/2">http://slides.com/jeremyderusse/docker-dev#/5/2</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[10print]]></title>
    <link href="http://mcamuzat.github.io/blog/2015/04/15/10print/"/>
    <updated>2015-04-15T22:38:15+02:00</updated>
    <id>http://mcamuzat.github.io/blog/2015/04/15/10print</id>
    <content type="html"><![CDATA[<p>Je suis tombé un peu par hasard sur la critique du livre <a href="http://10print.org/">10 PRINT</a> , le pdf du livre est gratuit et plutôt joli, il parle de programmation, d&#8217;art et d&#8217;aléatoire.
Tout le livre est centré sur le programme de basic suivant qui donne l&#8217;image de la couverture.</p>

<pre><code>10 PRINT CHR$(205.5+RND(1)); : GOTO 10
/\\\\\\//\\////\\/\/\/\//\///////\\/////\///\\/\\
\/\///\/\//\\//\\\/\\\/\///\\\\\\/\/\\\\\\/\\\/\\
\\////\/////\\\\\\\/\\\\\\\\\\\//////\/\/\\\\/\//
/\//\\\/\\\/\\///\\//\////\\/\/\//\\//\//\\/////\
///\\/\\\\///\\/\/////\\\/\\\///\//\\\\//\\//\//\
//\\\\//\\/\//\\//\///\\/////\///\/\//\/\//\//\\/
//\/\/\///\\\/\//\////\\\//\/\/\\\\\\//\\\\\///\/
//\\/\\\//\////\//\\\\\/\////\\\///\/\\/\//\\\///
//\//\/\\\\\//////\///\/\\\/\/\/\\//\\/\\\//\//\\
//\/\/\\\/\\/\/\////\//\\//\\//\/\///\/\/////\///
//\\//\\\/////\//\//\\/\\//\/\//\//\\/\//\\\\\//\
</code></pre>

<p>Bon la police d&#8217;écriture ne rend pas vraiment justice au code.</p>

<p>C&#8217;est possible de faire le même motif en PHP et en peu de code ?</p>

<p>Une solution
<code>php
$out = array('/', '\\');
for($i = 0; $i &lt; 1000; $i++){
    echo $out[array_rand($out)];
}
</code></p>

<p>Attention <code>array_rand</code> renvoie la clé et non la valeur d&#8217;où le <code>$out[array_rand($out)]</code></p>

<p>Et puis je me suis dit que array_rand ne sert pas à grand chose.</p>

<p>Donc j&#8217;ai essayé
<code>php
$out = array('/', '\\');
for($i =0; $i &lt; 1000; $i++){
 echo $out[rand(0,1)];
}
</code>
pour générer des nombres aléatoire, il vaut mieux utiliser <code>mt_rand</code> qui d&#8217;après la documentation génère des nombres aléatoires plus intéressants (?). Pour des vrai nombres aléatoires pour les mots de passe,  on utilise des librairies voir cette <a href="http://blog.ircmaxell.com/2013/01/password-storage-talk-at-php-benelux-13.html">présentation</a>.</p>

<p>Mais il est possible d&#8217;initialiser plus d&#8217;une constante dans la boucle for.</p>

<pre><code>for($i =0, $out = array('/', '\\'); $i &lt; 1000; $i++){
 echo $out[mt_rand(0,1)];
}
</code></pre>

<p>On peut aussi faire plus d&#8217;une action dans l&#8217;incrémentation.</p>

<pre><code>for($i = 0, $out = array('/', '\\'); $i &lt; 1000; $i++, echo $out[mt_rand(0,1)])
);
</code></pre>

<p>On minimise les variables et la notation avec les <code>[]</code></p>

<p>Nous obtenons le code suivant</p>

<pre><code class="php">for($i =0, $o = ['/', '\\']; $i &lt; 1000; $i++, echo $o[mt_rand(0,1)]);
</code></pre>

<p>Je n&#8217;avais jamais écris de boucle for sans corps(<code>{..}</code>).</p>

<p>La documentation de PHP est plutôt claire sur le <a href="http://php.net/manual/fr/control-structures.for.php">for</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Suite Visiteur Pattern : Visiteur Booleen]]></title>
    <link href="http://mcamuzat.github.io/blog/2015/04/06/suite-visiteur-pattern-visiteur-bool%C3%A9en/"/>
    <updated>2015-04-06T19:55:44+02:00</updated>
    <id>http://mcamuzat.github.io/blog/2015/04/06/suite-visiteur-pattern-visiteur-booléen</id>
    <content type="html"><![CDATA[<h2>Introduction:</h2>

<p>Nous allons refaire la même chose que notre interpréteur d&#8217;expressions.
Mais avec des expressions booléennes.
Par exemple
<code>php
$expression = new Or( new And(New False(), New True()), new False);
</code>
Nous allons ensuite rajouter les comparaisons <code>==</code>, <code>&lt;</code>, etc ..
<code>php
$expression = new Not(new NotEqual(new Constant(5), new Variable('i')));
</code></p>

<p>Beaucoup de code. mais si vous avez compris la première partie. cela devrait aller.</p>

<h2>Expression Booléenne</h2>

<p>Nous définissons l&#8217;interface suivante.</p>

<pre><code class="php">/**
 * Une expression Booléenne
 */
interface BoolExpression
{
    public function accept(VisitorBoolExpression $v);
}
/**
 * Une classe abstraite.
 */
abstract class Unary implements BoolExpression
{
    public function accept(VisitorBoolExpression $v)
    {
        return $v-&gt;visit($this);
    }
}
</code></pre>

<p>Pour faire l&#8217;algèbre booléen j&#8217;ai besoin de <code>False</code> et de <code>True</code></p>

<p>Voici le code.</p>

<pre><code class="php">class True extends Unary {}

class False extends Unary {}
</code></pre>

<p>J&#8217;ai aussi besoin de la négation</p>

<pre><code class="php">class Not extends Unary {
    private $value;
    public function __construct(BoolExpression $expr) {
        $this-&gt;value = $expr;
    }
    public function getValue() {
        return $this-&gt;value;
    }
}
</code></pre>

<p>Je vais rajouter la condition And, Or, Nand (No-et), Nor(Non-ou)</p>

<p>Je définis une classe avec deux arguments dans le constructeur.
<code>php
class Binary extends Unary
{
    private $left;
    private $right;
    public function __construct(BoolExpression $left, BoolExpression $right) {
        $this-&gt;left = $left;
        $this-&gt;right = $right;
    }
    public function getLeft() {
        return $this-&gt;left;
    }
    public function getRight() {
        return $this-&gt;left;
    }
}
</code></p>

<p>Les classes sont alors très simples.
<code>php
// Or et And sont des mots réservés en Php.
class BinaryOr extends Binary{}
class BinaryAnd extends Binary{}
class BinaryNand extends Binary{}
class BinaryNor extends Binary{}
</code></p>

<p>J&#8217;ai un peu près tout.</p>

<p>On peut passer au Visiteur.
&#8220;` php
interface VisitorBoolExpression{
    public function visit(BoolExpression $expr);
}</p>

<p>class VisitorBoolEvaluation implements VisitorBoolExpression {
    protected $context;
    function __construct($context){
        $this->context = $context;
    }</p>

<pre><code>public function visit(BoolExpression $expr){
    $class = 'visit'.get_class($expr);
    return $this-&gt;$class($expr);
}
public function visitTrue(BoolExpression $expr)
{
    return true;
}
public function visitFalse(BoolExpression $expr)
{
    return false;
}
public function visitNot(BoolExpression $expr)
{
    return !$expr-&gt;getValue()-&gt;accept($this);
}
public function visitBinaryOr(BoolExpression $expr)
{
    return $expr-&gt;getLeft()-&gt;accept($this)||$expr-&gt;getRight()-&gt;accept($this);
}
public function visitBinaryAnd(BoolExpression $expr)
{
    return $expr-&gt;getLeft()-&gt;accept($this)&amp;&amp;$expr-&gt;getRight()-&gt;accept($this);

}
public function visitBinaryNor(BoolExpression $expr)
{
    return !($expr-&gt;getLeft()-&gt;accept($this)||$expr-&gt;getRight()-&gt;accept($this));

}
public function visitBinaryNand(BoolExpression $expr)
{
    return !($expr-&gt;getLeft()-&gt;accept($this) &amp;&amp; $expr-&gt;getRight()-&gt;accept($this));
}
</code></pre>

<p>}
&#8220;`</p>

<p>Quelques exemples.</p>

<p>On réutilise notre mémoire du billet précédent. On utilise aussi <code>var_dump</code> plutôt que <code>echo</code> car <code>echo false</code> ne renvoie rien.</p>

<pre><code class="php">$memory = new Memory();
$memory-&gt;write('i', 10);

$ve = new VisitorBoolEvaluation($memory);
// une expression
$expression =  new True();
// appelle le visiteur
var_dump($expression-&gt;accept($ve)) // affiche bool(true);
$expression =  new Not(new False());
var_dump($expression-&gt;accept($ve)) // affiche bool(true);
$expression =  new BinaryAnd(new Not(new False()), new BinaryOr(new True(), new False()));
var_dump($expression-&gt;accept($ve)) //Affiche bool(true);
</code></pre>

<p>bien sur on peux refaire un autre visiteur pour traduire en chaînes de caractères
&#8220;` php
class VisitorBoolPrint implements VisitorBoolExpression {
    protected $context;
    function __construct($context){
        $this->context = $context;
    }</p>

<pre><code>public function visit(BoolExpression $expr){
    $class = 'visit'.get_class($expr);
    return $this-&gt;$class($expr);
}
public function visitTrue(BoolExpression $expr)
{
    return "true";
}
public function visitFalse(BoolExpression $expr)
{
    return "false";
}
public function visitNot(BoolExpression $expr)
{
    return "!" . $epr-&gt;getValue()-&gt;accept($this);
}
public function visitBinaryOr(BoolExpression $expr)
{
    return "(" . $expr-&gt;getLeft()-&gt;accept($this)
    .'||' .$expr-&gt;getRight()-&gt;accept($this). ")";
}
...
...
</code></pre>

<p> }
&#8220;`
Le même exemple .</p>

<pre><code class="php">$memory = new Memory();
$memory-&gt;write('i', 10);
$ve = new VisitorBoolPrint($memory);
// une expression
$expression =  new True();
// appelle le visiteur
var_dump($expression-&gt;accept($ve)) // affiche true;
$expression =  new Not(new False());
var_dump($expression-&gt;accept($ve)) // affiche !false;
$expression =  new BinaryAnd(new Not(new False()), new BinaryOr(new True(), new False()));
var_dump($expression-&gt;accept($ve)) //Affiche (!false&amp;&amp;(true||false));
</code></pre>

<h2>Les comparaisons</h2>

<p>Nous pouvons rajouter le <code>==</code>, <code>!=</code>, <code>&gt;</code> , <code>&lt;</code> !</p>

<p>ajoutons de nouveau objet. les object prennent en entrée des expressions mais sortent des boléens.</p>

<pre><code class="php">class BinaryComparaison extends Unary
{
    private $left;
    private $right;
    public function __construct(Expression $left, Expression $right) {
        $this-&gt;left = $left;
        $this-&gt;right = $right;
    }
    public function getLeft() {
        return $this-&gt;left;
    }
    public function getRight() {
        return $this-&gt;right;
    }
}

class Equal extends BinaryComparaison{}
class NotEqual extends BinaryComparaison{}
//Greater Than Equal
class Gte extends BinaryComparaison{}
// Lesser Than Equal
class Lte extends BinaryComparaison{}
// Lesser Than
class Lt extends BinaryComparaison{}
// Greater Than
class Gt extends BinaryComparaison{}
</code></pre>

<p>Pour mon visiteur je vais utiliser mon visiteur d&#8217;expression du post précédent.</p>

<p>donc je modifie le constructeur.
&#8220;` php
    function __construct($context, $ve){
        $this->context = $context;
        $this->ve = $ve;
    }</p>

<pre><code>je ne montre que le égal, mais vous avez un peu près l'idée pour le reste. 
</code></pre>

<pre><code>public function visitEqual(BoolExpression $expr)
{
    return ($expr-&gt;getLeft()-&gt;accept($this-&gt;ve)  == $expr-&gt;getRight()-&gt;accept($this-&gt;ve));
}
</code></pre>

<pre><code>
Le visiteur booléen utilise un autre visiteur pour évaluer une expression. 

Un exemple d'utilisation
</code></pre>

<p>$memory = new Memory();
$memory->write(&lsquo;i&rsquo;, 10);
// une visiteur d&#8217;expression
$ve = new VisitorEvaluation($memory);
// un visiteur pour les expressions booléennes
$vb = new VisitorBoolEvaluation($memory, $ve);
// une expression
$expression =  new Not(new Equal( new Constant(10), new Addition(new Constant(5), new Variable(&lsquo;i&rsquo;))));
var_dump ( $expression->accept($vb) );// affiche bool(true)
&#8220;`</p>

<p>si je reprend mon autre visiteur <code>VisitorToPhp</code> avec le <code>visitorBoolPrint</code></p>

<pre><code class="php">$memory = new Memory();
$memory-&gt;write('i', 10);
$ve = new VisitorToPhp($memory);
$vb = new VisitorBoolPrint($memory, $ve);
// une expression
$expression =  new Not(new Equal( new Constant(10), new Addition(new Constant(5), new Variable('i'))));
var_dump ( $expression-&gt;accept($vb) ); //affiche  "!(10==(5+$i))"
</code></pre>

<h2>Une conclusion.</h2>

<ul>
<li>Dans le premier post : On a vu le visiteur pour évaluer/afficher des expressions.</li>
<li>dans le second post : le visiteur pour les expressions booléennes et les comparaisons. Celui-ci utilise le premier visiteur pour faire les calculs.</li>
</ul>


<p>dans un prochain post, je vais montrer un troisième visiteur <code>visitorInstruction</code> pour évaluer des instructions d&#8217;un langage très simple. Mais cela est un peu long à écrire. Il y a un peu de théorie et des figures à faire.</p>

<p>Merci de m&#8217;avoir lu.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Interpréteur Et Visiteur Pattern]]></title>
    <link href="http://mcamuzat.github.io/blog/2015/04/05/interpreteur-et-visiteur-pattern/"/>
    <updated>2015-04-05T18:16:10+02:00</updated>
    <id>http://mcamuzat.github.io/blog/2015/04/05/interpreteur-et-visiteur-pattern</id>
    <content type="html"><![CDATA[<h1>Introduction</h1>

<p>Nous allons voir ensemble sur une série trois posts</p>

<ul>
<li>le design-pattern interpréteur</li>
<li>les limitations et une solution qui va introduire le visiteur pattern</li>
</ul>


<h1>Mise en place</h1>

<p>Nous allons créer un simple calculatrice.</p>

<p>Nous définissons l&#8217;interface suivante</p>

<pre><code class="php">/**
 * Une expression arithmétique
 */
interface Expression
{
    public function interpret(Context $context = null);
}
</code></pre>

<h2>Evaluer des constantes</h2>

<p>Voici le code pour évaluer des constantes
&#8220;` php
Class Constant implements Expression
{
    private $value;
    public function __construct($value)
    {
        $this->value = $value;
    }</p>

<pre><code>public function interpret(Context $context = null) 
{
    return $this-&gt;value;
}
</code></pre>

<p>}
&#8220;`</p>

<p>Un exemple
<code>
$constante = new Constant(5);
echo $constante-&gt;interpret(); // affiche 5
</code></p>

<p>jusqu&#8217;ici rien de complexe. Si j&#8217;interprète la constante que j&#8217;ai définie à 5, j&#8217;obtiens 5.</p>

<h2>Evaluer des additions</h2>

<p>voici le code pour interpréter les additions</p>

<pre><code>Class Addition Implements Expression
{
    private $left;
    private $right;
    public function __construct(Expression $left, Expression $right) {
        $this-&gt;right = $right;
        $this-&gt;left = $left;
    }
    public function interpret(Context $context = null) {
        return $this-&gt;left-&gt;interpret($context) + $this-&gt;right-&gt;interpret($context);
    }

}
</code></pre>

<p>Un exemple
<code>
$addition = new Addition(new Constant(5), new Constant(6));
echo $constante-&gt;interpret(); // affiche 11
</code>
On utilise la <strong>récursion</strong> pour interpréter la partie droite et gauche</p>

<pre><code>$addition = new Addition(new Addition( new Constant(5), new Constant(6)), new Constante(4));
echo $constante-&gt;interpret(); // affiche 15
</code></pre>

<p>Faire la multiplication, la soustraction, la division ne sont pas plus compliquées. Il suffit de changer le signe dans la fonction interpret()</p>

<pre><code>    // muliplication 
    public function interpret(Context $context = null) {
        return $this-&gt;left-&gt;interpret($context) * $this-&gt;right-&gt;interpret($context);
    }
</code></pre>

<h2>Ajouter d&#8217;autres méthodes</h2>

<p>Ajoutons la methode Abso qui renvoie la valeur absolue, la fonction min qui renvoie le minimum
&#8220;` php
Class Abso Implements Expression
{
    public function __construct($value) {
        $this->value = $value;
    }
    public function interpret(Context $context = null) {
        return abs($this->value->interpret($context));
    }</p>

<p>}</p>

<p>Class Minimum Implements Expression
{
    public function __construct(Expression $left, Expression $right) {
        $this->right = $right;
        $this->left = $left;
    }
    public function interpret(Context $context = null) {
        return min($this->right->interpret($context),$this->left->interpret($context));
    }
}
&#8220;`</p>

<p>un exemple
<code>
$min = new Minimum(new Abso(-10), new Addition(new Constant(24), new Constant(2)));
echo $min-&gt;interpret(); // renvoie 10
</code></p>

<h2>Tout n&#8217;est qu&#8217;une question de contexte</h2>

<p>Nous allons ajouter les variables.</p>

<p>Il nous faut d&#8217;abord implémenter le Context</p>

<p>Voici la définition
&#8220;` php
/<em>*
 * Interface Context
 </em>/
interface Context
{
    // write a value in memory
    public function write($name, $value);
    // get a value from the memory
    public function read($name);
    //return all the value
    public function getAll()
}</p>

<p>/<em>*
 * A Memory
 </em>/
class Memory implements Context
{
    private $memory = array();
    // write a value in memory
    public function write($name, $value)
    {
        $this->memory[$name] = $value;
        return $this;
    }</p>

<pre><code>// get a value from the memory
public function read($name)
{
    return $this-&gt;memory[$name];
}

public function getAll()
{
    return $this-&gt;memory;
}
</code></pre>

<p>}</p>

<pre><code>
Il ne nous reste plus qu'à implémenter la variable.
</code></pre>

<p>class Variable implements Expression
{    public function __construct($name) {
        $this->name = $name;
    }
    public function interpret(Context $context = null){
        return $context->read($this->name);
    }
}</p>

<pre><code>On comprend l'intérêt du context. Il nous permet de passer un pseudo-scope..

Un exemple:
</code></pre>

<p>$memory = new Memory();
$memory->write(&lsquo;i&rsquo;, 10);
$expression = new Addition(new Constant(10), new Variable(&lsquo;i&rsquo;));
echo $expression->interpret($memory); // 20</p>

<p>$memory->write(&lsquo;i&rsquo;, 0);
echo $expression->interpret($memory); // 10
&#8220;`</p>

<p>On peux rajouter plein d&#8217;autre expression. L&#8217;avantage est qu&#8217;il suffit de rajouter une méthode <code>-&gt;interpret(..)</code> pour chaque objet.</p>

<h1>mais si on change le cahier des charges&hellip;</h1>

<p>Changeons le cahier des charges. Je souhaite transformer mon Expression en chaine de caractères. Je peux m&#8217;en sortir en surchargeant la méthode <code>__tostring</code></p>

<p>Par exemple :
<code>php
$expression = new Addition (new Addition(new Constant(3), new Constant(4)), new Constante(4));
$expression-&gt;__toString() // me donne ((3 + 4) + 4);
</code></p>

<pre><code>// pour la constante
        public function __toString() {
            return $this-&gt;value;
        }

// pour l'addition
         public function __toString() {
                // this-&gt;left-&gt;__toString()
                return '(' . $this-&gt;left . ' + ' . $this-&gt;right .')';
         }
</code></pre>

<p>Rechangeons le cahier des charges : je veux la traduction en Php</p>

<pre><code>$expression = new Addition (new Addition(new Variable('i'), new Constant(4)), new Constante(4));
$expression-&gt;__toPhp() // me donne (($i + 4) + 4);
</code></pre>

<p>je suis un peu bloqué, je dois rajouter à chaque fois une méthode dans chaque Object. Je perd un peu de la simplicité du pattern..</p>

<h2>Visiteur Pattern à la rescousse !</h2>

<p>Je vais définir une méthode <code>accept(Visitor $visitor)</code>
&#8220;` php
interface Expression{
     public function accept(VisitorExpression $v);
}</p>

<pre><code>
avec VisitorExpression définit ainsi
</code></pre>

<p>abstract class VisitorExpression{
    public abstract function visite(Expression $expr);
}
&#8220;`</p>

<p>Voici comment se transforme l&#8217;addition, la constante et la variable (je ne mets pas tout..)
&#8220;` php
Class Constant implements Expression
{
    private $value;
    public function __construct($value)
    {
        $this->value = $value;
    }
    public function getValue() {
        return $this->value;
    }
    public function accept(VisitorExpression $v)
    {
        return $v->visit($this);
    }</p>

<p>}</p>

<p>Class Addition Implements Expression
{
    public function __construct(Expression $left, Expression $right) {
        $this->right = $right;
        $this->left = $left;
    }
    public function getLeft() {
        return $this->left;
    }
    public function getRight() {
        return $this->right;
    }
    public function accept(VisitorExpression $v)
    {
        return $v->visit($this);
    }</p>

<p>}</p>

<p>class Variable implements Expression
{
    private $name;
    public function __construct($name) {
        $this->name = $name;
    }
    public function getName() {
        return $this->name;
    }
    public function accept(VisitorExpression $v)
    {
        return $v->visit($this);
    }
}</p>

<pre><code>
Voici l'implémentation de notre Visiteur
</code></pre>

<p>class VisitorEvaluation extends VisitorExpression {
    protected $context;
    function __construct($context){
        $this->context = $context;
    }</p>

<pre><code>public function visit(Expression $expr){
    $class = 'visit'.get_class($expr);
    return $this-&gt;$class($expr);
}
public function visitAddition(Expression $expr)
{
    return $expr-&gt;getLeft()-&gt;accept($this) +
        $expr-&gt;getRight()-&gt;accept($this);

}
public function visitConstant(Expression $expr)
{
    return $expr-&gt;getValue();

}
public function visitVariable(Expression $expr)
{
     return $this-&gt;context-&gt;read($expr-&gt;getName());
}
</code></pre>

<pre><code>en pratique. On appelle la méthode `accept`. Celle-ci appelle la methode `visit($this)`. la méthode visit détermine la fonction à appeller. 
Si c'est une constante alors `visistConstant()` celle-ci résout la valeur. pour une addition c'est un plus compliqué on ré-appelle récursivement `accept` sur chaque partie de l'addition.

Voici comment s'en servir
</code></pre>

<p>// j&#8217;ai besoin d&#8217;une mémoire
$memory = new Memory();
$memory->write(&lsquo;i&rsquo;, 10);
// j&#8217;ai besoin d&#8217;un visiteur
$ve = new VisitorEvaluation($memory);
// une expression
$expression = new Addition(new Constant(10), new Variable(&lsquo;i&rsquo;));
// appelle le visiteur
echo $expression->accept($ve); // 20
&#8220;`</p>

<p>On se rend compte qu&#8217;il n&#8217;y a plus de logique dans mes objet. Tout est sous-traité dans le visiteur.</p>

<p>L&#8217;avantage de cette méthode est qu&#8217;il est très simple de changer le visiteur sans changer la logique.</p>

<p>Par exemple le visiteur qui convertit en php</p>

<pre><code class="php">}
class VisitorToPhp extends VisitorEvaluation {
    public function visitAddition(Expression $expr)
    {
        return '(' .  $expr-&gt;getLeft()-&gt;accept($this) . '+'
            . $expr-&gt;getRight()-&gt;accept($this). ')';

    }
    public function visitVariable(Expression $expr)
    {
         return '$'. $expr-&gt;getName();
    }

    public function convertMemory()
    {
        $output = '';

        foreach($this-&gt;context-&gt;getAll() as $key =&gt; $value) {
            $output .= '$'.$key . ' = ' . $value . ';';
        }
        return $output;
    }

    public function getOutput()
    {
        return 'echo';
    }

    public function translate(Expression $exp) {
        return $this-&gt;convertMemory() . $this-&gt;getOutput() . $exp-&gt;accept($this);
    }
}
</code></pre>

<p>Et celui qui convertit en Javascript !
&#8220;`
class VisitorToJs extends VisitorToPhp {
    public function visitVariable(Expression $expr)
    {
         return $expr->getName();
    }</p>

<pre><code>public function convertMemory()
{
    $output = '';
    foreach($this-&gt;context-&gt;getAll() as $key =&gt; $value) {
        $output .= 'var '. $key . ' = ' . $value . ';';
    }
    return $output;
}
public function getOutput()
{
    return 'console.log';
}
</code></pre>

<p>}</p>

<pre><code></code></pre>

<p>$memory = new Memory();
$memory->write(&lsquo;i&rsquo;, 10);
$ve = new VisitorEvaluation($memory);
// une expression
$expression = new Addition(new Constant(10), new Variable(&lsquo;i&rsquo;));
// appelle le visiteur evaluation simple
echo $expression->accept($ve); // 20
// evaluation conversion php
$php = new VisitorToPhp($memory);
echo $expression->accept($php); // (10 + $i)
$js = new VisitorToJs($memory);
echo $expression->accept($js); // (10 + i)
// j&#8217;ai rajouté une méthode translate qui est un raccourci
echo $php->translate($expression); // $i = 10;echo(10+$i)
echo $js->translate($expression); // var i = 10;console.log(10+i)
&#8220;`</p>

<p>Les limitations du visiteur pattern</p>

<ul>
<li>toute la logique est sur le visiteur. s&#8217;il y a un beaucoup de type d&#8217;expression (dans notre cas Addition, Constant, Variable, Abso, Multiplication ..) c&#8217;est autant de ligne à rajouter dans celui-ci.</li>
<li>rajouter un <em>type</em>, oblige à le ré-implementer partout.</li>
</ul>


<p>Les avantages du visiteur pattern.
On peut parfaitement imaginer un type document, et lui ajouter un visiteur <code>toJson</code>, <code>toPdf</code>, <code>toEbook</code>, <code>toHtml</code>. sans jamais changer le modèle.</p>

<p>Nous continuerons avec le visiteur pattern dans un prochain post. Nous ajouterons un visiteur pour les expressions booléenes. puis nous ajouterons un visiteur pour des instructions. nous allons créer un mini-langage..</p>

<p>Ce projet vient des notes que j&#8217;avais prise quand j&#8217;étais au CNAM sur le cours de Design-Pattern en Java. J&#8217;avais adoré!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[FizzBuzz Sans Boucle If]]></title>
    <link href="http://mcamuzat.github.io/blog/2015/03/22/fizzbuzz-sans-boucle-if/"/>
    <updated>2015-03-22T23:19:46+01:00</updated>
    <id>http://mcamuzat.github.io/blog/2015/03/22/fizzbuzz-sans-boucle-if</id>
    <content type="html"><![CDATA[<p>Bon, j&#8217;ai passé deux-trois entretiens ou on m&#8217;a demandé d&#8217;implémenter &ldquo;fizzbuz&rdquo;</p>

<p>Les règles sont simples.</p>

<ul>
<li>Écrire un programme qui écrit les nombres de 1 à 100.</li>
<li>Si le chiffre est divisible par 3 afficher seulement &ldquo;fizz&rdquo;</li>
<li>Si le chiffre est divisible par 5 afficher seulement &ldquo;buzz&rdquo;</li>
<li>Si divisible par 3 et 5 afficher &ldquo;fizzbuzz&rdquo;</li>
<li>sinon afficher le chiffre tout seul</li>
</ul>


<p>Il y a plein de solutions possibles</p>

<h2>la plus littérale</h2>

<pre><code class="php">for ($i = 1; $i &lt;= 100; $i++) {
    if ($i % 15 == 0) {
        echo 'fizzbuzz'. "\n";
    } elseif ($i % 3 == 0) {
        echo 'buzz'. "\n";
    } elseif ($i % 5 == 0) {
        echo 'fizz'. "\n";
    } else {
    echo $i ."\n";
    }
}
</code></pre>

<h2>la version de wikipedia</h2>

<pre><code class="php">for ($i = 1; $i &lt;= 100; $i++) {
    $output = '';
    if ( $i%3 == 0) {
        $output .= 'fizz';
    }
    if ( $i%5 == 0) {
        $output .= 'buzz';
    }

    if ($output == '') {
        $output .= $i;
    }
    echo $output. "\n";
}
</code></pre>

<h2>Ma version que j&#8217;avais programmé</h2>

<p>Le <code>continue</code> n&#8217;est pas souvent utilisé. Mais je trouve qu&#8217;il remplit son rôle ici.</p>

<pre><code class="php">for ($i = 1; $i &lt;= 100; $i++) {
    if ($i % 15 == 0) {
        echo 'fizzbuzz'. "\n";
        continue;
    }
    if ($i % 3 == 0) {
        echo 'buzz'. "\n";
        continue;
    }
    if ($i % 5 == 0) {
        echo 'fizz'. "\n";
        continue;
    }
    echo $i ."\n";

}
</code></pre>

<h2>Sans boucle if</h2>

<p>Il existe une version qui n&#8217;utilise aucune boucle if.
&#8220;`php
$resp = array(
    &lsquo;fizzbuzz&rsquo;,
    false,
    false,
    &lsquo;fizz&rsquo;,
    false,
    &lsquo;buzz&rsquo;,
    &lsquo;fizz&rsquo;,
    false,
    false,
    &lsquo;fizz&rsquo;,
    false,
    false,
    &lsquo;fizz&rsquo;,
    false,
    false
);</p>

<p>for ($i = 1; $i &lt;= 100; $i++) {
    ($output = $resp[$i%15]) || ($output = $i);
    echo $output. &ldquo;\n&rdquo;;
}</p>

<pre><code>
En php on ne peux pas faire la commande suivante qui correcte en javascript;
</code></pre>

<p>var a = value || defautvalue ;
&#8220;`</p>

<pre><code>$output = $resp[i%15] || $i// =&gt; $output = true
</code></pre>

<p>C&#8217;est pour cela que l&#8217;on utilise cette ligne un peu bancale.
<code>
($output = $resp[$i%15]) || ($output = $i);
</code>
Il n&#8217;y a pas de boucle if. Si un jour on vous demande d&#8217;implémenter FizzBuzzb en essayer cette version.</p>
]]></content>
  </entry>
  
</feed>
