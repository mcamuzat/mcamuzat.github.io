<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Php | Mon blog perso.]]></title>
  <link href="http://mcamuzat.github.io/blog/categories/php/atom.xml" rel="self"/>
  <link href="http://mcamuzat.github.io/"/>
  <updated>2015-09-27T17:16:32+02:00</updated>
  <id>http://mcamuzat.github.io/</id>
  <author>
    <name><![CDATA[mcamuzat]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Guzzle Asynchrone Avec Les Promises]]></title>
    <link href="http://mcamuzat.github.io/blog/2015/09/21/guzzle-asynchrone-avec-les-promises/"/>
    <updated>2015-09-21T21:39:06+02:00</updated>
    <id>http://mcamuzat.github.io/blog/2015/09/21/guzzle-asynchrone-avec-les-promises</id>
    <content type="html"><![CDATA[<p>Nous continuons sur les promises et le yield.</p>

<ul>
<li><a href="/blog/2015/09/05/les-promises-et-php-via-react/">partie 1 les promises</a></li>
<li><a href="/blog/2015/09/06/php-yield-les-generateurs/">partie 2 le Yield</a></li>
<li><a href="/blog/2015/09/13/yield-php-co-routine/">partie 3 les co-routines</a></li>
</ul>


<p>Je vais parler de <a href="https://github.com/guzzle">Guzzle</a> qui est un client HTTP. Nous allons voir la version 6 qui utilise Php5.5</p>

<h2>Promise et Guzzle.</h2>

<p><em>Guzzle</em> connait les promises et possède sa propre <a href="https://github.com/guzzle/promises">implémentation</a>.</p>

<p>la signature de la fonction est un peu près la même que <a href="https://github.com/reactphp/promise">react/promise</a>.</p>

<p>Attention <em>Guzzle</em> ne fait pas la différence entre le <em>Deferred</em> qui est un travail dont la réponse est encore inconnu et représenter par une <em>promise</em>. Dans <em>Guzzle</em> le travail et la réponse sont la même chose.</p>

<pre><code class="php">use GuzzleHttp\Promise\Promise;

$promise = new Promise();
$promise-&gt;then(
    // $onFulfilled
    function ($value) {
        echo 'Tout va bien.';
    },
    // $onRejected
    function ($reason) {
        echo 'On a un problème.';
    }
);

$promise-&gt;resolve(null); // 'Tout va bien.';
// Ou 
$promise-&gt;reject(null); // 'On a un problème.';
</code></pre>

<p><em>Guzzle</em> est un client Web essayons un cas concret.</p>

<pre><code class="php">$client = new GuzzleHttp\Client();

$promise = $client-&gt;requestAsync('GET', 'http://httpbin.org/get');
$promise-&gt;then(
    function ($res) {
        return $res-&gt;getStatusCode();
    }
)-&gt;then(function ($value) { echo "j'ai recu un code $value"} ;

// Notre requète n'est pas encore partie. Il faut lancer manuellement l'appel.
$client-&gt;wait();
</code></pre>

<p>L&#8217;avantage ici est que je décide quand je lance l&#8217;appel. Par exemple on peut lancer en parallèle les requêtes.</p>

<pre><code class="php">$client = new Client(['base_uri' =&gt; 'http://httpbin.org/']);

// Je crée toute mes requetes
$promises = [
    'image' =&gt; $client-&gt;getAsync('/image'),
    'png'   =&gt; $client-&gt;getAsync('/image/png'),
    'jpeg'  =&gt; $client-&gt;getAsync('/image/jpeg'),
    'webp'  =&gt; $client-&gt;getAsync('/image/webp')
];

// je resouds tout en même temps

$results = Promise\unwrap($promises);
</code></pre>

<p>On peux créer des pools. Si on souhaite limiter le nombre de requête en même temps.</p>

<pre><code class="php">$client = new Client(['base_uri' =&gt; 'http://httpbin.org/']);

$batch = [
    'image' =&gt; '/image',
    'png'   =&gt; '/image/png',
    'jpeg'  =&gt; '/image/jpeg',
    'webp'  =&gt; '/image/webp'
];

$requests = function ($batch) {
    foreach ($batch as $url) {
        yield new Request('GET', $url);
    }
};

$pool = new Pool($client, $requests($batch), [
    'fulfilled' =&gt; function ($response, $index) {
        var_dump($index);
    },
    'concurrency =&gt; 2,
]);
$promise = $pool-&gt;promise();
$promise-&gt;wait();
</code></pre>

<p>le résultat ici.</p>

<pre><code class="php">int(3)
int(0)
int(1)
int(2)
</code></pre>

<p>On reconnait aussi notre nouvel ami le <code>yield</code>.</p>

<h2>Le premier arrivé</h2>

<p>Nous allons utiliser l&#8217;instruction <code>any()</code> toutes les requêtes sont lancées en concurrences. C&#8217;est la première arrivée qui l&#8217;emporte.</p>

<pre><code>$client = new Client(['base_uri' =&gt; 'http://httpbin.org/']);

// je crée toute mes requetes
$promises = [
    'image' =&gt; $client-&gt;getAsync('/image'),
    'png'   =&gt; $client-&gt;getAsync('/image/png'),
    'jpeg'  =&gt; $client-&gt;getAsync('/image/jpeg'),
    'webp'  =&gt; $client-&gt;getAsync('/image/webp')
];

$result = Promise\any($promises)-&gt;then(function($value){var_dump($value-&gt;getHeader('Content-Type'));});
$result-&gt;wait();
</code></pre>

<p>Je veux juste les deux premières réponses <code>some(2, $promise)</code></p>

<pre><code class="php">$client = new Client(['base_uri' =&gt; 'http://httpbin.org/']);

// je crée toute mes requetes
$promises = [
    'image' =&gt; $client-&gt;getAsync('/image'),
    'png'   =&gt; $client-&gt;getAsync('/image/png'),
    'jpeg'  =&gt; $client-&gt;getAsync('/image/jpeg'),
    'webp'  =&gt; $client-&gt;getAsync('/image/webp')
];

$result = Promise\some(2, $promises)
    -&gt;then(function($results)
    {foreach ($results as $value)
        var_dump($value-&gt;getHeader('Content-Type'));
    }
);
$result-&gt;wait();
</code></pre>

<h2>Yield + Promise == Coroutine promise</h2>

<p>Bon Nous allons complexifier encore un peu.</p>

<p>Soit le code suivant</p>

<pre><code class="php">$client = new Client(['base_uri' =&gt; 'http://httpbin.org/']);

$promiseGenerator = function () use ($client) {
    yield $client-&gt;getAsync('/image');
    yield $client-&gt;getAsync('/image/png');
    yield $client-&gt;getAsync('/image/jpeg');
    yield $client-&gt;getAsync('/image/webp');
};

$result = array();
$promise = Promise\each_limit($promiseGenerator(), 2, function($value, $idx) use (&amp;$result) {$result[$idx] = $value;});

$promise-&gt;wait();
</code></pre>

<p>Je mets à la suite toute les promises que je souhaite exécuter en ajoutant <code>yield</code> devant.</p>

<p>Je laisse Guzzle gérer avec un limitation de 2. des que le programme a une place de libre, il appelle le générateur pour avoir un nouvelle promise.</p>

<p>Mais il existe dans Guzzle des co-routines..</p>

<pre><code class="php">$client = new Client(['base_uri' =&gt; 'http://httpbin.org/']);

$myfunction = function ($url) use ($client) {
    return Promise\coroutine(
        function () use ($client, $url) {
            try {
                $value = (yield $client-&gt;getAsync($url));
            } catch (\Exception $e) {
                yield New RejectedPromise($e-&gt;getMessage());
            }
        }
    );
};

$images = ['foo', 'baz', 'bar'];
$promises = [];

// Build an array of promises.
foreach ($images as $image) {
    $promises[] = $myfunction($image);
}

$aggregate = Promise\all($promises)-&gt;then(
    function($values) {echo 'ok' ;}, function($values){echo 'nope';});

$aggregate-&gt;wait();
</code></pre>

<p>Le code est complètement asynchrone.</p>

<p>Il est intéressant de voir le code synchrone et non parallèle.</p>

<pre><code class="php">$client = new Client(['base_uri' =&gt; 'http://httpbin.org/']);

$getImages = function ($url) use ($client) {
            try {
                return $value = $client-&gt;get($url);
            } catch (\Exception $e) {
                $value = $e-&gt;getMessage();
            }
        };

$images = ['foo', 'baz', 'bar'];
$promises = [];

// Build an array of promises.
foreach ($images as $image) {
    $result[] = $getImages($image);
}
</code></pre>

<p>En gros, j&#8217;ai retiré le <code>async</code> et les <code>yields</code> mais les deux codes se ressemblent non ?</p>

<h2>Conclusion</h2>

<p>Les promises sont pratiques.</p>

<ul>
<li>elles sont chainables</li>
<li>elles sont asynchrones, annulables, rejetables</li>
<li>On peut faire des foreach dessus.</li>
<li>On peut les combiner.</li>
</ul>


<p>Ce n&#8217;est pas vraiment un hasard. Les promises sont des <strong>Monades</strong>. Il n&#8217;est pas simple d&#8217;expliquer les monades. Les monades viennent de la programmation fonctionnelle et c&#8217;est surtout <a href="https://www.haskell.org/">haskell</a> qui a popularisé cette structure. J&#8217;espère que je reviendrai dessus.</p>

<p><em>Guzzle</em> est vraiment très sympathique à utiliser. Le coté asynchrone n&#8217;est pas simple, la fonction <code>co-routine</code> n&#8217;est pas dans la documentation. Il a été très difficile de trouver un code d&#8217;exemple. Je regrette que parfois le seul moyen de déclencher la résolution est d&#8217;appeler de manière synchrone <code>-&gt;wait()</code> ce qui est dommage.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Yield PHP Co-routine]]></title>
    <link href="http://mcamuzat.github.io/blog/2015/09/13/yield-php-co-routine/"/>
    <updated>2015-09-13T20:31:37+02:00</updated>
    <id>http://mcamuzat.github.io/blog/2015/09/13/yield-php-co-routine</id>
    <content type="html"><![CDATA[<p>Nous allons continuer sur le <em>yield</em> <a href="/blog/2015/09/06/php-yield-les-generateurs/">partie1</a></p>

<p>Nous avons vu la fonction xrange qui permet de générer un million de valeurs pour un coup très faible en mémoire.</p>

<p>Mais il y a mieux ! On peux envoyer des valeurs dans le générateur
<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='php'><span class='line'><span class="o">&amp;</span><span class="nx">lt</span><span class="p">;</span><span class="o">?</span><span class="nx">php</span>
</span><span class='line'><span class="k">function</span> <span class="nf">generateAnimal</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="nv">$input</span> <span class="o">=</span> <span class="p">(</span><span class="k">yield</span> <span class="o">&amp;</span><span class="nx">lsquo</span><span class="p">;</span><span class="nx">Panda</span><span class="o">&amp;</span><span class="nx">rsquo</span><span class="p">;);</span>
</span><span class='line'>    <span class="nb">var_dump</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">ldquo</span><span class="p">;</span><span class="nx">j</span><span class="s1">&#39;ai reçu $input&amp;rdquo;);</span>
</span><span class='line'><span class="s1">    $input = (yield &amp;lsquo;Lama&amp;rsquo;);</span>
</span><span class='line'><span class="s1">    var_dump(&amp;ldquo;j&#39;</span><span class="nx">ai</span> <span class="nx">reçu</span> <span class="nv">$input</span><span class="o">&amp;</span><span class="nx">rdquo</span><span class="p">;);</span>
</span><span class='line'><span class="p">}</span><span class="o">&lt;/</span><span class="nx">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="nx">p</span><span class="o">&gt;</span><span class="nv">$gen</span> <span class="o">=</span> <span class="nx">generateAnimal</span><span class="p">();</span>
</span><span class='line'><span class="nb">var_dump</span><span class="p">(</span><span class="nv">$gen</span><span class="o">-&gt;</span><span class="na">current</span><span class="p">());</span><span class="c1">// string(5) &amp;ldquo;Panda&amp;rdquo;</span>
</span><span class='line'><span class="nb">var_dump</span><span class="p">(</span><span class="nv">$gen</span><span class="o">-&gt;</span><span class="na">send</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">lsquo</span><span class="p">;</span><span class="nx">Canard</span><span class="o">&amp;</span><span class="nx">rsquo</span><span class="p">;));</span><span class="c1">//string(16) &amp;ldquo;j&#39;ai recu Canard&amp;rdquo;</span>
</span><span class='line'>                               <span class="c1">//string(4) &amp;ldquo;Lama&amp;rdquo;</span>
</span><span class='line'><span class="nb">var_dump</span><span class="p">(</span><span class="nv">$gen</span><span class="o">-&gt;</span><span class="na">send</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">lsquo</span><span class="p">;</span><span class="nx">Poney</span><span class="o">&amp;</span><span class="nx">rsquo</span><span class="p">;));</span> <span class="c1">// j&#39;ai recus Poney.</span>
</span></code></pre></td></tr></table></div></figure></p>

<p>Si j&#8217;avais fais deux fois <code>-&gt;next()</code>  au lieux de <code>-&gt;send()</code></p>

<pre><code class="php">$gen = generateAnimal();
var_dump($gen-&gt;current());// string(5) "Panda"
var_dump($gen-&gt;next());//string(16) "j'ai recu NULL"
                               //string(4) "Lama"
var_dump($gen-&gt;next()); // j'ai recus NULL.
</code></pre>

<h2>Les Co-routines</h2>

<p>Une co-routine est une fonction qui peut se suspendre en reprendre quand on le souhaite.</p>

<p>Nous allons faire une classe <code>Task</code>  pour mieux comprendre.</p>

<pre><code class="php">class Task
{
    protected $generator;

    protected $firstCall = true;

    public function __construct(Generator $generator)
    {
        $this-&gt;generator = $generator;
    }

    public function run()
    {
        if ($this-&gt;firstCall) {
            $this-&gt;generator-&gt;current();
        } else {
            $this-&gt;generator-&gt;next();
        }

        $this-&gt;firstCall = false;
    }

    public function finished()
    {
        return !$this-&gt;generator-&gt;valid();
    }
}
</code></pre>

<p>J&#8217;ai besoin d&#8217;un Runner</p>

<pre><code class="php">
class Runner
{
    public function __construct(Task $task)
    {
        $this-&gt;task = $task;
    }

    public function run()
    {
        while (!$this-&gt;task-&gt;finished()) {
            $this-&gt;task-&gt;run();
        }
    }
}
</code></pre>

<p>Un petit code d&#8217;exemple</p>

<pre><code>function task1() {
    for ($i = 1; $i &lt;= 10; ++$i) {
        echo "This is task 1 iteration $i.\n";
        yield;
    }
}

$task = new Task(task1());
$runner = new Runner($task);
$runner-&gt;run();
</code></pre>

<p>Cela donne</p>

<pre><code>This is task 1 iteration 1.
This is task 1 iteration 2.
This is task 1 iteration 3.
This is task 1 iteration 4.
This is task 1 iteration 5.
This is task 1 iteration 6.
This is task 1 iteration 7.
This is task 1 iteration 8.
This is task 1 iteration 9.
This is task 1 iteration 10.
</code></pre>

<p>J&#8217;ai un objet Task qui appelle une fonction et qui rend la main à chaque itération. Cela semble compliqué pour une seule tache. Mais modifions le code pour avoir plusieurs taches.</p>

<pre><code>class Scheduler
{
    protected $queue;

    public function __construct()
    {
        $this-&gt;queue = new SplQueue();
    }

    public function enqueue(Task $task)
    {
        $this-&gt;queue-&gt;enqueue($task);
    }

    public function run()
    {
        while (!$this-&gt;queue-&gt;isEmpty()) {
            $task = $this-&gt;queue-&gt;dequeue();
            $task-&gt;run();

            if (!$task-&gt;finished()) {
                $this-&gt;enqueue($task);
            }
        }
    }
}
</code></pre>

<p>Bon toute la magie est faite grâce à la <code>SplQueue</code> qui est une file d&#8217;attente. J&#8217;ajoute dans la file d&#8217;attente toutes les taches.</p>

<p>Je prend une tache de la file d&#8217;attente. Je l&#8217;exécute avec <code>-&gt;run()</code>, si la tache n&#8217;est pas finie, je la remets dans la file d&#8217;attente.</p>

<p>Reprenons un code d&#8217;exemple</p>

<pre><code class="php">function task1() {
    for ($i = 1; $i &lt;= 10; ++$i) {
        echo "This is task 1 iteration $i.\n";
        yield;
    }
}

function task2() {
    for ($i = 1; $i &lt;= 5; ++$i) {
        echo "This is task 2 iteration $i.\n";
        yield;
    }
}

$task1 =  new Task(task1());
$task2 = new Task(task2());
$scheduler = new Scheduler();
$scheduler-&gt;enqueue($task1);
$scheduler-&gt;enqueue($task2);
$scheduler-&gt;run();
</code></pre>

<p>Le résultat.</p>

<pre><code>This is task 1 iteration 1.
This is task 2 iteration 1.
This is task 1 iteration 2.
This is task 2 iteration 2.
This is task 1 iteration 3.
This is task 2 iteration 3.
This is task 1 iteration 4.
This is task 2 iteration 4.
This is task 1 iteration 5.
This is task 2 iteration 5.
This is task 1 iteration 6.
This is task 1 iteration 7.
This is task 1 iteration 8.
This is task 1 iteration 9.
This is task 1 iteration 10.
</code></pre>

<p>On voit que j&#8217;exécute en parallèle toutes mes deux taches.</p>

<h2>En conclusion</h2>

<p>Il existe deux librairies qui utilise ce concept</p>

<ul>
<li><a href="https://github.com/icicleio/icicle">Icicle</a></li>
<li><a href="https://github.com/recoilphp/recoil">recoil</a></li>
</ul>


<p>Cette façon d&#8217;implémenter est assez curieuse. Car le code ne ressemble pas au code classique asynchrone avec des callbacks et autre événements. Si on regarde bien cela ressemble beaucoup a du code synchrone. Elle est inspirée du <code>C#</code> <code>async/wait</code>. On a l&#8217;impression que cela ressemble a du code synchrone où on ajoute des <code>yield</code> un peu partout. (en simplifiant beaucoup..)</p>

<p>Il y a peu de documentation et d&#8217;exemple sur le sujet.</p>

<ul>
<li>la référence est ce post de <a href="http://nikic.github.io">Nikic</a>: <a href="https://nikic.github.io/2012/12/22/Cooperative-multitasking-using-coroutines-in-PHP.html">Cooperative multitasking using coroutines (in PHP!)</a></li>
<li>Une version légèrement simplifié dont je me suis inspiré pour le code <a href="https://medium.com/@assertchris/co-operative-php-multitasking-ce4ef52858a0">Co-operative PHP Multitasking</a></li>
</ul>


<p>Je vais essayer de continuer avec le yield et repartir sur les promises.</p>

<p>Merci de m&#8217;avoir lu.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Problème Np-Complet]]></title>
    <link href="http://mcamuzat.github.io/blog/2015/09/09/probleme-np-complet/"/>
    <updated>2015-09-09T21:55:10+02:00</updated>
    <id>http://mcamuzat.github.io/blog/2015/09/09/probleme-np-complet</id>
    <content type="html"><![CDATA[<p>Aujourd&#8217;hui je vais parler des problèmes Np-complets avec le <a href="http://xkcd.com/">xkcd</a> suivant. L&#8217;original est <a href="http://xkcd.com/287/">ici</a></p>

<p><img class="center" src="/images/np_complete.png" width="600" height="388" title="&lsquo;xkcd&rsquo; &lsquo;xkcd&rsquo;" ></p>

<p>On appelle ce genre de problème les NP-complets</p>

<p>Pour faire simple (Ce que j&#8217;en ai compris)</p>

<p>Les NP-problèmes sont des problèmes donc il est très facile de vérifier une solutions. Dans notre cas ici il suffit de commander 7 * 2.15 pour obtenir 15.05. Le problème a une solution. Mais il est quasiment impossible de trouver une méthode efficace pour déterminer la solution, voir même de savoir s&#8217;il y a une solutions.</p>

<p>Il suffit de regarder les images suivantes (pris d&#8217;un post de <a href="http://cstheory.stackexchange.com/questions/5188/explain-p-np-problem-to-10-year-old">stack exchange</a>)</p>

<ul>
<li>si on met les paquets les plus gros d&#8217;abord, les plus larges, avec un <a href="http://www.optaplanner.org/">planner</a>.</li>
</ul>


<p><img class="center" src="/images/backpack.png" width="600" height="450" title="&lsquo;bin packing&rsquo; &lsquo;slide1&rsquo;" ></p>

<ul>
<li><p>A quel moment mettre le paquet <code>2 * 4 = 8</code>. suivant la forme la solution varie
<img class="center" src="/images/backpack2.png" width="600" height="450" title="&lsquo;bin packing&rsquo; &lsquo;slide2&rsquo;" ></p></li>
<li><p>Enfin impossible de savoir s&#8217;il y a une solution ici. Il y a priori la place, pourtant il n&#8217;y a pas de solution</p></li>
</ul>


<p><img class="center" src="/images/backpack3.png" width="600" height="450" title="&lsquo;bin packing&rsquo; &lsquo;slide3&rsquo;" ></p>

<p>la source des images <a href="http://cstheory.stackexchange.com/posts/5206/revisions">ici</a>.</p>

<p>Il reste la force brute.</p>

<p>Voici ma version du xkcd en php</p>

<pre><code class="php">function findSolution($total, $list, $menu) {
    foreach($menu as $plat =&gt; $prix) {
        $result = array_merge($list, array($plat));
        if ($total-$prix == 0) {
            var_dump($result);
            return;
        }
        if ($total-$prix &gt; 0) {
            $result = findSolution($total-$prix, $result, $menu);
        }
    }
}
$menu = array(
    "Mixed Fruit"=&gt;215,
    "French Fries"=&gt;275,
    "Side Salad"=&gt;335,
    "Hot Wing"=&gt;355,
    "Mozzarela Sticks"=&gt;420,
    "Sampler Plate"=&gt;580,
);
findSolution(1505, array(), $menu);
</code></pre>

<p>Cela affiche toute les solutions possibles.</p>

<p>Bien sur il y a des doublons. Il n&#8217;y a pas de différence entre <code>["Hot wing", "Hot wing", "Mixed Fruit", "Sampler Plate"]</code> et  <code>["Hot wing", "Hot wing", "Sampler Plate", "Mixed Fruit"]</code></p>

<p>Pour supprimer les doublons à l&#8217;affichage. Je vais utiliser des globales.</p>

<pre><code>$count = 0;
$allResult = array();
function findSolution($total, $list, $menu) {
    global $count;
    global $allResult;
    foreach($menu as $plat =&gt; $prix) {
        $count++;
        $result = array_merge($list, array($plat));

        if ($total-$prix == 0) {
            $sort = $result;
            sort($sort);
            $allResult[] = $sort;
            return $result;
        }
        if ($total-$prix &gt; 0) {
            $result = findSolution($total-$prix,$result, $menu);

        }
    }
}
$menu = array(
    "Mixed Fruit"=&gt;215,
    "French Fries"=&gt;275,
    "Side Salad"=&gt;335,
    "Hot Wing"=&gt;355,
    "Mozzarela Sticks"=&gt;420,
    "Sampler Plate"=&gt;580
);
$solution = findSolution(1505, array(), $menu);

$result = array_map(
    "unserialize",
    array_unique(
        array_map("serialize", $allResult
    )
)
);
var_dump($result);
var_dump($count);
</code></pre>

<ul>
<li>je trie le tableau de résultats. pour que tout mes doublons s&#8217;affiche pareil.</li>
<li><code>array_unique</code> ne marche pas si les valeurs sont des <em>tableaux</em> (ce qui est la cas ici)</li>
<li>Je transforme mes tableaux en chaine de caractères grâce à la serialization avec le <code>array_map</code></li>
<li>Alors <code>array_unique</code> vire les doublons</li>
<li>Je deserialize avec à nouveau <code>array_map</code> et l&#8217;opération inverse.</li>
</ul>


<pre><code class="php">array([resultat1], [resultat1],[resultat2])
// array_map("serialize", $result);
array("resultat1_serialisé","resultat1_serialisé","resultat2_serialisé");
// array_unique(..)
array("resultat1_serialise", "resultat2_serialise");
// array_map("unserialize", ..)
array([resultat1], [resultat2])
</code></pre>

<pre><code class="php">int(12040)
array(2) {
  [0] =&gt;
  array(7) {
    [0] =&gt;
    string(11) "Mixed Fruit"
    [1] =&gt;
    string(11) "Mixed Fruit"
    [2] =&gt;
    string(11) "Mixed Fruit"
    [3] =&gt;
    string(11) "Mixed Fruit"
    [4] =&gt;
    string(11) "Mixed Fruit"
    [5] =&gt;
    string(11) "Mixed Fruit"
    [6] =&gt;
    string(11) "Mixed Fruit"
  }
  [1] =&gt;
  array(4) {
    [0] =&gt;
    string(8) "Hot Wing"
    [1] =&gt;
    string(8) "Hot Wing"
    [2] =&gt;
    string(11) "Mixed Fruit"
    [3] =&gt;
    string(13) "Sampler Plate"
  }
}
</code></pre>

<p>J&#8217;ai fait 12040 boucles pour obtenir toutes les solutions. On peut bien sur optimiser un peu l&#8217;algorithme, si la valeur 5.60 ne marche pas à la première boucle, il y a pas de chance pour quelle marche à la seconde boucle. Donc il faut supprimer des valeurs dans le tableau au fur et à mesure.</p>

<h2> Conclusion</h2>

<p>La force brute n&#8217;est pas vraiment une solution, avec plus de valeurs on explose les possibilités.  Il existe plusieurs <a href="https://fr.wikipedia.org/wiki/Probl%C3%A8me_du_sac_%C3%A0_dos">approches</a> qui tende vers des solutions.</p>

<p>En informatique, il y a des nombreux cas où ce problème intervient</p>

<ul>
<li>L&#8217;ordre optimal d&#8217;installation des logiciels (Probablement la partie la plus marrante de <a href="https://getcomposer.org/">composer</a>, mais elle est assez peu documentée)</li>
<li>Beaucoup de cryptages utilisent des problèmes NP-complets (factorisation de deux nombres premiers).</li>
<li>La dernière phrase du comics parle du <a href="https://fr.wikipedia.org/wiki/Probl%C3%A8me_du_voyageur_de_commerce">voyageur de commerce</a>, un problème célèbre.</li>
<li>Le sudoku, Les jeux <a href="http://arxiv.org/pdf/1203.1895v1.pdf">nintendos</a> ?!</li>
<li>Enfin une <a href="https://fr.wikipedia.org/wiki/Liste_de_probl%C3%A8mes_NP-complets">liste complète</a> de wikipedia</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PHP Yield Les Générateurs]]></title>
    <link href="http://mcamuzat.github.io/blog/2015/09/06/php-yield-les-generateurs/"/>
    <updated>2015-09-06T19:06:48+02:00</updated>
    <id>http://mcamuzat.github.io/blog/2015/09/06/php-yield-les-generateurs</id>
    <content type="html"><![CDATA[<p>Nous allons voir une nouveauté de PHP 5.5 l&#8217;instruction <strong>yield</strong></p>

<p>Cela permet de mettre en place ce qu&#8217;on appelle les générateurs.</p>

<h2>Un premier exemple</h2>

<p>Regardons un exemple ensemble</p>

<pre><code class="php">&lt;?php
function generateAnimal() {
    echo "Je suis dans le générateur\n";
    yield "Panda";
    echo "Je suis retourné dans le générateur\n";
    yield "Lama";
    echo "je suis de retour\n";
    yield "Alpaga";
    echo "plus de d'animaux\n";
}

$generator = generateAnimal();
foreach ($generator as $value) {
    echo "j'ai reçu $value \n";
}
</code></pre>

<p>Voici le résultat</p>

<pre><code>j'ai reçu Panda 
Je suis retourné dans le générateur
j'ai reçu Lama 
je suis de retour
j'ai reçu Alpaga 
plus de d'animaux
</code></pre>

<p>D&#8217;abord un générateur se comporte comme un iterator. C&#8217;est grâce à cela que je peux faire un <code>foreach</code>.</p>

<p>Je vais refaire pas à pas avec des commentaires.</p>

<h3>premier passage</h3>

<pre><code class="php">&lt;?php
function generateAnimal() {
    echo "Je suis dans le générateur\n";
    yield "Panda"; // Je retourne ici 
        echo "Je suis retourné dans le générateur\n";
    yield "Lama";
        echo "je suis de retour\n";
    yield "Alpaga";
    echo "plus de d'animaux\n";
}


$generator = generateAnimal();

echo $generator-&gt;current();
// "je suis dans le générateur
// $value = "Panda"
</code></pre>

<h3>Itération suivante</h3>

<p>En fait le générateur reste en suspens, <code>yield</code> est un pseudo <code>return</code> (enfin c&#8217;est comme cela que je l&#8217;ai compris)</p>

<pre><code class="php">&lt;?php
function generateAnimal() {
    echo "Je suis dans le générateur\n";
    yield "Panda"; // Je suis reste ici .. je continue 
    echo "Je suis retourné dans le générateur\n";
    yield "Lama"; // je m'arrete à nouveau 
    echo "je suis de retour\n";
    yield "Alpaga";
    echo "plus d'animaux\n";
}


$generator-&gt;next() // On récupère la valeur suivante
echo $generator-&gt;current();
// "je suis retourné dans le générateur
// "Lama"
</code></pre>

<h3>Troisième itération</h3>

<pre><code class="php">&lt;?php
function generateAnimal() {
    echo "Je suis dans le générateur\n";
    yield "Panda";
    echo "Je suis retourné dans le générateur\n";
    yield "Lama"; // je me suis arrété ici 
    echo "je suis de retour\n";
    yield "Alpaga"; // je retourne .. 
    echo "plus d'animaux\n";
}


$generator-&gt;next() // On récupère la valeur suivante
echo $generator-&gt;current();
// Je suis de retour
// "Alpaga"
</code></pre>

<h3>Dernière Itération</h3>

<p>Nous y sommes presque..</p>

<pre><code class="php">&lt;?php
function generateAnimal() {
    echo "Je suis dans le générateur\n";
    yield "Panda";
    echo "Je suis retourné dans le générateur\n";
    yield "Lama";  
    echo "je suis de retour\n";
    yield "Alpaga"; // je me suis arréte ici
    echo "plus d'animaux\n"; //pas de yield je renvoie null..
}

$generator-&gt;next() // On récupère la valeur suivante
echo $generator-&gt;current();
// Plus d'animaux 
// il n'y a rien car echo null;
</code></pre>

<p>Une fois qu&#8217;un générateur a fini, on ne peux le réutiliser</p>

<pre><code class="php">foreach ($generator as $value) {
    echo "j'ai reçu $value \n";
}

foreach ($generator as $value) {
    echo "j'ai reçu $value \n";
}
</code></pre>

<p>J&#8217;obtiens</p>

<pre><code class="">PHP Fatal error:  Uncaught exception 'Exception' with message 'Cannot traverse an already closed generator' in /home/marc/yield.php:16
</code></pre>

<h2>Quel est l&#8217;intérêt ?</h2>

<p>Admettons que je veux faire un <code>foreach</code> sur un tableau d&#8217;un millions de lignes.</p>

<p>Pour faire un Array de 1 Million de valeurs ce n&#8217;est pas très compliqué. Une instruction suffit.</p>

<pre><code class="php">range(1000000) = [1,2,3,4,...,1000000];
</code></pre>

<p>Mais cela prend un peu de mémoire. Utilisons notre générateur de manière sympathique</p>

<pre><code class="php">function xrange($min, $max) {
  for ($i = $min; $i &lt; $max; $i++) yield $i;
}

foreach (xrange(1,1000000) as $value) {
   echo $value;
}
</code></pre>

<p>l&#8217;énorme avantage est que je n&#8217;ai pas besoin de générer un array de 1 Millions de lignes, je génère valeur par valeur. Si la fonction est appelle deux fois je ne génère que deux valeurs. L&#8217;occupation en mémoire est faible. Les valeurs sont instanciées <em>paresseusements</em>.</p>

<h3>Un exemple encore plus concret.</h3>

<p>Pour lire un fichier:</p>

<pre><code class="php ">function getLinesFromFile($fileName) {
    $fileHandle = fopen($fileName, 'r');
    while (false !== $line = fgets($fileHandle)) {
        yield $line;
    }
    fclose($fileHandle);
}
$lines = getLinesFromFile($fileName);
foreach ($lines as $line) {
    // do something with $line
}
</code></pre>

<p>Ce code a plusieurs avantages.</p>

<ul>
<li>On va chercher la ligne à la demande.</li>
<li>Il y a une couche d&#8217;abstraction entre la lecture et le programme principale.</li>
</ul>


<h3>Un petit quizz</h3>

<p>Pouvez vous deviner la fonction suivante ?</p>

<pre><code>function mystere() {
    $last = 0;
    $current = 1;
    yield 1;
    while (true) {
        list($current, $last) = array($current + $last, $current);
        yield $current;
    }
}

$count = 0;
foreach (mystere() as $value) {
    $count++;
    echo $value . "\n";
    if ($count &gt; 10) {
        break;
        // pas cool la boucle infinie
    }
}
</code></pre>

<h2>Une mise au point</h2>

<p>Les générateurs se comportent comme des itérateurs, mais pour implémenter un <a href="http://php.net/manual/fr/class.iterator.php">iterator</a> il faut implémenter l&#8217;interface suivante.</p>

<pre><code class="php "> Iterator extends Traversable {
/* Méthodes */
abstract public mixed current ( void )
abstract public scalar key ( void )
abstract public void next ( void )
abstract public void rewind ( void )
abstract public boolean valid ( void )
}
</code></pre>

<p>Par exemple pour l&#8217;exemple du fichier (je recopie la doc de php)</p>

<pre><code class="php">class LineIterator implements Iterator {
    protected $fileHandle;

    protected $line;
    protected $i;

    public function __construct($fileName) {
        if (!$this-&gt;fileHandle = fopen($fileName, 'r')) {
            throw new RuntimeException('Impossible d\'ouvrir le fichier : "' . $fileName . '"');
        }
    }

    public function rewind() {
        fseek($this-&gt;fileHandle, 0);
        $this-&gt;line = fgets($this-&gt;fileHandle);
        $this-&gt;i = 0;
    }

    public function valid() {
        return false !== $this-&gt;line;
    }

    public function current() {
        return $this-&gt;line;
    }

    public function key() {
        return $this-&gt;i;
    }

    public function next() {
        if (false !== $this-&gt;line) {
            $this-&gt;line = fgets($this-&gt;fileHandle);
            $this-&gt;i++;
        }
    }

    public function __destruct() {
        fclose($this-&gt;fileHandle);
    }
}
</code></pre>

<p>L&#8217;implémentation en générateur.</p>

<pre><code class="php">function getLinesFromFile($fileName) {
    if (!$fileHandle = fopen($fileName, 'r')) {
        throw new RuntimeException('Impossible d\'ouvrir le fichier : "' . $fileName . '"');
    }

    while (false !== $line = fgets($fileHandle)) {
        yield $line;
    }

    fclose($fileHandle);
}
</code></pre>

<p>C&#8217;est quand même plus simple.</p>

<h2>En conclusion.</h2>

<p>Cela existe aussi dans les autres langages</p>

<p>On trouve l&#8217;instruction <code>yield</code> surtout dans python</p>

<pre><code class="python">def countdown(n):
    while n &gt; 0:
        yield n
        n -= 1

for x in countdown(10):
    print 'depart dans %s' % x
</code></pre>

<p>La référence est ce <a href="http://www.dabeaz.com/generators/">site</a> , Il existe une <a href="http://www.youtube.com/watch?v=5-qadlG7tWo">video</a> (<strong>3 heures !!!</strong>)</p>

<p>Cela existe aussi dans <a href="http://www.tutorialspoint.com/ruby/ruby_blocks.htm">ruby</a>, <a href="https://msdn.microsoft.com/fr-fr/library/9k7k7cf0.aspx">C#</a>, et dans le javascript ES6</p>

<p>C&#8217;est un peu plus qu&#8217;une nouvelle syntaxe. Cela permet de faire du code asynchrone. Car cela permet une structure de codage que l&#8217;on appelle: Les <a href="https://fr.wikipedia.org/wiki/Coroutine">Couroutines</a>. Mais plus d&#8217;info dans un prochain post .</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Les Promises Et Php via ReactPhp]]></title>
    <link href="http://mcamuzat.github.io/blog/2015/09/05/les-promises-et-php-via-react/"/>
    <updated>2015-09-05T19:10:10+02:00</updated>
    <id>http://mcamuzat.github.io/blog/2015/09/05/les-promises-et-php-via-react</id>
    <content type="html"><![CDATA[<p>Les promises sont une alternative plus puissante au Callback. Relativement peu connues au début. Elle sont maintenant en standard dans beaucoup de langage javascript ES6, python 3.2, java. Où via des librairies comme <a href="https://github.com/reactphp/promise">react/promise</a> pour php</p>

<p>Une promise représente une valeur donc le résultat n&#8217;est pas encore connu.
Quand le résultat est connu,  la promise a 3 états possibles</p>

<ul>
<li><strong>Pending</strong> ou <strong>Unfulfillled</strong>  en Attente..</li>
<li><strong>Resolved</strong> ou <strong>fulfillled</strong>  Succès</li>
<li><strong>Rejected</strong> ou <strong>Failed</strong>  Erreur.</li>
</ul>


<p>Un <em>Deffered</em> représente un travail qui n&#8217;est pas encore fini. Donc un <em>Deferred</em> possède une promise (une valeur pas encore connues).</p>

<p>Quand la valeur est connue, la promesse utilise un <em>handler</em> (en général <code>-&gt;then()</code>) qui lui-même renvoie une promise. L&#8217;intérêt est que les promises sont chainables.</p>

<p>Mais essayons quelques exemples qui seront un peu plus parlant.</p>

<p>Pour ce faire nous allons d&#8217;abord installer <a href="https://github.com/reactphp/promise">react/promises</a></p>

<pre><code class="php">&lt;?php
require __DIR__.'/vendor/autoload.php';

// On crée un travail
$deferred = new React\Promise\Deferred();

// On veux la promise
$promise  = $deferred-&gt;promise()-&gt;then(
    function () { echo "tout va bien \n"; },
    function () { echo "tout va mal \n"; },
    function () { echo "j'attends\n "; }
);


// Le travail est un succes, on résoud la promise
$deferred-&gt;resolve(); 
</code></pre>

<p>Voici ce que j&#8217;obtiens si je lance le programme.</p>

<pre><code class="php">tout va bien
</code></pre>

<p>Si je remplace <code>$deferred-&gt;resolve()</code> par <code>$deferred-&gt;reject()</code>. Le travail n&#8217;as pas marché. J&#8217;obtiens</p>

<pre><code class="php">Tout va mal
</code></pre>

<p>La syntaxe de <code>then</code> est</p>

<pre><code class="php">then(callable $onFulfilled = null, callable $onRejected = null, callable $onProgress = null)
</code></pre>

<ul>
<li>Si l&#8217;action est un succès, On résous la promise en appelant la fonction <code>$onFulfilled</code>.</li>
<li>L&#8217;action n&#8217;est pas bonne, On rejette la promise avec <code>$onRejected</code>.</li>
<li>Si l&#8217;action est en cours , On appelle <code>$onProgress</code>.</li>
</ul>


<p>A noter qu&#8217;une promise une fois qu&#8217;elle est résolue ou rejetée ne peut plus être réutilisée sauf dans le cas du <code>pending</code></p>

<pre><code class="php">$promise-&gt;notify();
$promise-&gt;notify();
$promise-&gt;notify();
$promise-&gt;resolve();
</code></pre>

<p>Le résultat</p>

<pre><code class="">j'attends
j'attends
j'attends
tout va bien
</code></pre>

<p>Pour l&#8217;instant rien de bien compliqué. On peut chainer les promises</p>

<pre><code class="php ">$promise  = $deferred-&gt;promise()-&gt;then(
    function () { echo "action 1 ok\n"; }
)-&gt;then(
    function () { echo "action 2 ok\n";}
)-&gt;then(
   function () { echo "action 3 ok\n";},
   function () { echo "une des actions n'est pas ok..\n";}
);

$deferred-&gt;resolve();
</code></pre>

<p>Le résultat
<code>
action 1 ok
action 2 ok
action 3 ok
</code></p>

<p>Essayons avec <code>deffered-&gt;reject()</code></p>

<p>Le résultat</p>

<pre><code>une des actions n'est pas ok..
</code></pre>

<p>Ajoutons un exception à la deuxième étape.
<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='php'><span class='line'><span class="nv">$promise</span>  <span class="o">=</span> <span class="nv">$deferred</span><span class="o">-&gt;</span><span class="na">promise</span><span class="p">()</span><span class="o">-&gt;</span><span class="na">then</span><span class="p">(</span>
</span><span class='line'>    <span class="k">function</span> <span class="p">()</span> <span class="p">{</span> <span class="k">echo</span> <span class="o">&amp;</span><span class="nx">ldquo</span><span class="p">;</span><span class="nx">action</span> <span class="mi">1</span> <span class="nx">ok\n</span><span class="o">&amp;</span><span class="nx">rdquo</span><span class="p">;;</span> <span class="p">}</span>
</span><span class='line'><span class="p">)</span><span class="o">-&gt;</span><span class="na">then</span><span class="p">(</span>
</span><span class='line'>    <span class="k">function</span> <span class="p">()</span> <span class="p">{</span> <span class="k">throw</span> <span class="k">new</span> <span class="nx">Exception</span><span class="p">();}</span>
</span><span class='line'><span class="p">)</span><span class="o">-&gt;</span><span class="na">then</span><span class="p">(</span>
</span><span class='line'>   <span class="k">function</span> <span class="p">()</span> <span class="p">{</span> <span class="k">echo</span> <span class="o">&amp;</span><span class="nx">ldquo</span><span class="p">;</span><span class="nx">action</span> <span class="mi">3</span> <span class="nx">ok\n</span><span class="o">&amp;</span><span class="nx">rdquo</span><span class="p">;;},</span>
</span><span class='line'>   <span class="k">function</span> <span class="p">()</span> <span class="p">{</span> <span class="k">echo</span> <span class="o">&amp;</span><span class="nx">ldquo</span><span class="p">;</span><span class="nx">une</span> <span class="nx">des</span> <span class="nx">actions</span> <span class="nx">n</span><span class="s1">&#39;est pas ok..\n&amp;rdquo;;}</span>
</span><span class='line'><span class="s1">);&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="s1">&lt;pre&gt;&lt;code&gt;</span>
</span><span class='line'><span class="s1">Le résultat</span>
</span><span class='line'><span class="s1">&lt;/code&gt;&lt;/pre&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="s1">&lt;p&gt;action 1 ok</span>
</span><span class='line'><span class="s1">une des actions n&#39;</span><span class="nx">est</span> <span class="nx">pas</span> <span class="nx">ok</span><span class="o">..</span>
</span></code></pre></td></tr></table></div></figure></p>

<p>Ajoutons une exception dans le premier, et ajoutons un cas pour gérer l&#8217;erreur
<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='php'><span class='line'><span class="nv">$promise</span>  <span class="o">=</span> <span class="nv">$deferred</span><span class="o">-&gt;</span><span class="na">promise</span><span class="p">()</span><span class="o">-&gt;</span><span class="na">then</span><span class="p">(</span>
</span><span class='line'>    <span class="k">function</span> <span class="p">()</span> <span class="p">{</span> <span class="k">throw</span> <span class="k">new</span> <span class="nx">\Exception</span><span class="p">();</span> <span class="p">}</span>
</span><span class='line'><span class="p">)</span><span class="o">-&gt;</span><span class="na">then</span><span class="p">(</span>
</span><span class='line'>    <span class="k">function</span> <span class="p">()</span> <span class="p">{</span> <span class="k">echo</span> <span class="o">&amp;</span><span class="nx">ldquo</span><span class="p">;</span><span class="nx">action</span> <span class="mi">2</span> <span class="nx">ok\n</span><span class="o">&amp;</span><span class="nx">rdquo</span><span class="p">;;},</span>
</span><span class='line'>    <span class="k">function</span> <span class="p">()</span> <span class="p">{</span> <span class="k">echo</span> <span class="o">&amp;</span><span class="nx">ldquo</span><span class="p">;</span><span class="nx">l</span><span class="s1">&#39;action 1 pas ok mais on continue..\n&amp;rdquo;;}</span>
</span><span class='line'><span class="s1">)-&gt;then(</span>
</span><span class='line'><span class="s1">   function () { echo &amp;ldquo;action 3 ok\n&amp;rdquo;;},</span>
</span><span class='line'><span class="s1">   function () { echo &amp;ldquo;une des actions n&#39;</span><span class="nx">est</span> <span class="nx">pas</span> <span class="nx">ok</span><span class="o">..</span><span class="nx">\n</span><span class="o">&amp;</span><span class="nx">rdquo</span><span class="p">;;}</span>
</span><span class='line'><span class="p">);</span><span class="o">&lt;/</span><span class="nx">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="nx">p</span><span class="o">&gt;</span><span class="nv">$deferred</span><span class="o">-&gt;</span><span class="na">resolve</span><span class="p">();</span>
</span></code></pre></td></tr></table></div></figure></p>

<p>Le résultat
<code>
l'action 1 pas ok mais on continue..
action 3 ok
</code></p>

<p>Si on veux que l&#8217;erreur de l&#8217;action 1 se propage deux possibilités..</p>

<ul>
<li>supprimer le callback d&#8217;erreur de l&#8217;action 2</li>
<li>Ou relancer l&#8217;exception</li>
</ul>


<pre><code>$promise  = $deferred-&gt;promise()-&gt;then(
    function () { throw new \Exception(); }
)-&gt;then(
    function () { echo "action 2 ok\n";},
    function () { echo "l'action 1 pas ok et on stop le processus"; throw new \Exception();}
)-&gt;then(
   function () { echo "action 3 ok\n";},
   function () { echo "une des actions n'est pas ok..\n";}
);
</code></pre>

<p>Ce qui est intéressant dans les promises c&#8217;est que le code équivalent en procédural est pas génial.
<code>
 $result = doAction1();
try {
    $result = doAction1();
    if ($result) {
        $result2 = doAction2($result);
        if ($result2) {
            $result3 = doAction3($result3);
            return $result3;
        } else {
            throw new Exception();
        }
    } else {
        throw New Exception();
    }
} catch (..){
    echo "une des actions n'est pas ok"
}
</code></p>

<p>Devient
<code>
    $result = $doAction1()
        -&gt;then(function($result1){doAction2($result1);})
        -&gt;then(
            function($result2){doAction3($result2);},
            function() {echo "une des actions n'est pas ok"}
        );
</code></p>

<p>C&#8217;est mieux non ?</p>

<p>Dans un prochain article nous nous utiliserons ce que nous avons appris avec <a href="http://guzzle.readthedocs.org/en/latest/">Guzzle</a>.</p>
]]></content>
  </entry>
  
</feed>
