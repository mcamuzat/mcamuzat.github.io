<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: php | Journal d'un panda.]]></title>
  <link href="http://mcamuzat.github.io/blog/categories/php/atom.xml" rel="self"/>
  <link href="http://mcamuzat.github.io/"/>
  <updated>2015-11-11T17:52:18+01:00</updated>
  <id>http://mcamuzat.github.io/</id>
  <author>
    <name><![CDATA[mcamuzat]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Listes Chainées Iterator]]></title>
    <link href="http://mcamuzat.github.io/blog/2015/11/01/listes-chainees-iterator/"/>
    <updated>2015-11-01T19:46:40+01:00</updated>
    <id>http://mcamuzat.github.io/blog/2015/11/01/listes-chainees-iterator</id>
    <content type="html"><![CDATA[<p>Troisième partie sur la SPL et les listes chainées.</p>

<ul>
<li>partie 1 <a href="blog/2015/10/03/spl-surcharge-magique">SPL et surcharge</a></li>
<li>partie 2 <a href="blog/2015/10/10/liste-chainees-implementation">Implémentation</a></li>
</ul>


<p>Nous allons implémenter l&#8217;interface <code>ArrayAccess</code>. Donc notre liste chainée va se comporter comme un array.</p>

<p>Je vais rajouter deux méthodes. Attention les <code>Array</code> commencent traditionnellement à 0 d&#8217;où le <code>$this-&gt;count -1</code></p>

<ul>
<li><p>Supprimer le chainon N
&#8220;` php
 public function removeAtPosition($position)
 {
     if (!$this->validateInterval($position)) {
             throw new \Exception(&ldquo;L&#8217;index doit être valide&rdquo;);
     }</p>

<pre><code> if ($position == 0) {
     return $this-&gt;removeFirstValue();
 }

 if ($position  ==  $this-&gt;count -1 ) {
     return $this-&gt;removeLastValue();

 }
 $current = $this-&gt;first;
 $last = $current;
 for ($i = 0; $i &lt; $position; $i++) {
     $last = $current;
     $current = $current-&gt;getNext();
 }

 $last-&gt;setNext($current-&gt;getNext());

 return $this;
</code></pre>

<p> }
&#8220;`</p></li>
<li><p>Récupérer le chainon N
&#8220;` php
 public function getAtPosition($position)
 {
     if (!$this->validateInterval($position)) {
         throw new \Exception(&ldquo;L&#8217;index doit être numerique&rdquo;);
     }
     if ($position == 0) {
         return $this->first->getData();
     }</p>

<pre><code> if ($position == $this-&gt;count - 1) {
     return $this-&gt;last-&gt;getData();
 }

 $current = $this-&gt;first;
 for ($i = 0; $i &lt; $position; $i++) {
     $current = $current-&gt;getNext();
 }

 return $current-&gt;getData();
</code></pre>

<p> }</p></li>
</ul>


<pre><code>
Pour avoir le 9999 chainon,  il faut parcourir les 9998 chainons précédents.

Avec les deux méthodes précédentes. Il suffit d'implémenter les méthodes suivantes
</code></pre>

<pre><code>public function offsetSet($offset, $value) {
    if ($offset == null) {
        $this-&gt;insertAtEnd($value);
    } else {
        if (!$this-&gt;validateInterval($offset)) {
            throw new \Exception("L'index doit être valide");
        }
        $this-&gt;insertAtPosition($offset, $value);
    }
}

public function offsetExists($offset) {
    return $this-&gt;validInterval($offset);
}

public function offsetUnset($offset)
{
     return $this-&gt;removeAtPosition($offset);
}

public function offsetGet($offset)
{
    return $this-&gt;getAtPosition($offset);
}
</code></pre>

<pre><code>
Pour vérifier que les valeurs en entrée sont correctes j'utilise la fonction suivante 
</code></pre>

<pre><code>private function validateInterval($offset) {
    return (false !== filter_var(
        $offset,
        FILTER_VALIDATE_INT,
        array(
            'options' =&gt; array(
                'min_range' =&gt; 0,
                'max_range' =&gt; $this-&gt;count-1
            )
        )
    ));
}
</code></pre>

<pre><code>
Bon cela semble un peu abstrait, voici quelques exemples d'utilisations.
</code></pre>

<p>$list = new LinkedList();
$list[] = &ldquo;first&rdquo;;
$list[] = &ldquo;second&rdquo;;
$list[] = &ldquo;third&rdquo;;
//
var_dump(isset($list[1]));// => true
var_dump($list[1]); // => &ldquo;second&rdquo;
unset($list[1]);
var_dump($list[1]); // => third
<code>``
Nous avons une liste qui se comporte comme un array. c'est pratique, mais on ne peux pas faire de</code>foreach` dessus.. Enfin pas encore.</p>

<h2>Ajout de l&#8217;itérator</h2>

<p>Pour faire un itérator il faut implémenter l&#8217;interface suivante
<code>php
 Iterator extends Traversable {
/* Méthodes */
abstract public mixed current ( void )
abstract public scalar key ( void )
abstract public void next ( void )
abstract public void rewind ( void )
abstract public boolean valid ( void )
}
</code></p>

<p>Dans le cas de notre liste chainée cela n&#8217;est pas très compliqué.</p>

<pre><code class="php"> class LinkedList implements Countable, ArrayAccess, *Iterator* {
    .....   
    private $current;
    private $position = 0;
    ....

    public function current () {
        return $this-&gt;current-&gt;getData();
    }
    public function key () {
        return $this-&gt;position;

    }
    public function next () {
        $this-&gt;position++;
        $this-&gt;current = $this-&gt;current-&gt;getNext();

    }
    public function rewind () {
        $this-&gt;position = 0;
        $this-&gt;current = $this-&gt;first;

    }
    public function valid () {
        return $this-&gt;current !== null;
    }
</code></pre>

<p>Un petit code d&#8217;exemple</p>

<pre><code class="php">$list = new LinkedList();
//
$list[] = "first";
$list[] = "second";
$list[] = "third";
foreach($list as $key =&gt; $value) {
    var_dump("$key =&gt; $value");
}

// string(10) "0 =&gt; first"
// string(11) "1 =&gt; second"
// string(10) "2 =&gt; third"
</code></pre>

<p>Je peux a tout moment le retransformer en <code>array</code> grâce à la méthode <code>iterator_to_array($list)</code></p>

<pre><code class="php">
array(3) {
  [0] =&gt;
  string(5) "first"
  [1] =&gt;
  string(6) "second"
  [2] =&gt;
  string(5) "third"
}
</code></pre>

<p>Pour faire dans l&#8217;autre sens nous pouvons implémenter le constructor
<code>php
    public function __construct($input = null)
    {
        if ($input) {
            if (! (is_array($input) || $input instanceof Traversable)) {
                throw new \Exception("Un array ou Un iterator..");
            }
            foreach($input as $value) {
                $this-&gt;insertAtEnd($value);
            }
        }
    }
</code></p>

<p>Mon constructor prend un array ou un Objet qui implémente <code>Traversable</code> (en gros un Itérateur);</p>

<p>Quelques exemples
&#8220;` php
$list = new LinkedList(array(&ldquo;one&rdquo;, &ldquo;two&rdquo;, &ldquo;three&rdquo;));
foreach($list as $key => $value) {
    var_dump($value);
}
//string(3) &ldquo;one&rdquo;
//string(3) &ldquo;two&rdquo;
//string(5) &ldquo;three&rdquo;</p>

<p>$spl = New SplQueue();
$spl[] = &ldquo;travail1&rdquo;;
$spl[] = &ldquo;travail2&rdquo;;
$spl[] = &ldquo;travail3&rdquo;;
$list = new LinkedList($spl));
foreach($list as $key => $value) {
    var_dump($value);
}</p>

<p>// string(8) &ldquo;travail1&rdquo;
// string(8) &ldquo;travail2&rdquo;
// string(8) &ldquo;travail3&rdquo;</p>

<p>$linked = New LinkedList();
$linked[] = &ldquo;valeur 1&rdquo;;
$linked[] = &ldquo;valeur 2&rdquo;;
$linked[] = &ldquo;valeur 3&rdquo;;</p>

<p>$list = new LinkedList($linked);
foreach($list as $key => $value) {
    var_dump($value);
}
// string(9) &ldquo;valeur 1&rdquo;
// string(8) &ldquo;valeur 2&rdquo;
// string(8) &ldquo;valeur 3&rdquo;</p>

<p>&#8220;`</p>

<h2>En conclusion.</h2>

<p>Nous avons implémenter Les listes chainées avec toutes les méthodes. Mon exemple est un peu théorique. Mais je vous conseille de re-regarder les doctrines collections.</p>

<p>Merci de m&#8217;avoir lu.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Les fractales en php Mandelbrot]]></title>
    <link href="http://mcamuzat.github.io/blog/2015/10/18/les-fractales-en-php-mandelbrot/"/>
    <updated>2015-10-18T20:02:28+02:00</updated>
    <id>http://mcamuzat.github.io/blog/2015/10/18/les-fractales-en-php-mandelbrot</id>
    <content type="html"><![CDATA[<p>Voici le code :</p>

<pre><code class="php">class Mandelbrot
{


    function Mandelbrot()
    {
        for ($x = -19; $x &lt; 19; $x++) {
            echo("\n");
            for ($y = -19; $y &lt; 19; $y++) {
                if (($out = $this-&gt;iterate($x/20.0,$y/20.0)) == 0)
                    echo("*");
                else
                    echo("_");

            }
        }
    }

    function iterate($x,$y)
    {
        $cr = $y-0.5;
        $ci = $x;
        $zi = 0.0;
        $zr = 0.0;
        $i = 0;
        while (true) {
            $i++;
            $zr2 = $zr * $zr;
            $zi2 = $zi * $zi;
            // Calul de la nouvelle valeur de z
            list($zr, $zi) = array(
                $zr2 - $zi2 + $cr,
                2 * ($zr * $zi) + $ci
            );
            // Si le module est supérieur à 2
            if ($zi2 + $zr2 &gt; BAILOUT)
                return $i;
            // si cela fait la millieme boucle.
            if ($i &gt; MAX_ITERATIONS)
                return 0;
        }

    }


}

$m = new Mandelbrot();
?&gt;
</code></pre>

<p>Voici le résultat</p>

<pre><code class="">______________________________________
______________________________________
___________________________*__________
_________________________****_________
_________________________****_________
_________________________****_________
______________________________________
___________________*__**********______
___________________**************_**__
___________________*****************__
__________________*****************___
_________________*******************__
________________*********************_
________________*********************_
______*__*_____**********************_
______*******__**********************_
_____*********_**********************_
_____*********_**********************_
___*_*********_*********************__
***********************************___
___*_*********_*********************__
_____*********_**********************_
_____*********_**********************_
______*******__**********************_
______*__*_____**********************_
________________*********************_
________________*********************_
_________________*******************__
__________________*****************___
___________________*****************__
___________________**************_**__
___________________*__**********______
______________________________________
_________________________****_________
_________________________****_________
_________________________****_________
___________________________*__________
_____________________________________
</code></pre>

<p>Comment cela marche.</p>

<p>Rappel sur les complexes</p>

<ul>
<li>un nombre complexe est composé d&#8217;une partie réelle et une partie imaginaire : <code>a + i b</code> ici <strong>a</strong> est la partie réelle et <strong>b</strong> est la partie imaginaire</li>
<li>le module d&#8217;un nombre complexe représente la distance entre les coordonnées du point et le centre. <code>|module|^2 = a^2 + b ^2</code></li>
<li>la multiplication d&#8217;un nombre complexe donne <code>(a + ib)^2 = (a^2-b^2)+2ab * i</code></li>
</ul>


<h2>La version simple</h2>

<p>il existe une video en anglais qui explique cela très bien.</p>

<iframe width="560" height="315" src="https://www.youtube.com/embed/NGMRB4O922I" frameborder="0" allowfullscreen></iframe>


<ul>
<li>Je crée un tableau (x,y) de 20 * 20 qui va de [1, -1] en largeur et en hauteur</li>
<li>j&#8217;effectue la boucle suivante.</li>
<li>je calcule la valeur <code>z1</code> qui est égale à <code>z0^2 + c</code> avec c qui est <code>x+i*y</code>.</li>
<li>puis je calcule la valeur de <code>z2 = z1^2 + c</code> puis <code>z3</code>..</li>
<li>je quitte la boucle pour deux raisons.

<ul>
<li>si le module est supérieur à 2, le module devient de plus en plus grand et dépasse 2.</li>
<li>au bout de 1000 boucles la valeurs n&#8217;a toujours pas dépassé 2. Je renvoie 0</li>
</ul>
</li>
</ul>


<p>C&#8217;est le code de la fonction <code>iterate</code>. le php ne connaît pas les complexes(c&#8217;est natif en python..) donc le chiffre z est divisé en 2 <code>zr</code> la partie réelle et <code>zi</code> la partie imaginaire.</p>

<pre><code>    function iterate($x,$y)
    {
        $cr = $y-0.5;
        $ci = $x;
        $zi = 0.0;
        $zr = 0.0;
        $i = 0;
        while (true) {
            $i++;
            $zr2 = $zr * $zr;
            $zi2 = $zi * $zi;
            // Calul de la nouvelle valeur de z
            list($zr, $zi) = array(
                $zr2 - $zi2 + $cr,
                2 * ($zr * $zi) + $ci
            );
            // Si le module est supérieur à 2
            if ($zi2 + $zr2 &gt; BAILOUT)
                return $i;
            // si cela fait la millieme boucle.
            if ($i &gt; MAX_ITERATIONS)
                return 0;
        }

    }
</code></pre>

<p>Si on compte le nombre d&#8217;étapes pour dépasser 2 on obtient le schéma suivant.</p>

<pre><code class="php">    function Mandelbrot()
    {
        for ($x = -19; $x &lt; 19; $x++) {
            echo("\n");
            for ($y = -19; $y &lt; 19; $y++) {
                if (($out = $this-&gt;iterate($x/20.0,$y/20.0)) == 0)
                    echo(" ");
                else
                    echo(chr(41+$out%16));

            }
        }
    }
</code></pre>

<p>Voici le résultat</p>

<pre><code class="">--------------.......///1241410/....--
-------------.......///023.2520//....-
------------.......///053)1 ,*1///....
-----------.......//00128    ,20////..
----------......//0001130    ,2100///.
--------......//012222348    7432000,/
-------.....///017+644.*1865+1/73222)1
------....////00164 *4          .68)*)
-----..//////00024-              6  23
---..///////0002868                 .1
-../000///00011/23                 ,61
.//1611111111125.                   +3
//01)3326422224,                     8
//014*.67-753352                     )
//113) 2) 73757                      8
/0125,       )*                      )
1+34-         0                      6
26780         +                      2
48/ 6         )                     41
                                   621
48/ 6         )                     41
26780         +                      2
1+34-         0                      6
/0125,       )*                      )
//113) 2) 73757                      8
//014*.67-753352                     )
//01)3326422224,                     8
.//1611111111125.                   +3
-../000///00011/23                 ,61
---..///////0002868                 .1
-----..//////00024-              6  23
------....////00164 *4          .68)*)
-------.....///017+644.*1865+1/73222)1
--------......//012222348    7432000,/
----------......//0001130    ,2100///.
-----------.......//00128    ,20////..
------------.......///053)1 ,*1///....
-------------.......///023.2520//....-
</code></pre>

<p>C&#8217;est ce qui est assez amusant dans les fractales, les formules sont très simples. Mais le résultat est très impressionnant.</p>

<h2>Des liens</h2>

<ul>
<li>article <a href="https://en.wikipedia.org/wiki/Mandelbrot_set">wikipédia</a></li>
<li>les videos hypnotiques de <a href="https://en.wikipedia.org/wiki/Electric_Sheep">electric sheep</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Listes chainées : implémentation]]></title>
    <link href="http://mcamuzat.github.io/blog/2015/10/10/liste-chainees-implementation/"/>
    <updated>2015-10-10T21:12:47+02:00</updated>
    <id>http://mcamuzat.github.io/blog/2015/10/10/liste-chainees-implementation</id>
    <content type="html"><![CDATA[<p>Dans la <a href="/blog/2015/10/03/spl-surcharge-magique/">partie 1</a> nous avons appris à surcharger le <code>count</code> ainsi que les différentes méthodes de <code>ArrayAccess</code>. Pour faire un exemple un peu plus concret, je vais impémenter les listes chainées. Les listes doublement chainée sont <strong>déja</strong> implémentées dans la SPL via <a href="http://php.net/manual/fr/class.spldoublylinkedlist.php">SplDoublyLinkedList</a>.</p>

<p>Le liste chainée (linked list en anglais) est une structure de donnée. Nous allons essayer d&#8217;implémenter une liste chainée en PHP. Cela nous permettra de comprendre l&#8217;idée. Nous allons implémenter l&#8217;interface <code>Countable</code>. (J&#8217;implémente <code>ArrayAccess</code> et <code>Iterator</code> dans le post suivant).</p>

<p>Une liste chainée est constituée de <code>Node</code> ou noeud/chainon.</p>

<p>Un node a deux propriétés.</p>

<ul>
<li>Sa valeurs</li>
<li>Le liens vers le noeud suivant</li>
</ul>


<p>En php</p>

<pre><code class="php">class Node {
    private $data;
    private $next;
    public function __construct($data, Node $next = null)
    {
        $this-&gt;data = $data;
        $this-&gt;next = $next;
    }
    public function setData($data)
    {
        $this-&gt;data = $data;
    }
    public function getData()
    {
        return $this-&gt;data;
    }

    public function getNext()
    {
        return $this-&gt;next;
    }

    public function setNext(Node $next = null)
    {
        $this-&gt;next = $next;
    }

}
</code></pre>

<p>pour créer une liste rien de bien compliqué.</p>

<pre><code class="php ">$noeud1 = new Node(12);
$noeud2 = new Node(99);
$noeud3 = new Node(37);
$noeud1-&gt;setNext($noeud2);
$neoud2-&gt;setNext($noeud3);
</code></pre>

<p>Résultat le dessin suivant (wikipedia)</p>

<p>{% img center /images/linked-list.png 408 41 &lsquo;Une liste chainée&rsquo; &lsquo;Une liste chainée %}</p>

<h2>Implementation de la liste</h2>

<p>Nous allons créer des méthodes pour ajouter simplement nos chainons.</p>

<pre><code class="php">class LinkedList implements Countable, ArrayAccess, Iterator {

    private $first;
    private $last;
    private $count = 0;
    ... 
    // pour l'iterateur
    private $current;
    private $position = 0;

    // Permet d'afficher le contenu de la chaine. 
    public function printMe() {
        $current = $this-&gt;first;
        while ($current-&gt;getNext()) {
            echo "-{$current-&gt;getData()}-";
            $current = $current-&gt;getNext();

        }
        echo $current-&gt;getData();
    }


}
</code></pre>

<p>Nous allons traquer le premier élément de la chaine (<code>$this-&gt;first</code>) et le dernier (<code>$this-&gt;last</code>)</p>

<h3>Ajout d&#8217;un chainon à la fin</h3>

<p>C&#8217;est assez simple.</p>

<ul>
<li>Créer un nouveau noeud</li>
<li>Récupérer le dernier chainon</li>
<li>Faire pointer la propriété <code>next</code> du dernier chainon vers notre nouveau noeud.</li>
<li>Notre nouveau noeud devient le dernier noeud.</li>
<li>On augmente la taille de 1</li>
</ul>


<p>en code cela donne
&#8220;` php
    public function insertAtEnd($data) {
        // nouveau noeud
        $node = new Node($data);
        // si la liste est vide
        if ($this->first == null) {
            $this->first = $node;
        }
        // on ajoute le liens vers le suivant
        if (!$this->last == null) {
            $this->last->setNext($node);
        }
    // notre nouveau noeud devient le dernier
        $this->last = $node;
        // on augmente la taille.
        $this->count++;
        return $this;
    }</p>

<pre><code>
Exemple
</code></pre>

<p>$list = new LinkedList();
$list->insertAtEnd(&ldquo;ha&rdquo;)->insertAtEnd(&ldquo;hi&rdquo;);
$list->printMe() // -ha-hi
&#8220;`</p>

<h3>Ajout d&#8217;un chainon au début</h3>

<p>C&#8217;est un peu près la même idée.</p>

<ul>
<li>Créer un nouveau noeud</li>
<li>Récupérer le premier noeud.</li>
<li>Notre noeud pointe vers le premier noeud.</li>
<li>On pointe le <code>first</code> vers notre nouveau noeud.</li>
</ul>


<p>En code
<code>php
    public function insertFirstValue($data)
    {
       $node = new Node($data, $this-&gt;first);
       $this-&gt;count++;
       // si la liste est vide
       if ($this-&gt;last == null) {
            $this-&gt;last = $this-&gt;first;
       }
       $this-&gt;first = $node;
       return $this;
    }
</code></p>

<p>Un exemple</p>

<pre><code>$list = new LinkedList();
$list-&gt;insertAtEnd("first")-&gt;insertFirstValue("second");
$list-&gt;printMe(); // -second-first
</code></pre>

<h3>Suppression d&#8217;un chainon au début.</h3>

<p>Il faut faire dans l&#8217;autre sens.</p>

<p>En code
&#8220;` php
    public function removeFirstValue() {
       if ($this->count == 0) {
            throw new \Exception(&lsquo;La liste est vide&rsquo;);
       }
       $value = $this->first->getData();
       $this->count&ndash;;
       $this->first = $this->first->getNext();
       // si la liste est vide , reinitialiser le last
       if ($this->first == null) {
           $this->last = null;
       }
       return $value;
    }
$list = new LinkedList();
$list->insertAtEnd(&ldquo;first&rdquo;)->insertAtEnd(&ldquo;second&rdquo;);
$list->printMe(); // -first-second
var_dump($list->removeFirstValue());
$list->printMe(); //</p>

<pre><code>
### Suppression d'un chainon à la fin

Comme le dernier chainon ne connait pas son prédécesseur. C'est beaucoup plus compliqué. On est obligé de repartir depuis le début. Donc pour supprimer le dernier chainon d'un liste d'un million de chainon, il nous faut parcourir les 1 millions de chainons.

En Code 
</code></pre>

<pre><code>public function RemoveLastValue()
{
    // cas particulier la liste est vide
    if ($this-&gt;count == 0) {
        throw new \Exception('la Liste est vide');
    }
    // Il n'y a qu'un noeud.
    if ($this-&gt;count == 1) {
        $value = $this-&gt;last-&gt;getData();
        $this-&gt;first = null;
        $this-&gt;last = null;
        $this-&gt;count == 0;
        return $this-&gt;value;
    }
    // On parcours tout les chainons jusqu'à l'avant-dernier
    $current = $this-&gt;first-&gt;getNext();
    $previous = $this-&gt;first;
    while ($current-&gt;getNext()) {
         $previous = $current;
         $current = $current-&gt;getNext();
    }
    // on supprime le liens
    $previous-&gt;setNext(null);
    // On déplace le last
    $this-&gt;last = $previous;
    // on décremente
    $this-&gt;count--;
    return $current-&gt;getData();
}
</code></pre>

<pre><code>
### Ajouter une valeurs au milieu de la chaine

Même punition que pour supprimer un lien à la fin de la liste. Si on a une liste de 1 Millions de chainons. Pour insérer à la position 99999, nous sommes obligés de parcourir les 99999 chainons. Et pour la suppression ce sera pareil..

{% img center /images/LinkedLists-addingnode.png 474 116 'Ajout d'un chainon' 'Ajout d'un chainon' %}
</code></pre>

<pre><code>public function insertAtPosition($position, $data)
{
    if ($position &lt;= 0) {
        return $this-&gt;insertFirstValue($data);
    }

    if ($position &gt;= $this-&gt;count) {
        return $this-&gt;insertAtEnd($data);
    }

    $current = $this-&gt;first;
    for ($i = 1; $i &lt; $position; $i++) {
        $current = $current-&gt;getNext();
    }

    $node = new Node($data, $current-&gt;getNext());
    $current-&gt;setNext($node);

    $this-&gt;count++;
    return $this;
}
</code></pre>

<pre><code>
## Implementer le `count`

Si vous avez lu le [post précédent]() il suffit d'ajouter une méthode `count`
</code></pre>

<pre><code>public function count()
{
    return $this-&gt;count;
}
</code></pre>

<pre><code>
## Des applications avec la Liste chainée.

Si on renomme la méthode `insertAtEnd($data)` par `enqueue($job)` et la méthode `removeFirstValue()` par `dequeue()`

On obtient une file d'attente ou une `Queue` en anglais.
</code></pre>

<p>$fileAttente = new LinkedList();
$fileAttente->enqueue(&ldquo;job1&rdquo;)->enqueue(&ldquo;job2&rdquo;);
var_dump($fileAttente->dequeue()); // job1
// je rajoute un travail
$fileAttente->enqueue(&ldquo;OtherJob&rdquo;);
var_dump($fileAttente->dequeue()); // job2
var_dump($fileAttente->dequeue()); // OtherJob</p>

<pre><code>Si on renomme la méthode `insertFirstValue` en `push` et la méthode `removeFirstValue()` par `pop()` On obtient une Stack.

Voici le code pour inverser un array sans utiliser `array_reverse`
</code></pre>

<p>$list1 = array(1,2,3,4,5);
$stack = new LinkedList();
foreach ($list as $value) {
    $stack->push($value);
}
$list2 = array();
while (stack->count()) {
    $list2[] = $stack->pop(); <br/>
}
var_dump($list2) //[5,4,3,2,1];
&#8220;`</p>

<h2>Conclusion</h2>

<p>Un ancien livre est titré</p>

<blockquote><blockquote><p>Algorithms + Data Structures = Programs</p></blockquote></blockquote>

<p>On a tendance en language php à penser tout en Object et en Array. Parfois la façon dont on représente nos données est importante.</p>

<ul>
<li>Certaines opérations comme ajouter un lien au début/fin de la chaine sont très peu couteuses (une étape) on parle de complexité O(1);</li>
<li>supprimer un lien à la fin de la liste par contre prend N étapes On dit que la complexité est de O(N)</li>
</ul>


<p>Pour résoudre ce problème on a inventé les listes doublements chainées. Voir le dessin (Wikipédia);</p>

<p>{% img center /images/Doubly-linked-list.png 610 41 &lsquo;doubles listes chainée&rsquo; &lsquo;double liste chainée&rsquo; %}</p>

<p>Cela prend beaucoup plus de mémoire, mais on simplifie beaucoup l&#8217;ajout et la suppression au début et à la fin de liste. par contre la recherche dans une liste chainée est toujours aussi longue.</p>

<p>Mon post sur les <a href="blog/2015/08/29/stacks-structures-meconnues/">Stack</a>.</p>

<p>Dans le post suivant on implémentera les méthodes de <code>ArrayAccess</code> et <code>Iterator</code>, ce qui nous permettra de faire des <code>foreach</code> ou <code>isset($list[2])</code> etc ..</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SPL surcharge magique]]></title>
    <link href="http://mcamuzat.github.io/blog/2015/10/03/spl-surcharge-magique/"/>
    <updated>2015-10-03T17:17:33+02:00</updated>
    <id>http://mcamuzat.github.io/blog/2015/10/03/spl-surcharge-magique</id>
    <content type="html"><![CDATA[<p>Nous allons repartir sur la <a href="http://php.net/manual/fr/book.spl.php">SPL</a>.</p>

<p>Je vais parler des différentes méthodes amusantes à surcharger.</p>

<h2>Count</h2>

<p>Soit la classe suivante</p>

<pre><code class="php">class BadCounter implements countable{
    public function count() {
        return 42;
    }
}

$counter = new BadCounter();

var_dump(count($counter));// int(42)
</code></pre>

<p>On peux surcharger la méthode <code>count</code>. C&#8217;est d&#8217;ailleurs le cas dans le cas du <a href="http://doctrine-orm.readthedocs.org/en/latest/tutorials/pagination.html">Paginator</a> de doctrine.</p>

<pre><code class="php">
$dql = "SELECT p, c FROM BlogPost p JOIN p.comments c";
$query = $entityManager-&gt;createQuery($dql)
                       -&gt;setFirstResult(0)
                       -&gt;setMaxResults(10);

$paginator = new Paginator($query);

count($paginator) // nombre de lignes dans la base
</code></pre>

<h2>Les ArrayObjects</h2>

<p>On peut aussi changer toutes les méthodes pour un tableau.</p>

<ul>
<li><code>isset(counter['valeur'])</code></li>
<li><code>unset(counter['valeur'])</code></li>
<li><code>counter['valeur'] = 3</code></li>
<li><code>counter[] = 3</code></li>
<li><code>counter['valeur']</code></li>
</ul>


<pre><code class="php">
class GeekCounter implements Countable, ArrayAccess {
    public function count() {
        return 42;
    }
    public function offsetSet($offset, $value) {
        if (is_null($offset)) {
            echo("on ajoute $value \n");

        } else {
            echo("on change la clé $offset par $value \n");
        }
    }

    public function offsetExists($offset) {
        echo("on teste la clé  $offset \n");
        return true;
    }

    public function offsetUnset($offset) {
        echo("on unset la clé $offset \n");
    }

    public function offsetGet($offset) {
        echo("on me demande la clé $offset \n");
        return 42;
    }
}

$counter = new GeekCounter();

var_dump(isset($counter["IdontCare"]));
var_dump($counter["IdontCare"]);
unset($counter["IdontCare"]);
$counter[] = 3;
$counter["IdontCare"] = 3;
</code></pre>

<pre><code class="php">on teste la clé  IdontCare 
bool(true)
on me demande la clé IdontCare 
int(42)
on unset la clé IdontCare 
on ajoute 3 
on change la clé IdontCare par 3 
</code></pre>

<p>On trouve la même idée dans les collections de doctrine.(l&#8217;interface <code>Collection</code> n&#8217;est qu&#8217;une surcharge);</p>

<p>Si on ne souhaite pas tout implémenter il suffit de surcharger la Classe <code>ArrayObject</code></p>

<p>Par exemple:
&#8220;` php
class ZooDeBeauval extends ArrayObject {
    public function offsetSet($offset, $value) {
        if (!in_array($value, array(&ldquo;Panda&rdquo;, &ldquo;Koala&rdquo;, &ldquo;Otarie&rdquo;))) {
            echo &ldquo;non cet animal $value n&#8217;est pas autorisé&rdquo;;
        } else {
            parent::offsetSet($offset, $value);
        }</p>

<pre><code>}
</code></pre>

<p>}</p>

<pre><code>Un exemple
</code></pre>

<p>$zoo = new ZooParcDeBeauval();
$zoo[] = &lsquo;Panda&rsquo;;
$zoo[] = &lsquo;Koala&rsquo;;</p>

<p>echo &ldquo;liste :  &rdquo;.implode(&lsquo;, &rsquo;, iterator_to_array($zoo)) . PHP_EOL;
$zoo[] = &lsquo;Lama&rsquo;;
&#8220;`</p>

<p>le résultat</p>

<pre><code class="php">liste :  Panda, Koala
non cet animal Lama n'est pas autorisé
</code></pre>

<p>Pour les <code>foreach</code> j&#8217;ai déjà parlé des iterators et des <a href="blog/2015/09/06/php-yield-les-generateurs/">générateurs</a>.</p>

<h2>Conclusion</h2>

<p>Maintenant les interfaces <code>ArrayAccess</code> et <code>Countable</code> n&#8217;ont plus de secrets pour vous. Nous verrons dans un prochain Post les listes chainées. L&#8217;avantage de ces méthode est que l&#8217;on obtient une structure qui se comporte comme un <code>array</code> mais avec une occupation mémoire moindre.</p>

<p>Dans un prochain post, je vais parler des listes chainées et des différentes structure de la SPL (j&#8217;ai déja parlé de la <a href="blog/2015/08/29/stacks-structures-meconnues/">SplStack</a>)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Guzzle Asynchrone avec les promises]]></title>
    <link href="http://mcamuzat.github.io/blog/2015/09/21/guzzle-asynchrone-avec-les-promises/"/>
    <updated>2015-09-21T21:39:06+02:00</updated>
    <id>http://mcamuzat.github.io/blog/2015/09/21/guzzle-asynchrone-avec-les-promises</id>
    <content type="html"><![CDATA[<p>Nous continuons sur les promises et le yield.</p>

<ul>
<li><a href="/blog/2015/09/05/les-promises-et-php-via-react/">partie 1 les promises</a></li>
<li><a href="/blog/2015/09/06/php-yield-les-generateurs/">partie 2 le Yield</a></li>
<li><a href="/blog/2015/09/13/yield-php-co-routine/">partie 3 les co-routines</a></li>
</ul>


<p>Je vais parler de <a href="https://github.com/guzzle">Guzzle</a> qui est un client HTTP. Nous allons voir la version 6 qui utilise Php5.5</p>

<h2>Promise et Guzzle.</h2>

<p><em>Guzzle</em> connait les promises et possède sa propre <a href="https://github.com/guzzle/promises">implémentation</a>.</p>

<p>la signature de la fonction est un peu près la même que <a href="https://github.com/reactphp/promise">react/promise</a>.</p>

<p>Attention <em>Guzzle</em> ne fait pas la différence entre le <em>Deferred</em> qui est un travail dont la réponse est encore inconnu et représenter par une <em>promise</em>. Dans <em>Guzzle</em> le travail et la réponse sont la même chose.</p>

<pre><code class="php">use GuzzleHttp\Promise\Promise;

$promise = new Promise();
$promise-&gt;then(
    // $onFulfilled
    function ($value) {
        echo 'Tout va bien.';
    },
    // $onRejected
    function ($reason) {
        echo 'On a un problème.';
    }
);

$promise-&gt;resolve(null); // 'Tout va bien.';
// Ou 
$promise-&gt;reject(null); // 'On a un problème.';
</code></pre>

<p><em>Guzzle</em> est un client Web essayons un cas concret.</p>

<pre><code class="php">$client = new GuzzleHttp\Client();

$promise = $client-&gt;requestAsync('GET', 'http://httpbin.org/get');
$promise-&gt;then(
    function ($res) {
        return $res-&gt;getStatusCode();
    }
)-&gt;then(function ($value) { echo "j'ai recu un code $value"} ;

// Notre requète n'est pas encore partie. Il faut lancer manuellement l'appel.
$client-&gt;wait();
</code></pre>

<p>L&#8217;avantage ici est que je décide quand je lance l&#8217;appel. Par exemple on peut lancer en parallèle les requêtes.</p>

<pre><code class="php">$client = new Client(['base_uri' =&gt; 'http://httpbin.org/']);

// Je crée toute mes requetes
$promises = [
    'image' =&gt; $client-&gt;getAsync('/image'),
    'png'   =&gt; $client-&gt;getAsync('/image/png'),
    'jpeg'  =&gt; $client-&gt;getAsync('/image/jpeg'),
    'webp'  =&gt; $client-&gt;getAsync('/image/webp')
];

// je resouds tout en même temps

$results = Promise\unwrap($promises);
</code></pre>

<p>On peux créer des pools. Si on souhaite limiter le nombre de requête en même temps.</p>

<pre><code class="php">$client = new Client(['base_uri' =&gt; 'http://httpbin.org/']);

$batch = [
    'image' =&gt; '/image',
    'png'   =&gt; '/image/png',
    'jpeg'  =&gt; '/image/jpeg',
    'webp'  =&gt; '/image/webp'
];

$requests = function ($batch) {
    foreach ($batch as $url) {
        yield new Request('GET', $url);
    }
};

$pool = new Pool($client, $requests($batch), [
    'fulfilled' =&gt; function ($response, $index) {
        var_dump($index);
    },
    'concurrency =&gt; 2,
]);
$promise = $pool-&gt;promise();
$promise-&gt;wait();
</code></pre>

<p>le résultat ici.</p>

<pre><code class="php">int(3)
int(0)
int(1)
int(2)
</code></pre>

<p>On reconnait aussi notre nouvel ami le <code>yield</code>.</p>

<h2>Le premier arrivé</h2>

<p>Nous allons utiliser l&#8217;instruction <code>any()</code> toutes les requêtes sont lancées en concurrences. C&#8217;est la première arrivée qui l&#8217;emporte.</p>

<pre><code>$client = new Client(['base_uri' =&gt; 'http://httpbin.org/']);

// je crée toute mes requetes
$promises = [
    'image' =&gt; $client-&gt;getAsync('/image'),
    'png'   =&gt; $client-&gt;getAsync('/image/png'),
    'jpeg'  =&gt; $client-&gt;getAsync('/image/jpeg'),
    'webp'  =&gt; $client-&gt;getAsync('/image/webp')
];

$result = Promise\any($promises)-&gt;then(function($value){var_dump($value-&gt;getHeader('Content-Type'));});
$result-&gt;wait();
</code></pre>

<p>Je veux juste les deux premières réponses <code>some(2, $promise)</code></p>

<pre><code class="php">$client = new Client(['base_uri' =&gt; 'http://httpbin.org/']);

// je crée toute mes requetes
$promises = [
    'image' =&gt; $client-&gt;getAsync('/image'),
    'png'   =&gt; $client-&gt;getAsync('/image/png'),
    'jpeg'  =&gt; $client-&gt;getAsync('/image/jpeg'),
    'webp'  =&gt; $client-&gt;getAsync('/image/webp')
];

$result = Promise\some(2, $promises)
    -&gt;then(function($results)
    {foreach ($results as $value)
        var_dump($value-&gt;getHeader('Content-Type'));
    }
);
$result-&gt;wait();
</code></pre>

<h2>Yield + Promise == Coroutine promise</h2>

<p>Bon Nous allons complexifier encore un peu.</p>

<p>Soit le code suivant</p>

<pre><code class="php">$client = new Client(['base_uri' =&gt; 'http://httpbin.org/']);

$promiseGenerator = function () use ($client) {
    yield $client-&gt;getAsync('/image');
    yield $client-&gt;getAsync('/image/png');
    yield $client-&gt;getAsync('/image/jpeg');
    yield $client-&gt;getAsync('/image/webp');
};

$result = array();
$promise = Promise\each_limit($promiseGenerator(), 2, function($value, $idx) use (&amp;$result) {$result[$idx] = $value;});

$promise-&gt;wait();
</code></pre>

<p>Je mets à la suite toute les promises que je souhaite exécuter en ajoutant <code>yield</code> devant.</p>

<p>Je laisse Guzzle gérer avec un limitation de 2. des que le programme a une place de libre, il appelle le générateur pour avoir un nouvelle promise.</p>

<p>Mais il existe dans Guzzle des co-routines..</p>

<pre><code class="php">$client = new Client(['base_uri' =&gt; 'http://httpbin.org/']);

$myfunction = function ($url) use ($client) {
    return Promise\coroutine(
        function () use ($client, $url) {
            try {
                $value = (yield $client-&gt;getAsync($url));
            } catch (\Exception $e) {
                yield New RejectedPromise($e-&gt;getMessage());
            }
        }
    );
};

$images = ['foo', 'baz', 'bar'];
$promises = [];

// Build an array of promises.
foreach ($images as $image) {
    $promises[] = $myfunction($image);
}

$aggregate = Promise\all($promises)-&gt;then(
    function($values) {echo 'ok' ;}, function($values){echo 'nope';});

$aggregate-&gt;wait();
</code></pre>

<p>Le code est complètement asynchrone.</p>

<p>Il est intéressant de voir le code synchrone et non parallèle.</p>

<pre><code class="php">$client = new Client(['base_uri' =&gt; 'http://httpbin.org/']);

$getImages = function ($url) use ($client) {
            try {
                return $value = $client-&gt;get($url);
            } catch (\Exception $e) {
                $value = $e-&gt;getMessage();
            }
        };

$images = ['foo', 'baz', 'bar'];
$promises = [];

// Build an array of promises.
foreach ($images as $image) {
    $result[] = $getImages($image);
}
</code></pre>

<p>En gros, j&#8217;ai retiré le <code>async</code> et les <code>yields</code> mais les deux codes se ressemblent non ?</p>

<h2>Conclusion</h2>

<p>Les promises sont pratiques.</p>

<ul>
<li>elles sont chainables</li>
<li>elles sont asynchrones, annulables, rejetables</li>
<li>On peut faire des foreach dessus.</li>
<li>On peut les combiner.</li>
</ul>


<p>Ce n&#8217;est pas vraiment un hasard. Les promises sont des <strong>Monades</strong>. Il n&#8217;est pas simple d&#8217;expliquer les monades. Les monades viennent de la programmation fonctionnelle et c&#8217;est surtout <a href="https://www.haskell.org/">haskell</a> qui a popularisé cette structure. J&#8217;espère que je reviendrai dessus.</p>

<p><em>Guzzle</em> est vraiment très sympathique à utiliser. Le coté asynchrone n&#8217;est pas simple, la fonction <code>co-routine</code> n&#8217;est pas dans la documentation. Il a été très difficile de trouver un code d&#8217;exemple. Je regrette que parfois le seul moyen de déclencher la résolution est d&#8217;appeler de manière synchrone <code>-&gt;wait()</code> ce qui est dommage.</p>
]]></content>
  </entry>
  
</feed>
