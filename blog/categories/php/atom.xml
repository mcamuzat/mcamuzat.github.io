<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Php | Mon blog perso.]]></title>
  <link href="http://mcamuzat.github.io/blog/categories/php/atom.xml" rel="self"/>
  <link href="http://mcamuzat.github.io/"/>
  <updated>2015-08-31T23:54:34+02:00</updated>
  <id>http://mcamuzat.github.io/</id>
  <author>
    <name><![CDATA[mcamuzat]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Lancer Des Commandes Dans Vim]]></title>
    <link href="http://mcamuzat.github.io/blog/2015/08/31/lancer-des-commandes-dans-vim/"/>
    <updated>2015-08-31T23:49:17+02:00</updated>
    <id>http://mcamuzat.github.io/blog/2015/08/31/lancer-des-commandes-dans-vim</id>
    <content type="html"><![CDATA[<p>Soit le fichier texte suivant:</p>

<pre><code class=""> * Alpha
 * Foxtrot
 * Charlie
 * Delta
 * Echo 
 * Bravo
</code></pre>

<p>Dans VIM il suffit de taper.</p>

<pre><code class="">:%sort ou :%!sort
</code></pre>

<p>Pour obtenir
<code>
 * Alpha
 * Bravo
 * Charlie
 * Delta
 * Echo
 * Foxtrot
</code></p>

<p>On peux aussi lancer plein de commandes amusantes</p>

<pre><code> * Doublon
 * Pas unique
 * Doublon
 * 
 * ...
</code></pre>

<pre><code>!sort | uniq -c | tr "[A-Z]" "[a-z]"
</code></pre>

<p>Pour ceux qui ne se rappelle plus trop les commandes de Bash</p>

<ul>
<li><code>sort</code> trie le texte</li>
<li><code>uniq -c</code> prend toute les valeurs et les comptes c&#8217;est l&#8217;équivalent d&#8217;un <code>GROUP BY</code> en SQL</li>
<li><code>tr</code> est l&#8217;abréviation de <strong>tr</strong>anspose je remplace les lettres en <code>[A-Z]</code> par leur équivalent en minuscule.</li>
</ul>


<pre><code>      1  * 
      1  * ...
      2  * doublon
      1  * pas unique
</code></pre>

<p>Si vous sélectionnez le texte avec <code>v</code> et que vous appuyer sur <code>:</code></p>

<p>Alors vous devez voir la commande suivante
<code>
:'&lt;,'&gt;
</code>
et Ajoutez la commande que vous allez appliquer à la sélection. Par exemple <code>:'&lt;,'&gt;!sort</code></p>

<p>Plus rigolo. On peux appeler des langages que l&#8217;on veut dans VIM</p>

<pre><code class="php">&lt;?php echo "bonjour";
</code></pre>

<p>Tapez <code>!!</code>
vous devriez voir apparaître
<code>
:.!
</code>
Compléter avec <code>:.!php</code></p>

<p>votre texte va se remplacer
<code>
bonjour
</code></p>

<p>Cela marche aussi avec python</p>

<pre><code class="python">print "olleh"[::-1]
</code></pre>

<p>Avec le curseur sur la ligne, appuyer sur <code>!!</code> puis ajoutez <code>:.!python</code></p>

<p>La ligne devient</p>

<pre><code class="">hello
</code></pre>

<h2>Exécuter une commande Bash depuis VIM</h2>

<p>La commande suivante</p>

<pre><code>php app/console cache:clear --env=prod
</code></pre>

<p>Si vous voulez exécuter la commande mais ne pas modifiez la ligne.</p>

<pre><code>:.w !bash
</code></pre>

<p>C&#8217;est un peu moins simple.</p>

<ul>
<li><code>:.</code> représente la ligne actuelle.</li>
<li><code>w</code> représente une écriture</li>
<li><code>!bash</code> via Bash.</li>
</ul>


<p>La documentation de VIM <code>:help :w_c</code></p>

<h2>en résumé</h2>

<ul>
<li>Si vous voulez appliquer votre commande sur tout le fichier <code>:%!commande</code></li>
<li>S vous voulez juste la ligne <code>:.!commande</code> ou tapez <code>!!</code>.</li>
<li>Si vous voulez sur une sélection <code>v</code> ou <code>V</code> puis <code>:</code> vous deviez voir ceci <code>:'&lt;,'&gt;</code>, ajoutez la commande souhaitée.</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Les Stacks Des Structures Méconnues]]></title>
    <link href="http://mcamuzat.github.io/blog/2015/08/29/stacks-structures-meconnues/"/>
    <updated>2015-08-29T16:34:41+02:00</updated>
    <id>http://mcamuzat.github.io/blog/2015/08/29/stacks-structures-meconnues</id>
    <content type="html"><![CDATA[<h2>Introduction</h2>

<p>Je vais parler de <code>SplStack</code> une structure de donnée qui fait partie de La SPL (pour <strong>S</strong>tandart <strong>P</strong>HP <strong>L</strong>ibrairie). Nous allons voir trois façons de nous servir de cette structure.</p>

<h2>Les Stacks ou Pile</h2>

<p>La pile n&#8217;a que deux opérations.</p>

<ul>
<li>Empiler ou Push On ajoute une donnée sur le haut de la pile.</li>
<li>Dépiler ou Pop On retire une donnée du haut de la pile.</li>
</ul>


<p>Il n&#8217;y a que le haut de la pile qui est visible. La pile est une mémoire LIFO (<strong>L</strong>ast <strong>I</strong>n <strong>F</strong>irst <strong>O</strong>ut).</p>

<p>Quelques exemples.</p>

<pre><code class="php">$pile = new SplStack(); // la pile est vide []
$pile-&gt;push(34) // [34]
$pile-&gt;push(45) // [34, 45]
$value = $pile-&gt;pop() // [34]
$pile-&gt;push('a') // [34, 'a']
$value = $pile-&gt;top() // $value = 'a' pile [34, 'a']
</code></pre>

<p>On peux utiliser les array comme des piles avec <code>array_pop</code> et <code>array_push</code>. Mais depuis PHP 5.0 il existe une Classe tout faite <code>SplStack</code></p>

<h2>Premiere application la machine à pile</h2>

<p>Il faut d&#8217;abord que je vous parle de la notation polonaise inverse. (RPN en anglais pour <strong>R</strong>everse <strong>P</strong>olish <strong>N</strong>otation).
<code>1 + 3</code> devient <code>1 3 +</code>. Pour faire simple je mets l&#8217;opérateur à la fin.</p>

<p>des exemples un peu plus complexe.</p>

<p> <code>1 + 2 * 3</code> devient <code>2 3 * 1 +</code> et <code>( 1 + 3 ) * ( 3 - 4 )</code> devient <code>1 3 + 3 4 - *</code></p>

<p>C&#8217;est un peu compliqué comme notation (en tout cas pas naturelle) mais nous allons voir que l&#8217;algorithme pour le calcul est très simple.</p>

<p>Voici l&#8217;algorithme :</p>

<ul>
<li>Si l&#8217;entrée est un entier : je l&#8217;empile</li>
<li>Si c&#8217;est une opération : je dépile deux valeurs, je fais l&#8217;opération et j&#8217;empile le résultat</li>
</ul>


<p>Un exemple</p>

<pre><code class="">soit 1 3 + 3 4 - * 
# je prend la premiere valeur "1" c'est un chiffre je l'empile
ma pile [ *1* ] 
# je prend la seconde valeur "3" c'est un chiffre je l'empile
ma pile [ 1 *3* ]
# je prend la valeurs 3 c'est une operation "+", je depile deux valeurs d'abords "3" puis "1". je fais l'addition. "4" que j'empile
ma pile [ *4* ]
# je prend la quatrieme valeur "3" c'est un chiffre j'empile
ma pile [ 4 *3* ]
# la cinquieme valeurs est un chiffre
ma pile [ 4 3 *4*]
# la sixieme valeur est une opération. je dépile deux valeurs "4" et "3" que je soustrait et je rempile
ma pile [ 4 *-1*]
# la septième valeur est une opération je dépile "-1" et "4" que je multiplie
ma pile ["-4"]
</code></pre>

<p>L&#8217;avantage de la notation est qu&#8217;elle n&#8217;a pas besoin de parenthèse. Il n&#8217;y pas d&#8217;ambigüité <code>( 1 + 3 ) * ( 3 - 4 )</code> est différent de  <code>1 + 3 * 3 - 4</code>.</p>

<p>L&#8217;implémentation est simple</p>

<pre><code class="php">function execute(array $ops)
{
    $stack = new \SplStack();

    foreach ($ops as $op) {
        if (is_numeric($op)) {
            $stack-&gt;push((int) $op);
            continue;
        }

        switch ($op) {
            case '+':
                $stack-&gt;push($stack-&gt;pop() + $stack-&gt;pop());
                break;
            case '-':
                $n = $stack-&gt;pop();
                $stack-&gt;push($stack-&gt;pop() - $n);
                break;
            case '*':
                $stack-&gt;push($stack-&gt;pop() * $stack-&gt;pop());
                break;
            case '/':
                $n = $stack-&gt;pop();
                $stack-&gt;push($stack-&gt;pop() / $n);
                break;
            default:
                throw new \InvalidArgumentException(sprintf('Invalid operation: %s', $op));
                break;
        }
    }

    return $stack-&gt;top();
}
</code></pre>

<p>essayons notre exemple.</p>

<pre><code class="php">var_dump(execute(explode(' ', '1 3 + 3 4 - *');
int(-4)
</code></pre>

<p>Félicitation nous venons d&#8217;implémenter notre première machine à pile. La plus célèbre est la <code>Java Virtual Machine</code>. Il existe aussi des langages qui sont basé sur la notion de pile, le plus célèbre est le <a href="https://fr.wikipedia.org/wiki/Forth_%28langage%29">Forth</a> et le <a href="https://fr.wikipedia.org/wiki/PostScript">Postscript</a>(si si le format de adobe). L&#8217;avantage des machines à pile est qu&#8217;elle n&#8217;utilise aucun autre registre que la pile.</p>

<h2>Le Shunting-yard de Dijkstra</h2>

<p>Je présente une version simplifié. <em>Shunting-yard</em> peut se traduire en <strong>Aiguillage</strong>. Il permet d&#8217;évaluer une expression mathématique.</p>

<p>Soit la chaîne suivante:</p>

<pre><code class="php">var_dump($calculate(explode(' ', '( ( 1 + 3 ) * ( 3 - 4 ) )')));

# int(-4)
</code></pre>

<ul>
<li>Il y a des parenthèses partout</li>
<li>L&#8217;arité des fonction est 2:  l&#8217;arité est le nombre d&#8217;argument par exemple 1 + 2 est d&#8217;arité 2 deux arguments. L&#8217;algorithme que je présente est incapable de faire <code>1 + 2 + 3</code> mais fera très bien <code>(1 + ( 2 + 3 ))</code>.</li>
</ul>


<p>Voici l&#8217;algorithme:</p>

<ul>
<li>Si parenthèse ouvrante:  je passe</li>
<li>Si c&#8217;est une opération <code>+</code>, <code>-</code>, <code>/</code>, <code>*</code>:  Je stocke dans une pile l&#8217;opération.</li>
<li>Si c&#8217;est un chiffre : je stocke dans une pile de valeurs</li>
<li>Si c&#8217;est une parenthèse fermante: Je dépile une opération et je dépile deux arguments. Je fais l&#8217;opération avec mes deux arguments et je remets le résultats dans ma pile.</li>
</ul>


<p>Voici le code</p>

<pre><code>function calculate(array $input)
{
    $operators = new SplStack();
    $values = new SplStack();

    foreach ($input as $token) {
        switch ($token) {
        case "(":
            break;
        case "+":
        case "-":
        case "*":
        case "/":
            $operators-&gt;push($token);
            break;
        case ")":
            $op = $operators-&gt;pop();
            $value = $values-&gt;pop();
            switch ($op) {
            case "+":
                $value = $values-&gt;pop() + $value;
                break;
            case "-":
                $value = $values-&gt;pop() - $value;
                break;
            case "*":
                $value = $values-&gt;pop() * $value;
                break;
            case "/":
                $value = $values-&gt;pop() / $value;
                break;
            }
            $values-&gt;push($value);
            break;
        default:
            $values-&gt;push($token);

        }

    }
    return $values-&gt;top();
}
</code></pre>

<p>On utilise deux piles. Une pour les opérations, Une pour les valeurs
je propose de faire le même exemple que plus haut
je vais représenter les deux piles et l&#8217;entrée actuelle</p>

<pre><code>operators :  [] values:  []  expression : ( ( 1 + 3 ) * ( 3 - 4 ) )

# '(' on ignore

operators [] values []  expression : ( 1 + 3 ) * ( 3 - 4 ) )

# '(' on ignore
operators [] values []  expression: 1 + 3 ) * ( 3 - 4 ) )

# '1' on ajoute dans values
operators [] values [*1*] expression:  + 3 ) * ( 3 - 4 ) )

# '+' on ajoute dans opérator
operators [*+*] values [1] expression: 3 ) * ( 3 - 4 ) )

# '3' on ajoute dans value
operators [*+*] values [1, *3*] expression: ) * ( 3 - 4 ) )

# ')' on dépile deux valeur de value et on depile une valeurs de l'operators et on empile le résultats dans values
operators [] values [4] expression:  * ( 3 - 4 ) )`

# '*' on ajoute dans opérator 
operators [*] values [4] expression:  ( 3 - 4 ) )

# '(' on ignore
operators [*] values [4] expression:  3 - 4 ) )

# '3' on ajoute dans values 
operators [*] values [4 *3*] expression:  - 4 ) )

# '-' on ajoute dans operators
operators [*, *-*] values [4 3] expression:  4 ) )

# '4' on ajoute dans values 
operators [*, ] values [4 3 4] expression:  ) )

# ')' on dépile deux valeur de value et on depile une valeur de operators et on empile le résultat dans values
operators [*] values [4 -1] expression:  )

# ')' on dépile deux valeur de values et on depile une valeur de operators et on empile le résultat dans values
operators [] values [-4] expression: 
</code></pre>

<p>On se rend compte que cette algorithme très simple permet de calculer toutes les expressions que l&#8217;on passe du moment qu&#8217;elles sont bien formées.</p>

<pre><code class="php">$expression = "( ( 1 + 3 ) * ( 3 - 4 ) )"
var_dump(calculate(explode(" ", $expression)));
</code></pre>

<p>Félicitation vous venez d&#8217;écrire votre premier interpréteur.</p>

<p>la version originale prend en compte la priorité des opérations (cela rend certaines parenthèses inutiles) c&#8217;est un peu plus complexe, mais pas tant que cela.</p>

<h2>Exemple 3 conversion vers RPN</h2>

<p>Nous allons utiliser notre pile pour traduire notre expression vers la RPN.</p>

<p>C&#8217;est à dire  <code>( ( 1 + 3 ) * ( 3 - 4 ) )</code> -> <code>1 3 + 3 4 - *</code></p>

<p>Voici l&#8217;algorithme.</p>

<ul>
<li>Si l&#8217;entrée est un parenthèse ouvrante :  je passe</li>
<li>Si c&#8217;est une opération : je stocke cela dans une pile</li>
<li>Si c&#8217;est un entier : Je pousse cela dans une file d&#8217;attente</li>
<li>Si c&#8217;est une parenthèse fermante : je vide la pile dans la file d&#8217;attente.</li>
</ul>


<pre><code>function transformate(array $input)
{
    $stack = new SplStack();
    $output = new SplQueue();

    foreach ($input as $token) {
        switch ($token) {
        case "(":
            break;
        case "+":
        case "-":
        case "*":
        case "/":
            $stack-&gt;push($token);
            break;
        case ")":
            while(count($stack)&gt; 0 &amp;&amp; $stack-&gt;top()) {
                $output-&gt;enqueue($stack-&gt;pop());
            }
            break;
        default:
            $output-&gt;enqueue($token);
        }
    }
    return iterator_to_array($output);
}
</code></pre>

<p>regardons avec le même exemple</p>

<pre><code>stack :  [] output:  []  expression : ( ( 1 + 3 ) * ( 3 - 4 ) )

# '(' on ignore

stack : [] output: []  expression : ( 1 + 3 ) * ( 3 - 4 ) )

# '(' on ignore
stack :  [] output []  expression: 1 + 3 ) * ( 3 - 4 ) )

# '1' on ajoute dans output
stack: [] output [1] expression:  + 3 ) * ( 3 - 4 ) )

# '+' on ajoute dans la stack
stack: [*+*] output [1] expression: 3 ) * ( 3 - 4 ) )

# '3' on ajoute dans output
stack: [*+*] output [1, *3*] expression: ) * ( 3 - 4 ) )

# ')' on vide stack dans outputs
stack: [] output [ 1, 3, *+*] expression:  * ( 3 - 4 ) )`

# '*' on ajoute dans la stack
stack: [*] output [1 , 3 , +] expression:  ( 3 - 4 ) )

# '(' on ignore
stack: [*] output [1, 3, +] expression:  3 - 4 ) )

# '3' on ajoute dans output.
stack: [*] output [1, 3, +, *3*] expression:  - 4 ) )

# '-' on ajoute dans la stack
stack: [*, *-*] output [1, 3, +, 3] expression:  4 ) )

# '4' on ajoute dans output.
stack: [*,-] output [1, 3, +, 3, *4*] expression:  ) )

# ')' on depile la stack dans output, on dépile d'abords - puis *
stack: [] output [1, 3, +, 3, 4, -, *] expression:  )

# ')' on re depile la stack mais ici elle est déja vide. 
</code></pre>

<p>Il suffit de transformer en array <code>$output</code> pour avoir le résultats suivants
<code>( ( 1 + 3 ) * ( 3 - 4 ) )</code> -> <code>1 3 + 3 4 - *</code></p>

<h2>Tous ensemble.</h2>

<p>Je ne resiste pas au plaisir d&#8217;utiliser l&#8217;instruction tabou du php <code>eval()</code></p>

<blockquote><p>If eval() is the answer, you&rsquo;re almost certainly asking the wrong question. &ndash; Rasmus Lerdorf, BDFL of PHP</p></blockquote>

<pre><code>$operation = "( ( 1 + 3 ) * ( 3 - 4 ) )";
$input = explode(" ", $operation);
var_dump(calculate($input));
var_dump(execute(transformate($input)));
var_dump($value = eval("return ($operation);"));
</code></pre>

<p>Nous avons sans surprise le même résultat
<code>
int(-4)
int(-4)
int(-4)
</code></p>

<h2>En conclusion</h2>

<ul>
<li>Nous avons créé une <em>VM</em> Notre machine à pile.</li>
<li>Nous avons crée un <em>interpréteur</em>:  notre algorithme de shunting-yard</li>
<li>Nous avons fait un traducteur de notre expression vers notre machine à pile. C&#8217;est un <em>compilateur</em>.</li>
<li>La notion de pile existe partout, on parle de pile d&#8217;appel (<em>stack-frame</em>), de dépassement de la pile (<em>stack overflow</em>), <code>git stash</code> est aussi un stockage en pile.</li>
</ul>


<h2>Des références.</h2>

<ul>
<li>L&#8217;algorithme simplifie viens du livre <a href="http://www.amazon.fr/dp/032157351X">Algorithms</a> de Sedgewick (j&#8217;ai traduis du Java vers Php)</li>
<li>L&#8217;exemple le plus complet sur les stacks-machine est <a href="https://igor.io/archive.html">Igor.io</a> la série est superbe, l&#8217;auteur explique vraiment bien.</li>
<li>L&#8217;article de wikipedia sur le <a href="https://en.wikipedia.org/wiki/Shunting-yard_algorithm">shunting-yard</a> Les illustrations montrent bien la notion d&#8217;aiguillage.</li>
<li><a href="https://fr.wikipedia.org/wiki/Edsger_Dijkstra">Edsger W. Dijkstra</a> est surtout connus pour son algorithme sur le plus court chemin. Mais c&#8217;est une légende de l&#8217;informatique. A voir si vous ne connaissez pas.</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Array_walk, Array_map, Array_walk_recursive]]></title>
    <link href="http://mcamuzat.github.io/blog/2015/08/26/array-walk/"/>
    <updated>2015-08-26T22:30:55+02:00</updated>
    <id>http://mcamuzat.github.io/blog/2015/08/26/array-walk</id>
    <content type="html"><![CDATA[<p>Une question que l&#8217;on m&#8217;a posé.</p>

<p>Quel instruction je n&#8217;ai jamais jamais réussi à utiliser dans php ? Dans le sens jamais trouvé d&#8217;utilisation pratique.</p>

<p>Ma réponse est un <code>array_recursive_walk()</code> et dans la même idée les <code>RecursiveIteratorIterator</code></p>

<p>Et puis on m&#8217;a demander la différence entre un <code>array_walk</code> et un <code>array_map</code>.</p>

<h2><code>array_map</code></h2>

<p>Voici quelques exemples</p>

<pre><code class="php">// via un array_map
$array = ['one', 'two', 'three']
$out = array_map(uc_first, $array);
</code></pre>

<p><code>array_map</code> ne touche pas le tableau original.</p>

<p>En fait <code>array_map</code> fait exactement ceci.</p>

<pre><code>$out = [ ucfirst('one'), ucfirst('two'), ucfirst('three') ];
</code></pre>

<p>De manière générale</p>

<pre><code>array_map(function($a),[a ,b, ..,z]) 
[function(a), function(b), function(c), .. function(z)].
</code></pre>

<ul>
<li>On renvoie un tableau de la <strong>même</strong> taille.</li>
<li>la fonction appelé doit contenir un <strong>return</strong></li>
<li>C&#8217;est de la programmation fonctionnelle (c&#8217;est le <strong>map</strong> de <strong>Map</strong>Reduce).</li>
<li>On ne connais pas l&#8217;index (que l&#8217;on pourrai récupérer dans un <code>foreach($array as $key =&gt; $value)</code>).</li>
</ul>


<h2><code>Array_walk</code></h2>

<pre><code class="php">$array = ['one', 'two', 'three']
function toMaj(&amp;$input, $key) {
    // ucfirst give error with 2 arguments
    $input = ucfirst($input);
}
array_walk($array, 'toMaj');
var_dump($array);
</code></pre>

<p>Constatons:</p>

<ul>
<li>Je passe par référence <code>&amp;input</code>.</li>
<li>Donc je n&#8217;ai pas besoin de <code>return</code>.</li>
<li>Donc nous sommes dans du <strong>procédural</strong>. (ce qui n&#8217;est pas forcément un défaut)</li>
<li>J&#8217;ai économisé une variable</li>
<li>On est obligé d&#8217;écrire des fonctions à deux arguments certaines fonctions comme <code>ucfirst</code> refusent d&#8217;avoir plusieurs arguments.</li>
<li>Par contre, on connait l&#8217;index (<code>$key</code>) mais impossible de le modifier.</li>
<li><code>array_walk</code> renvoie <code>true</code> or <code>false</code> ce qui n&#8217;aide pas beaucoup</li>
</ul>


<pre><code>$array = ['one', 'two', 'three']
function toMaj(&amp;$input, $key) {
    $input = $key.' : 'ucfirst($input);
}
array_walk($array, 'toMaj');
var_dump($array);
</code></pre>

<p>Pour résumer
les deux fonctions ont un peu près le même résultat.</p>

<ul>
<li><code>array_walk</code> prend un array et remplace chaque valeurs par Fonction(valeur).</li>
<li><code>array_map</code> prend un array et recrée un array de la même taille.</li>
</ul>


<h2>Le <code>Array_recursive_walk</code></h2>

<p>Un exemple de code.</p>

<p>Je voulais faire un <code>CamelCase</code> -> <code>snake_case</code> mais comme le <code>array_walk</code> impossible de modifier les clés des index.</p>

<p>Soit l&#8217;exemple suivant</p>

<pre><code class="php">$array =  ["Tortue-ninja" =&gt; ["leonardo" , "donatello", "michelangelo","raphael"], "Mechant" =&gt; ["shredder", "krang"]];
array_walk_recursive($array, function(&amp;$item, $key) {
    if ($key === "Tortue-ninja") {
        echo 'Cowabunga!';
    }
    $item = ucfirst($item);
});

var_dump($array);
</code></pre>

<p>Le programme n&#8217;affiche pas de <code>Cowabunga</code>, mais j&#8217;ai mis en majuscule toutes les valeurs.</p>

<pre><code>array(2) {
  'Tortue-ninja' =&gt;
  array(4) {
    [0] =&gt;
    string(8) "Leonardo"
    [1] =&gt;
    string(9) "Donatello"
    [2] =&gt;
    string(12) "Michelangelo"
    [3] =&gt;
    string(7) "Raphael"
  }
  'mechant' =&gt;
  array(2) {
    [0] =&gt;
    string(8) "Shredder"
    [1] =&gt;
    string(5) "Krang"
  }
}
</code></pre>

<p>On ne passe jamais sur le clé : <code>Tortue-ninja</code>, d&#8217;ailleurs la documentation est claire</p>

<blockquote><p>Toute clé qui est associée à un tableau n&#8217;est pas passée à la fonction de rappel.</p></blockquote>

<p>Un vrai exemple
<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='php'><span class='line'>    <span class="nb">array_walk_recursive</span><span class="p">(</span><span class="nv">$data</span><span class="p">,</span> <span class="k">function</span> <span class="p">(</span><span class="o">&amp;</span><span class="nx">amp</span><span class="p">;</span><span class="nv">$value</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="nv">$value</span> <span class="nx">instanceof</span> <span class="nx">\Traversable</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="nv">$value</span> <span class="o">=</span> <span class="nb">iterator_to_array</span><span class="p">(</span><span class="nv">$value</span><span class="p">);</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">});</span>
</span></code></pre></td></tr></table></div></figure>`</p>

<p>Un exemple que l&#8217;on retrouve dans <a href="">PHPUnit</a> et <a href="">Symfony2</a></p>

<p>On veut logger des objets en les serialisant en Json. Certain objects (comme les ArrayCollection et autres..) sont <em>Traversables</em> (c&#8217;est à dire qu&#8217;il possède un Iterateur (On implémente <code>current</code>, <code>next</code>, <code>rewind</code>, <code>valid</code>). En php il est possible de transformer les Itérateurs en Array avec l&#8217;instruction <code>iterator_to_array()</code>. ainsi on transforme l&#8217;objet en Array pour avoir plus d&#8217;information.</p>

<h2>En conclusion</h2>

<p>Donc je n&#8217;ai jamais réussi à écrire un <code>array_walk_recursive</code> mais au moins j&#8217;ai réussi à écrire un post dessus.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Halt Compiler : Twig Et Php Dans Le Même Fichier]]></title>
    <link href="http://mcamuzat.github.io/blog/2015/08/23/halt-compiler-twig-et-php-dans-le-meme-fichier/"/>
    <updated>2015-08-23T17:20:41+02:00</updated>
    <id>http://mcamuzat.github.io/blog/2015/08/23/halt-compiler-twig-et-php-dans-le-meme-fichier</id>
    <content type="html"><![CDATA[<h2>Introduction</h2>

<p>je vais parler de l&#8217;instruction <code>__halt_compiler()</code>.</p>

<p>Cette instruction arrête l&#8217;interprétation du PHP. Instruction inutile ? Pas vraiment..</p>

<p>Pour ce faire je vais montrer un exemple ou je vais mixer un fichier php et un fichier <a href="http://twig.sensiolabs.org/">twig</a> ensemble.</p>

<h2>L&#8217;instruction <code>__halt_compiler()</code></h2>

<p>D&#8217;après php.net</p>

<blockquote><p>Stoppe l&#8217;exécution du compilateur. Ceci peut être très utile pour embarquer des données dans des scripts PHP, comme des fichiers d&#8217;installation.
L&#8217;octet de la position du début des données peut être déterminé par la constante <code>__COMPILER_HALT_OFFSET__</code> qui n&#8217;est définie que s&#8217;il y a une fonction <code>__halt_compiler()</code> présente dans le fichier.</p></blockquote>

<h2>Une première expérimentation</h2>

<p>Soit le fichier php suivant :</p>

<pre><code class="php">&lt;?php
echo 'salut la compagnie!!';
__halt_compiler();
echo "j'apparais pas";
</code></pre>

<p>Comme prévue deuxième ligne ne s&#8217;affiche pas.</p>

<h2>Une seconde expérimentation.</h2>

<pre><code class="php">&lt;?php
$txt = file_get_contents(__FILE__, false, null, __COMPILER_HALT_OFFSET__);
echo strtoupper($txt);
__halt_compiler();
Bonjour tout le monde!
</code></pre>

<p>La constante <code>__FILE__</code> représente le fichier actuelle, la constante <code>__COMPILER_HALT_OFFSET__</code> représente la position de l&#8217;instruction <code>__halt_compiler()</code>. On récupère le texte qui ne s&#8217;affiche pas.</p>

<pre><code class="sh">BONJOUR TOUT LE MONDE!
</code></pre>

<h2>Mettre le fichier php et le fichier de template twig dans le même fichier</h2>

<p>Un exemple un peu théorique car pas très optimisé.</p>

<p>J&#8217;ai besoin de twig, voici le <code>composer.json</code></p>

<pre><code class="json">{
   "require": {
        "twig/twig": "^1.20"
    }
}
</code></pre>

<p>Voici mon programme.</p>

<pre><code class="php">&lt;?php
require_once __DIR__ . '/vendor/autoload.php'; // Autoload files using Composer autoload

function get_halt_data() {
    return file_get_contents(__FILE__, false, null, __COMPILER_HALT_OFFSET__);
}

$loader = new Twig_Loader_Array(array(
    'index' =&gt; get_halt_data()));
$twig = new Twig_Environment($loader);

echo $twig-&gt;render('index', array('name' =&gt; 'Fabien'));

__halt_compiler();

hello {\{name}\}
</code></pre>

<pre><code class="sh">hello fabien
</code></pre>

<p>Désolé pour les <code>{\{</code> sinon cela n&#8217;apparait pas sur le code.</p>

<p>C&#8217;est relativement inefficace. Il doit avoir moyen de faire un peu plus propre en profitant du cache.</p>

<p>Comme annoncé dans le titre , j&#8217;ai dans le même fichier le php et le template twig.</p>

<h3>Un exemple plus concret <code>composer.phar</code></h3>

<p>Ouvrons pour voir le fichier <code>composer.phar</code></p>

<p>Voici ce que je vois. Nous retrouvons notre instruction du jour.</p>

<pre><code class="php">...
Phar::mapPhar('composer.phar');
define('COMPOSER_DEV_WARNING_TIME', 1445255994);
require 'phar://composer.phar/bin/composer';

__HALT_COMPILER(); ?&gt;
.. 
</code></pre>

<p>Les fichiers <code>.phar</code> en pratique n&#8217;utilise que cette astuce. Je connais assez peu.</p>

<h2>Conclusion</h2>

<ul>
<li>Sur l&#8217;utilisation en template. Il y a le projet <a href="https://github.com/bobthecow/mustache.php">mustache.php</a> vous ne devriez pas être perdu avec le loader <a href="https://github.com/bobthecow/mustache.php/wiki/Template-Loading#inline-loader">suivant</a></li>
<li>Sur l&#8217;utilisation de string dans un template twig, la lecture de cet <a href="https://techpunch.co.uk/development/render-string-twig-template-symfony2">article</a> est très bien.</li>
<li>Sur les <code>.phar</code> la <a href="http://php.net/manual/en/phar.mapphar.php">documentation officielle</a> semble un bon début.</li>
</ul>


<p>Je vais essayer de continuer à parler d&#8217;autres instructions et structures peu connues (par exemple <code>__invoke</code> ou les <code>SplHeap</code>).</p>

<p>Merci de m&#8217;avoir lu.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[QuickCheck Une Autre Façon De Tester]]></title>
    <link href="http://mcamuzat.github.io/blog/2015/08/22/quickcheck-une-autre-facon-de-tester/"/>
    <updated>2015-08-22T19:01:42+02:00</updated>
    <id>http://mcamuzat.github.io/blog/2015/08/22/quickcheck-une-autre-facon-de-tester</id>
    <content type="html"><![CDATA[<h2>Introduction</h2>

<p>Nous allons voir ensemble, une nouvelle façon de faire des tests. Nous allons installer utiliser un projet <a href="https://github.com/steos/php-quickcheck">php-quickcheck</a>. L&#8217;idée ici n&#8217;est pas d&#8217;écrire des tests, mais demander au logiciel de les générer.</p>

<h2>Installation.</h2>

<p>Nous allons créer le <code>composer.json</code> suivant.</p>

<pre><code class="json">{
  "require": {
    "steos/php-quickcheck": "dev-master"
  }
}
</code></pre>

<p>Puis créer un fichier <code>test.php</code>.</p>

<pre><code class="php">
require_once __DIR__ . '/vendor/autoload.php'; // Autoload files using Composer autoload

use QCheck\Generator as Gen;
use QCheck\Quick;
</code></pre>

<p>Un petit <code>composer install</code>. Et tout est en place.</p>

<h2>Exemple N°1</h2>

<h3>Affirmation</h3>

<p>Je vais essayer de prouver que <code>array_merge($list1, $list2) == $list1 + $list2</code> (<strong>ce qui est faux</strong>)</p>

<p>Je l&#8217;écris dans la fonction suivante</p>

<pre><code class="php">function isEqual(array $list1, array $list2) {
    return (array_merge($list1, $list2) == $list1 + $list2);
}
</code></pre>

<h3>Mise en place et contre-exemple.</h3>

<p>Voici le code</p>

<pre><code class="php">$test = Gen::forAll(
    [Gen::ints()-&gt;intoArrays(), Gen::ints()-&gt;intoArrays()], isEqual
 );
</code></pre>

<p><code>Gen::ints()-&gt;intoArrays()</code> génère des array avec une taille aléatoire <code>[0, 1], [-15,0,5], ..</code> que  je vais passer à la fonction <code>isEqual</code></p>

<pre><code>print_r(Quick::check(102, $test, ['echo' =&gt; true]));
</code></pre>

<p>Je vais lancer 102 fois mon test.</p>

<p>Voici ce que me dit le programme dès que je lance.</p>

<pre><code>..F
Array
(
    [result] =&gt; 
    [seed] =&gt; 1440263990644
    [failing_size] =&gt; 2
    [num_tests] =&gt; 3
    [fail] =&gt; Array
        (
            [0] =&gt; Array
                (
                    [0] =&gt; 1
                )

            [1] =&gt; Array
                (
                    [0] =&gt; -2
                    [1] =&gt; 1
                )

        )

    [shrunk] =&gt; Array
        (
            [nodes_visited] =&gt; 9
            [depth] =&gt; 3
            [result] =&gt; 
            [smallest] =&gt; Array
                (
                    [0] =&gt; Array
                        (
                            [0] =&gt; 0
                        )

                    [1] =&gt; Array
                        (
                            [0] =&gt; 0
                        )

                )

        )

)
</code></pre>

<p>Le résultat est intéressant, Le logiciel a essayé 3 fois, au troisième essai l&#8217;exemple <code>([1], [-2,1])</code> donne un cas qui ne marche pas.</p>

<p>Vérifions avec <code>php -a</code></p>

<pre><code class="">php &gt; var_dump(array_merge([1], [-2,1]));
array(3) {
  [0] =&gt;
  int(1)
  [1] =&gt;
  int(-2)
  [2] =&gt;
  int(1)
}
php &gt; var_dump([1] + [-2,1]);
array(2) {
  [0] =&gt;
  int(1)
  [1] =&gt;
  int(1)
}
</code></pre>

<p>Effectivement.. Mais il y a mieux. Le logiciel a fais un <em>shrunk</em>, c&#8217;est à dire qu&#8217;il a calculé le plus petit exemple possible qui est <code>([0], [0])</code>.</p>

<p>Donc la librairie me donne tort et en plus me donne le contre-exemple.</p>

<h2>Exemple N°2</h2>

<h3>Affirmation</h3>

<p>J&#8217;affirme que <code>(sort (array) == sort(sort(array))</code> que en gros cela ne sert à rien de trier deux fois un array.</p>

<h3>Mise en place</h3>

<pre><code>$test2 = Gen::forAll(
    [Gen::ints()-&gt;intoArrays()],
    function ($list) {
        $lista = $list;
        $listb = $list;
        sort($lista);
        sort($listb);
        sort($listb);
        return ($lista == $listb);
    }
  );

print_r(Quick::check(101, $test2, ['echo' =&gt; true]));
</code></pre>

<p>Je lance le logiciel</p>

<pre><code>.....................................................................................................Array
(
    [result] =&gt; 1
    [num_tests] =&gt; 101
    [seed] =&gt; 1440265001108
)
</code></pre>

<p>Le logiciel semble d&#8217;accord. Il a fait 101 tests, mais il n&#8217;a pas trouvé de contre-exemple.</p>

<h2>Exemple N°3</h2>

<p>Nous allons encoder en <code>run legth encoding</code> qui est l&#8217;actuel encodage des fichiers bitmaps.</p>

<p>Quelque exemples:
<code>
Input: WWWWWWWWWWWWBWWWWWWWWWWWWBBBWWWWWWWWWWWWWWWWWWWWWWWWBWWWWWWWWWWWWWW
Output: 12W1B12W3B24W1B14W
</code></p>

<p>Il y a <code>12W</code> puis <code>1B</code> etc .. je compresse ma chaîne de caractères.</p>

<p>Dans l&#8217;autre sens
<code>
Input: 12W1B12W3B24W1B14W
Output: WWWWWWWWWWWWBWWWWWWWWWWWWBBBWWWWWWWWWWWWWWWWWWWWWWWWBWWWWWWWWWWWWWW
</code></p>

<p>Voici une implémentation en php</p>

<pre><code class="php">function encode($str) {
    return preg_replace_callback(
        '/(.)\1+/',
        function($m) {
            return sprintf('%s%s', strlen($m[0]), $m[1]);
        },
        $str
    );
};
function decode($str) {
    return preg_replace_callback(
        '/(\d+)(\D)/',
        function($m) {
            return str_repeat($m[2], $m[1]);
        },
         $str
     );
}
</code></pre>

<p>Mon implémentation est correcte, mais il y a un petit souci. Pouvez vous deviner le souci de mon programme.</p>

<p>A priori <code>$input == decode(encode($input))</code></p>

<h3>Mise en place.</h3>

<pre><code class="php">$test3 = Gen::forAll(
    [Gen::alphaNumStrings()],
    function ($string) {
      return ($string == decode(encode($string)));
    }
);
print_r(Quick::check(101, $test2, ['echo' =&gt; true]));
</code></pre>

<p>Le logiciel ne tarde pas à trouver le souci</p>

<pre><code>.....F
Array
(
    [result] =&gt; 
    [seed] =&gt; 1440265916923
    [failing_size] =&gt; 5
    [num_tests] =&gt; 6
    [fail] =&gt; Array
        (
            [0] =&gt; G67k}
        )

    [shrunk] =&gt; Array
        (
            [nodes_visited] =&gt; 34
            [depth] =&gt; 7
            [result] =&gt; 
            [smallest] =&gt; Array
                (
                    [0] =&gt; 0 
                )

        )

)
</code></pre>

<p>La chaîne de caractère <code>"G67k"</code> ne marche pas, et en fait la chaîne <code>"0"</code> tout cours ne marche pas.</p>

<h2>Conclusion des 3 exemples.</h2>

<ul>
<li>Je n&#8217;ai pas écris de test. C&#8217;est le logiciel qui génère les tests.</li>
<li>Les tests sont aléatoires. Par exemple si j&#8217;avais limité à 5 tests l&#8217;exemple 3 pourrait passer.</li>
<li>Si le code ne passe pas le logiciel est capable de <em>réduire</em> jusqu&#8217;à trouver un contre-exemple ici la chaine <code>"0"</code> ou l&#8217;entrée <code>([0],[0])</code></li>
<li>Un autre cas, dans le dernier exemple, j&#8217;ai pris un générateur de texte qui prend des chiffres et des lettres, si j&#8217;avais pris un générateur de lettre seulement comme <code>gen::alphaString</code>. Le test passerait sans problème.</li>
</ul>


<p>Ce type de logiciel s&#8217;appelle le <a href="https://en.wikipedia.org/wiki/QuickCheck">QuickCheck</a> du nom du premier logiciel en <a href="https://en.wikipedia.org/wiki/Haskell_%28programming_language%29">Haskell</a>. Ce sont des tests aléatoires.</p>

<p>Il existe deux portage en php.</p>

<ul>
<li><a href="https://github.com/giorgiosironi/eris">eris</a></li>
<li><a href="https://github.com/steos/php-quickcheck">php-quickcheck</a></li>
</ul>


<p>Il y a le même problème que les tests unitaires: Quand les tests unitaires ne passent pas,  il y a un problème. Mais des tests unitaires qui passent ne prouve pas forcement que le logiciel est correct. Néanmoins cette méthode qui génère des milliers de tests donne des résultats assez intéressants. La capacité a trouvé automatiquement un contre-exemple (s&#8217;il y a un contre-exemple) est vraiment un plus.</p>

<p>Cela n&#8217;a pas été évident d&#8217;écrire ce post. J&#8217;ai eu un peu de mal à trouver un exemple pertinent. Je me suis inspiré des exemples de <a href="https://github.com/DRMacIver/hypothesis">hypothesis</a>. L&#8217;implémentation du RLE viens de <a href="http://rosettacode.org/wiki/Run-length_encoding">rosetta</a> mais l&#8217;exemple en php est obsolète (la regex <code>/../e</code> php5.5 n&#8217;en veux pas). J&#8217;ai retraduis le code.</p>
]]></content>
  </entry>
  
</feed>
