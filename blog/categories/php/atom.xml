<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Php | Mon blog perso.]]></title>
  <link href="http://mcamuzat.github.io/blog/categories/php/atom.xml" rel="self"/>
  <link href="http://mcamuzat.github.io/"/>
  <updated>2015-09-13T21:47:34+02:00</updated>
  <id>http://mcamuzat.github.io/</id>
  <author>
    <name><![CDATA[mcamuzat]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Yield PHP Co-routine]]></title>
    <link href="http://mcamuzat.github.io/blog/2015/09/13/yield-php-co-routine/"/>
    <updated>2015-09-13T20:31:37+02:00</updated>
    <id>http://mcamuzat.github.io/blog/2015/09/13/yield-php-co-routine</id>
    <content type="html"><![CDATA[<p>Nous allons continuer sur le <em>yield</em> <a href="/blog/2015/09/06/php-yield-les-generateurs/">partie1</a></p>

<p>Nous avons vu la fonction xrange qui permet de générer un million de valeurs pour un coup très faible en mémoire.</p>

<p>Mais il y a mieux ! On peux envoyer des valeurs dans le générateur
&#8220;` php
&lt;?php
function generateAnimal() {
    $input = (yield &lsquo;Panda&rsquo;);
    var_dump(&ldquo;j&#8217;ai reçu $input&rdquo;);
    $input = (yield &lsquo;Lama&rsquo;);
    var_dump(&ldquo;j&#8217;ai reçu $input&rdquo;);
}</p>

<p>$gen = generateAnimal();
var_dump($gen->current());// string(5) &ldquo;Panda&rdquo;
var_dump($gen->send(&lsquo;Canard&rsquo;));//string(16) &ldquo;j&#8217;ai recu Canard&rdquo;
                               //string(4) &ldquo;Lama&rdquo;
var_dump($gen->send(&lsquo;Poney&rsquo;)); // j&#8217;ai recus Poney.
&#8220;`</p>

<p>Si j&#8217;avais fais deux fois <code>-&gt;next()</code>  au lieux de <code>-&gt;send()</code></p>

<pre><code class="php">$gen = generateAnimal();
var_dump($gen-&gt;current());// string(5) "Panda"
var_dump($gen-&gt;next());//string(16) "j'ai recu NULL"
                               //string(4) "Lama"
var_dump($gen-&gt;next()); // j'ai recus NULL.
</code></pre>

<h2>Les Co-routines</h2>

<p>Une co-routine est une fonction qui peut se suspendre en reprendre quand on le souhaite.</p>

<p>Nous allons faire une classe <code>Task</code>  pour mieux comprendre.</p>

<pre><code class="php">class Task
{
    protected $generator;

    protected $firstCall = true;

    public function __construct(Generator $generator)
    {
        $this-&gt;generator = $generator;
    }

    public function run()
    {
        if ($this-&gt;firstCall) {
            $this-&gt;generator-&gt;current();
        } else {
            $this-&gt;generator-&gt;next();
        }

        $this-&gt;firstCall = false;
    }

    public function finished()
    {
        return !$this-&gt;generator-&gt;valid();
    }
}
</code></pre>

<p>J&#8217;ai besoin d&#8217;un Runner</p>

<pre><code class="php">
class Runner
{
    public function __construct(Task $task)
    {
        $this-&gt;task = $task;
    }

    public function run()
    {
        while (!$this-&gt;task-&gt;finished()) {
            $this-&gt;task-&gt;run();
        }
    }
}
</code></pre>

<p>Un petit code d&#8217;exemple</p>

<pre><code>function task1() {
    for ($i = 1; $i &lt;= 10; ++$i) {
        echo "This is task 1 iteration $i.\n";
        yield;
    }
}

$task = new Task(task1());
$runner = new Runner($task);
$runner-&gt;run();
</code></pre>

<p>Cela donne</p>

<pre><code>This is task 1 iteration 1.
This is task 1 iteration 2.
This is task 1 iteration 3.
This is task 1 iteration 4.
This is task 1 iteration 5.
This is task 1 iteration 6.
This is task 1 iteration 7.
This is task 1 iteration 8.
This is task 1 iteration 9.
This is task 1 iteration 10.
</code></pre>

<p>J&#8217;ai un objet Task qui appelle une fonction et qui rend la main à chaque itération. Cela semble compliqué pour une seule tache. Mais modifions le code pour avoir plusieurs taches.</p>

<pre><code>class Scheduler
{
    protected $queue;

    public function __construct()
    {
        $this-&gt;queue = new SplQueue();
    }

    public function enqueue(Task $task)
    {
        $this-&gt;queue-&gt;enqueue($task);
    }

    public function run()
    {
        while (!$this-&gt;queue-&gt;isEmpty()) {
            $task = $this-&gt;queue-&gt;dequeue();
            $task-&gt;run();

            if (!$task-&gt;finished()) {
                $this-&gt;enqueue($task);
            }
        }
    }
}
</code></pre>

<p>Bon toute la magie est faite grâce à la <code>SplQueue</code> qui est une file d&#8217;attente. J&#8217;ajoute dans la file d&#8217;attente toutes les taches.</p>

<p>Je prend une tache de la file d&#8217;attente. Je l&#8217;exécute avec <code>-&gt;run()</code>, si la tache n&#8217;est pas finie, je la remets dans la file d&#8217;attente.</p>

<p>Reprenons un code d&#8217;exemple</p>

<pre><code class="php">function task1() {
    for ($i = 1; $i &lt;= 10; ++$i) {
        echo "This is task 1 iteration $i.\n";
        yield;
    }
}

function task2() {
    for ($i = 1; $i &lt;= 5; ++$i) {
        echo "This is task 2 iteration $i.\n";
        yield;
    }
}

$task1 =  new Task(task1());
$task2 = new Task(task2());
$scheduler = new Scheduler();
$scheduler-&gt;enqueue($task1);
$scheduler-&gt;enqueue($task2);
$scheduler-&gt;run();
</code></pre>

<p>Le résultat.</p>

<pre><code>This is task 1 iteration 1.
This is task 2 iteration 1.
This is task 1 iteration 2.
This is task 2 iteration 2.
This is task 1 iteration 3.
This is task 2 iteration 3.
This is task 1 iteration 4.
This is task 2 iteration 4.
This is task 1 iteration 5.
This is task 2 iteration 5.
This is task 1 iteration 6.
This is task 1 iteration 7.
This is task 1 iteration 8.
This is task 1 iteration 9.
This is task 1 iteration 10.
</code></pre>

<p>On voit que j&#8217;exécute en parallèle toutes mes deux taches.</p>

<h2>En conclusion</h2>

<p>Il existe deux librairies qui utilise ce concept</p>

<ul>
<li><a href="https://github.com/icicleio/icicle">Icicle</a></li>
<li><a href="https://github.com/recoilphp/recoil">recoil</a></li>
</ul>


<p>Cette façon d&#8217;implémenter est assez curieuse. Car le code ne ressemble pas au code classique asynchrone avec des callbacks et autre événements. Si on regarde bien cela ressemble beaucoup a du code synchrone. Elle est inspirée du <code>C#</code> <code>async/wait</code>. On a l&#8217;impression que cela ressemble a du code synchrone où on ajoute des <code>yield</code> un peu partout. (en simplifiant beaucoup..)</p>

<p>Il y a peu de documentation et d&#8217;exemple sur le sujet.</p>

<ul>
<li>la référence est ce post de <a href="http://nikic.github.io">Nikic</a>: <a href="https://nikic.github.io/2012/12/22/Cooperative-multitasking-using-coroutines-in-PHP.html">Cooperative multitasking using coroutines (in PHP!)</a></li>
<li>Une version légèrement simplifié dont je me suis inspiré pour le code <a href="https://medium.com/@assertchris/co-operative-php-multitasking-ce4ef52858a0">Co-operative PHP Multitasking</a></li>
</ul>


<p>Je vais essayer de continuer avec le yield et repartir sur les promises.</p>

<p>Merci de m&#8217;avoir lu.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Problème Np-Complet]]></title>
    <link href="http://mcamuzat.github.io/blog/2015/09/09/probleme-np-complet/"/>
    <updated>2015-09-09T21:55:10+02:00</updated>
    <id>http://mcamuzat.github.io/blog/2015/09/09/probleme-np-complet</id>
    <content type="html"><![CDATA[<p>Aujourd&#8217;hui je vais parler des problèmes Np-complets avec le <a href="http://xkcd.com/">xkcd</a> suivant. L&#8217;original est <a href="http://xkcd.com/287/">ici</a></p>

<p>{% img center /images/np_complete.png 600 388 &lsquo;xkcd&rsquo; &lsquo;xkcd&rsquo; %}</p>

<p>On appelle ce genre de problème les NP-complets</p>

<p>Pour faire simple (Ce que j&#8217;en ai compris)</p>

<p>Les NP-problèmes sont des problèmes donc il est très facile de vérifier une solutions. Dans notre cas ici il suffit de commander 7 * 2.15 pour obtenir 15.05. Le problème a une solution. Mais il est quasiment impossible de trouver une méthode efficace pour déterminer la solution, voir même de savoir s&#8217;il y a une solutions.</p>

<p>Il suffit de regarder les images suivantes (pris d&#8217;un post de <a href="http://cstheory.stackexchange.com/questions/5188/explain-p-np-problem-to-10-year-old">stack exchange</a>)</p>

<ul>
<li>si on met les paquets les plus gros d&#8217;abord, les plus larges, avec un <a href="http://www.optaplanner.org/">planner</a>.</li>
</ul>


<p>{% img center /images/backpack.png 600 450 &lsquo;bin packing&rsquo; &lsquo;slide1&rsquo; %}</p>

<ul>
<li><p>A quel moment mettre le paquet <code>2 * 4 = 8</code>. suivant la forme la solution varie
{% img center /images/backpack2.png 600 450 &lsquo;bin packing&rsquo; &lsquo;slide2&rsquo; %}</p></li>
<li><p>Enfin impossible de savoir s&#8217;il y a une solution ici. Il y a priori la place, pourtant il n&#8217;y a pas de solution</p></li>
</ul>


<p>{% img center /images/backpack3.png 600 450 &lsquo;bin packing&rsquo; &lsquo;slide3&rsquo; %}</p>

<p>la source des images <a href="http://cstheory.stackexchange.com/posts/5206/revisions">ici</a>.</p>

<p>Il reste la force brute.</p>

<p>Voici ma version du xkcd en php</p>

<pre><code class="php">function findSolution($total, $list, $menu) {
    foreach($menu as $plat =&gt; $prix) {
        $result = array_merge($list, array($plat));
        if ($total-$prix == 0) {
            var_dump($result);
            return;
        }
        if ($total-$prix &gt; 0) {
            $result = findSolution($total-$prix, $result, $menu);
        }
    }
}
$menu = array(
    "Mixed Fruit"=&gt;215,
    "French Fries"=&gt;275,
    "Side Salad"=&gt;335,
    "Hot Wing"=&gt;355,
    "Mozzarela Sticks"=&gt;420,
    "Sampler Plate"=&gt;580,
);
findSolution(1505, array(), $menu);
</code></pre>

<p>Cela affiche toute les solutions possibles.</p>

<p>Bien sur il y a des doublons. Il n&#8217;y a pas de différence entre <code>["Hot wing", "Hot wing", "Mixed Fruit", "Sampler Plate"]</code> et  <code>["Hot wing", "Hot wing", "Sampler Plate", "Mixed Fruit"]</code></p>

<p>Pour supprimer les doublons à l&#8217;affichage. Je vais utiliser des globales.</p>

<pre><code>$count = 0;
$allResult = array();
function findSolution($total, $list, $menu) {
    global $count;
    global $allResult;
    foreach($menu as $plat =&gt; $prix) {
        $count++;
        $result = array_merge($list, array($plat));

        if ($total-$prix == 0) {
            $sort = $result;
            sort($sort);
            $allResult[] = $sort;
            return $result;
        }
        if ($total-$prix &gt; 0) {
            $result = findSolution($total-$prix,$result, $menu);

        }
    }
}
$menu = array(
    "Mixed Fruit"=&gt;215,
    "French Fries"=&gt;275,
    "Side Salad"=&gt;335,
    "Hot Wing"=&gt;355,
    "Mozzarela Sticks"=&gt;420,
    "Sampler Plate"=&gt;580
);
$solution = findSolution(1505, array(), $menu);

$result = array_map(
    "unserialize",
    array_unique(
        array_map("serialize", $allResult
    )
)
);
var_dump($result);
var_dump($count);
</code></pre>

<ul>
<li>je trie le tableau de résultats. pour que tout mes doublons s&#8217;affiche pareil.</li>
<li><code>array_unique</code> ne marche pas si les valeurs sont des <em>tableaux</em> (ce qui est la cas ici)</li>
<li>Je transforme mes tableaux en chaine de caractères grâce à la serialization avec le <code>array_map</code></li>
<li>Alors <code>array_unique</code> vire les doublons</li>
<li>Je deserialize avec à nouveau <code>array_map</code> et l&#8217;opération inverse.</li>
</ul>


<pre><code class="php">array([resultat1], [resultat1],[resultat2])
// array_map("serialize", $result);
array("resultat1_serialisé","resultat1_serialisé","resultat2_serialisé");
// array_unique(..)
array("resultat1_serialise", "resultat2_serialise");
// array_map("unserialize", ..)
array([resultat1], [resultat2])
</code></pre>

<pre><code class="php">int(12040)
array(2) {
  [0] =&gt;
  array(7) {
    [0] =&gt;
    string(11) "Mixed Fruit"
    [1] =&gt;
    string(11) "Mixed Fruit"
    [2] =&gt;
    string(11) "Mixed Fruit"
    [3] =&gt;
    string(11) "Mixed Fruit"
    [4] =&gt;
    string(11) "Mixed Fruit"
    [5] =&gt;
    string(11) "Mixed Fruit"
    [6] =&gt;
    string(11) "Mixed Fruit"
  }
  [1] =&gt;
  array(4) {
    [0] =&gt;
    string(8) "Hot Wing"
    [1] =&gt;
    string(8) "Hot Wing"
    [2] =&gt;
    string(11) "Mixed Fruit"
    [3] =&gt;
    string(13) "Sampler Plate"
  }
}
</code></pre>

<p>J&#8217;ai fait 12040 boucles pour obtenir toutes les solutions. On peut bien sur optimiser un peu l&#8217;algorithme, si la valeur 5.60 ne marche pas à la première boucle, il y a pas de chance pour quelle marche à la seconde boucle. Donc il faut supprimer des valeurs dans le tableau au fur et à mesure.</p>

<h2> Conclusion</h2>

<p>La force brute n&#8217;est pas vraiment une solution, avec plus de valeurs on explose les possibilités.  Il existe plusieurs <a href="https://fr.wikipedia.org/wiki/Probl%C3%A8me_du_sac_%C3%A0_dos">approches</a> qui tende vers des solutions.</p>

<p>En informatique, il y a des nombreux cas où ce problème intervient</p>

<ul>
<li>L&#8217;ordre optimal d&#8217;installation des logiciels (Probablement la partie la plus marrante de <a href="https://getcomposer.org/">composer</a>, mais elle est assez peu documentée)</li>
<li>Beaucoup de cryptages utilisent des problèmes NP-complets (factorisation de deux nombres premiers).</li>
<li>La dernière phrase du comics parle du <a href="https://fr.wikipedia.org/wiki/Probl%C3%A8me_du_voyageur_de_commerce">voyageur de commerce</a>, un problème célèbre.</li>
<li>Le sudoku, Les jeux <a href="http://arxiv.org/pdf/1203.1895v1.pdf">nintendos</a> ?!</li>
<li>Enfin une <a href="https://fr.wikipedia.org/wiki/Liste_de_probl%C3%A8mes_NP-complets">liste complète</a> de wikipedia</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PHP Yield Les Générateurs]]></title>
    <link href="http://mcamuzat.github.io/blog/2015/09/06/php-yield-les-generateurs/"/>
    <updated>2015-09-06T19:06:48+02:00</updated>
    <id>http://mcamuzat.github.io/blog/2015/09/06/php-yield-les-generateurs</id>
    <content type="html"><![CDATA[<p>Nous allons voir une nouveauté de PHP 5.5 l&#8217;instruction <strong>yield</strong></p>

<p>Cela permet de mettre en place ce qu&#8217;on appelle les générateurs.</p>

<h2>Un premier exemple</h2>

<p>Regardons un exemple ensemble</p>

<pre><code class="php">&lt;?php
function generateAnimal() {
    echo "Je suis dans le générateur\n";
    yield "Panda";
    echo "Je suis retourné dans le générateur\n";
    yield "Lama";
    echo "je suis de retour\n";
    yield "Alpaga";
    echo "plus de d'animaux\n";
}

$generator = generateAnimal();
foreach ($generator as $value) {
    echo "j'ai reçu $value \n";
}
</code></pre>

<p>Voici le résultat</p>

<pre><code>j'ai reçu Panda 
Je suis retourné dans le générateur
j'ai reçu Lama 
je suis de retour
j'ai reçu Alpaga 
plus de d'animaux
</code></pre>

<p>D&#8217;abord un générateur se comporte comme un iterator. C&#8217;est grâce à cela que je peux faire un <code>foreach</code>.</p>

<p>Je vais refaire pas à pas avec des commentaires.</p>

<h3>premier passage</h3>

<pre><code class="php">&lt;?php
function generateAnimal() {
    echo "Je suis dans le générateur\n";
    yield "Panda"; // Je retourne ici 
        echo "Je suis retourné dans le générateur\n";
    yield "Lama";
        echo "je suis de retour\n";
    yield "Alpaga";
    echo "plus de d'animaux\n";
}


$generator = generateAnimal();

echo $generator-&gt;current();
// "je suis dans le générateur
// $value = "Panda"
</code></pre>

<h3>Itération suivante</h3>

<p>En fait le générateur reste en suspens, <code>yield</code> est un pseudo <code>return</code> (enfin c&#8217;est comme cela que je l&#8217;ai compris)</p>

<pre><code class="php">&lt;?php
function generateAnimal() {
    echo "Je suis dans le générateur\n";
    yield "Panda"; // Je suis reste ici .. je continue 
    echo "Je suis retourné dans le générateur\n";
    yield "Lama"; // je m'arrete à nouveau 
    echo "je suis de retour\n";
    yield "Alpaga";
    echo "plus d'animaux\n";
}


$generator-&gt;next() // On récupère la valeur suivante
echo $generator-&gt;current();
// "je suis retourné dans le générateur
// "Lama"
</code></pre>

<h3>Troisième itération</h3>

<pre><code class="php">&lt;?php
function generateAnimal() {
    echo "Je suis dans le générateur\n";
    yield "Panda";
    echo "Je suis retourné dans le générateur\n";
    yield "Lama"; // je me suis arrété ici 
    echo "je suis de retour\n";
    yield "Alpaga"; // je retourne .. 
    echo "plus d'animaux\n";
}


$generator-&gt;next() // On récupère la valeur suivante
echo $generator-&gt;current();
// Je suis de retour
// "Alpaga"
</code></pre>

<h3>Dernière Itération</h3>

<p>Nous y sommes presque..</p>

<pre><code class="php">&lt;?php
function generateAnimal() {
    echo "Je suis dans le générateur\n";
    yield "Panda";
    echo "Je suis retourné dans le générateur\n";
    yield "Lama";  
    echo "je suis de retour\n";
    yield "Alpaga"; // je me suis arréte ici
    echo "plus d'animaux\n"; //pas de yield je renvoie null..
}

$generator-&gt;next() // On récupère la valeur suivante
echo $generator-&gt;current();
// Plus d'animaux 
// il n'y a rien car echo null;
</code></pre>

<p>Une fois qu&#8217;un générateur a fini, on ne peux le réutiliser</p>

<pre><code class="php">foreach ($generator as $value) {
    echo "j'ai reçu $value \n";
}

foreach ($generator as $value) {
    echo "j'ai reçu $value \n";
}
</code></pre>

<p>J&#8217;obtiens</p>

<pre><code class="">PHP Fatal error:  Uncaught exception 'Exception' with message 'Cannot traverse an already closed generator' in /home/marc/yield.php:16
</code></pre>

<h2>Quel est l&#8217;intérêt ?</h2>

<p>Admettons que je veux faire un <code>foreach</code> sur un tableau d&#8217;un millions de lignes.</p>

<p>Pour faire un Array de 1 Million de valeurs ce n&#8217;est pas très compliqué. Une instruction suffit.</p>

<pre><code class="php">range(1000000) = [1,2,3,4,...,1000000];
</code></pre>

<p>Mais cela prend un peu de mémoire. Utilisons notre générateur de manière sympathique</p>

<pre><code class="php">function xrange($min, $max) {
  for ($i = $min; $i &lt; $max; $i++) yield $i;
}

foreach (xrange(1,1000000) as $value) {
   echo $value;
}
</code></pre>

<p>l&#8217;énorme avantage est que je n&#8217;ai pas besoin de générer un array de 1 Millions de lignes, je génère valeur par valeur. Si la fonction est appelle deux fois je ne génère que deux valeurs. L&#8217;occupation en mémoire est faible. Les valeurs sont instanciées <em>paresseusements</em>.</p>

<h3>Un exemple encore plus concret.</h3>

<p>Pour lire un fichier:</p>

<pre><code class="php ">function getLinesFromFile($fileName) {
    $fileHandle = fopen($fileName, 'r');
    while (false !== $line = fgets($fileHandle)) {
        yield $line;
    }
    fclose($fileHandle);
}
$lines = getLinesFromFile($fileName);
foreach ($lines as $line) {
    // do something with $line
}
</code></pre>

<p>Ce code a plusieurs avantages.</p>

<ul>
<li>On va chercher la ligne à la demande.</li>
<li>Il y a une couche d&#8217;abstraction entre la lecture et le programme principale.</li>
</ul>


<h3>Un petit quizz</h3>

<p>Pouvez vous deviner la fonction suivante ?</p>

<pre><code>function mystere() {
    $last = 0;
    $current = 1;
    yield 1;
    while (true) {
        list($current, $last) = array($current + $last, $current);
        yield $current;
    }
}

$count = 0;
foreach (mystere() as $value) {
    $count++;
    echo $value . "\n";
    if ($count &gt; 10) {
        break;
        // pas cool la boucle infinie
    }
}
</code></pre>

<h2>Une mise au point</h2>

<p>Les générateurs se comportent comme des itérateurs, mais pour implémenter un <a href="http://php.net/manual/fr/class.iterator.php">iterator</a> il faut implémenter l&#8217;interface suivante.</p>

<pre><code class="php "> Iterator extends Traversable {
/* Méthodes */
abstract public mixed current ( void )
abstract public scalar key ( void )
abstract public void next ( void )
abstract public void rewind ( void )
abstract public boolean valid ( void )
}
</code></pre>

<p>Par exemple pour l&#8217;exemple du fichier (je recopie la doc de php)</p>

<pre><code class="php">class LineIterator implements Iterator {
    protected $fileHandle;

    protected $line;
    protected $i;

    public function __construct($fileName) {
        if (!$this-&gt;fileHandle = fopen($fileName, 'r')) {
            throw new RuntimeException('Impossible d\'ouvrir le fichier : "' . $fileName . '"');
        }
    }

    public function rewind() {
        fseek($this-&gt;fileHandle, 0);
        $this-&gt;line = fgets($this-&gt;fileHandle);
        $this-&gt;i = 0;
    }

    public function valid() {
        return false !== $this-&gt;line;
    }

    public function current() {
        return $this-&gt;line;
    }

    public function key() {
        return $this-&gt;i;
    }

    public function next() {
        if (false !== $this-&gt;line) {
            $this-&gt;line = fgets($this-&gt;fileHandle);
            $this-&gt;i++;
        }
    }

    public function __destruct() {
        fclose($this-&gt;fileHandle);
    }
}
</code></pre>

<p>L&#8217;implémentation en générateur.</p>

<pre><code class="php">function getLinesFromFile($fileName) {
    if (!$fileHandle = fopen($fileName, 'r')) {
        throw new RuntimeException('Impossible d\'ouvrir le fichier : "' . $fileName . '"');
    }

    while (false !== $line = fgets($fileHandle)) {
        yield $line;
    }

    fclose($fileHandle);
}
</code></pre>

<p>C&#8217;est quand même plus simple.</p>

<h2>En conclusion.</h2>

<p>Cela existe aussi dans les autres langages</p>

<p>On trouve l&#8217;instruction <code>yield</code> surtout dans python</p>

<pre><code class="python">def countdown(n):
    while n &gt; 0:
        yield n
        n -= 1

for x in countdown(10):
    print 'depart dans %s' % x
</code></pre>

<p>La référence est ce <a href="http://www.dabeaz.com/generators/">site</a> , Il existe une <a href="http://www.youtube.com/watch?v=5-qadlG7tWo">video</a> (<strong>3 heures !!!</strong>)</p>

<p>Cela existe aussi dans <a href="http://www.tutorialspoint.com/ruby/ruby_blocks.htm">ruby</a>, <a href="https://msdn.microsoft.com/fr-fr/library/9k7k7cf0.aspx">C#</a>, et dans le javascript ES6</p>

<p>C&#8217;est un peu plus qu&#8217;une nouvelle syntaxe. Cela permet de faire du code asynchrone. Car cela permet une structure de codage que l&#8217;on appelle: Les <a href="https://fr.wikipedia.org/wiki/Coroutine">Couroutines</a>. Mais plus d&#8217;info dans un prochain post .</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Les Promises Et Php via ReactPhp]]></title>
    <link href="http://mcamuzat.github.io/blog/2015/09/05/les-promises-et-php-via-react/"/>
    <updated>2015-09-05T19:10:10+02:00</updated>
    <id>http://mcamuzat.github.io/blog/2015/09/05/les-promises-et-php-via-react</id>
    <content type="html"><![CDATA[<p>Les promises sont une alternative plus puissante au Callback. Relativement peu connues au début. Elle sont maintenant en standard dans beaucoup de langage javascript ES6, python 3.2, java. Où via des librairies comme <a href="https://github.com/reactphp/promise">react/promise</a> pour php</p>

<p>Une promise représente une valeur donc le résultat n&#8217;est pas encore connu.
Quand le résultat est connu,  la promise a 3 états possibles</p>

<ul>
<li><strong>Pending</strong> ou <strong>Unfulfillled</strong>  en Attente..</li>
<li><strong>Resolved</strong> ou <strong>fulfillled</strong>  Succès</li>
<li><strong>Rejected</strong> ou <strong>Failed</strong>  Erreur.</li>
</ul>


<p>Un <em>Deffered</em> représente un travail qui n&#8217;est pas encore fini. Donc un <em>Deferred</em> possède une promise (une valeur pas encore connues).</p>

<p>Quand la valeur est connue, la promesse utilise un <em>handler</em> (en général <code>-&gt;then()</code>) qui lui-même renvoie une promise. L&#8217;intérêt est que les promises sont chainables.</p>

<p>Mais essayons quelques exemples qui seront un peu plus parlant.</p>

<p>Pour ce faire nous allons d&#8217;abord installer <a href="https://github.com/reactphp/promise">react/promises</a></p>

<pre><code class="php">&lt;?php
require __DIR__.'/vendor/autoload.php';

// On crée un travail
$deferred = new React\Promise\Deferred();

// On veux la promise
$promise  = $deferred-&gt;promise()-&gt;then(
    function () { echo "tout va bien \n"; },
    function () { echo "tout va mal \n"; },
    function () { echo "j'attends\n "; }
);


// Le travail est un succes, on résoud la promise
$deferred-&gt;resolve(); 
</code></pre>

<p>Voici ce que j&#8217;obtiens si je lance le programme.</p>

<pre><code class="php">tout va bien
</code></pre>

<p>Si je remplace <code>$deferred-&gt;resolve()</code> par <code>$deferred-&gt;reject()</code>. Le travail n&#8217;as pas marché. J&#8217;obtiens</p>

<pre><code class="php">Tout va mal
</code></pre>

<p>La syntaxe de <code>then</code> est</p>

<pre><code class="php">then(callable $onFulfilled = null, callable $onRejected = null, callable $onProgress = null)
</code></pre>

<ul>
<li>Si l&#8217;action est un succès, On résous la promise en appelant la fonction <code>$onFulfilled</code>.</li>
<li>L&#8217;action n&#8217;est pas bonne, On rejette la promise avec <code>$onRejected</code>.</li>
<li>Si l&#8217;action est en cours , On appelle <code>$onProgress</code>.</li>
</ul>


<p>A noter qu&#8217;une promise une fois qu&#8217;elle est résolue ou rejetée ne peut plus être réutilisée sauf dans le cas du <code>pending</code></p>

<pre><code class="php">$promise-&gt;notify();
$promise-&gt;notify();
$promise-&gt;notify();
$promise-&gt;resolve();
</code></pre>

<p>Le résultat</p>

<pre><code class="">j'attends
j'attends
j'attends
tout va bien
</code></pre>

<p>Pour l&#8217;instant rien de bien compliqué. On peut chainer les promises</p>

<pre><code class="php ">$promise  = $deferred-&gt;promise()-&gt;then(
    function () { echo "action 1 ok\n"; }
)-&gt;then(
    function () { echo "action 2 ok\n";}
)-&gt;then(
   function () { echo "action 3 ok\n";},
   function () { echo "une des actions n'est pas ok..\n";}
);

$deferred-&gt;resolve();
</code></pre>

<p>Le résultat
<code>
action 1 ok
action 2 ok
action 3 ok
</code></p>

<p>Essayons avec <code>deffered-&gt;reject()</code></p>

<p>Le résultat</p>

<pre><code>une des actions n'est pas ok..
</code></pre>

<p>Ajoutons un exception à la deuxième étape.
&#8220;` php
$promise  = $deferred->promise()->then(
    function () { echo &ldquo;action 1 ok\n&rdquo;; }
)->then(
    function () { throw new Exception();}
)->then(
   function () { echo &ldquo;action 3 ok\n&rdquo;;},
   function () { echo &ldquo;une des actions n&#8217;est pas ok..\n&rdquo;;}
);</p>

<pre><code>
Le résultat
</code></pre>

<p>action 1 ok
une des actions n&#8217;est pas ok..
&#8220;`</p>

<p>Ajoutons une exception dans le premier, et ajoutons un cas pour gérer l&#8217;erreur
&#8220;` php
$promise  = $deferred->promise()->then(
    function () { throw new \Exception(); }
)->then(
    function () { echo &ldquo;action 2 ok\n&rdquo;;},
    function () { echo &ldquo;l&#8217;action 1 pas ok mais on continue..\n&rdquo;;}
)->then(
   function () { echo &ldquo;action 3 ok\n&rdquo;;},
   function () { echo &ldquo;une des actions n&#8217;est pas ok..\n&rdquo;;}
);</p>

<p>$deferred->resolve();
&#8220;`</p>

<p>Le résultat
<code>
l'action 1 pas ok mais on continue..
action 3 ok
</code></p>

<p>Si on veux que l&#8217;erreur de l&#8217;action 1 se propage deux possibilités..</p>

<ul>
<li>supprimer le callback d&#8217;erreur de l&#8217;action 2</li>
<li>Ou relancer l&#8217;exception</li>
</ul>


<pre><code>$promise  = $deferred-&gt;promise()-&gt;then(
    function () { throw new \Exception(); }
)-&gt;then(
    function () { echo "action 2 ok\n";},
    function () { echo "l'action 1 pas ok et on stop le processus"; throw new \Exception();}
)-&gt;then(
   function () { echo "action 3 ok\n";},
   function () { echo "une des actions n'est pas ok..\n";}
);
</code></pre>

<p>Ce qui est intéressant dans les promises c&#8217;est que le code équivalent en procédural est pas génial.
<code>
 $result = doAction1();
try {
    $result = doAction1();
    if ($result) {
        $result2 = doAction2($result);
        if ($result2) {
            $result3 = doAction3($result3);
            return $result3;
        } else {
            throw new Exception();
        }
    } else {
        throw New Exception();
    }
} catch (..){
    echo "une des actions n'est pas ok"
}
</code></p>

<p>Devient
<code>
    $result = $doAction1()
        -&gt;then(function($result1){doAction2($result1);})
        -&gt;then(
            function($result2){doAction3($result2);},
            function() {echo "une des actions n'est pas ok"}
        );
</code></p>

<p>C&#8217;est mieux non ?</p>

<p>Dans un prochain article nous nous utiliserons ce que nous avons appris avec <a href="http://guzzle.readthedocs.org/en/latest/">Guzzle</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Lancer Des Commandes Dans Vim]]></title>
    <link href="http://mcamuzat.github.io/blog/2015/08/31/lancer-des-commandes-dans-vim/"/>
    <updated>2015-08-31T23:49:17+02:00</updated>
    <id>http://mcamuzat.github.io/blog/2015/08/31/lancer-des-commandes-dans-vim</id>
    <content type="html"><![CDATA[<p>Soit le fichier texte suivant:</p>

<pre><code class=""> * Alpha
 * Foxtrot
 * Charlie
 * Delta
 * Echo 
 * Bravo
</code></pre>

<p>Dans VIM il suffit de taper.</p>

<pre><code class="">:%sort ou :%!sort
</code></pre>

<p>Pour obtenir
<code>
 * Alpha
 * Bravo
 * Charlie
 * Delta
 * Echo
 * Foxtrot
</code></p>

<p>On peux aussi lancer plein de commandes amusantes</p>

<pre><code> * Doublon
 * Pas unique
 * Doublon
 * 
 * ...
</code></pre>

<pre><code>!sort | uniq -c | tr "[A-Z]" "[a-z]"
</code></pre>

<p>Pour ceux qui ne se rappelle plus trop les commandes de Bash</p>

<ul>
<li><code>sort</code> trie le texte</li>
<li><code>uniq -c</code> prend toute les valeurs et les comptes c&#8217;est l&#8217;équivalent d&#8217;un <code>GROUP BY</code> en SQL</li>
<li><code>tr</code> est l&#8217;abréviation de <strong>tr</strong>anspose je remplace les lettres en <code>[A-Z]</code> par leur équivalent en minuscule.</li>
</ul>


<pre><code>      1  * 
      1  * ...
      2  * doublon
      1  * pas unique
</code></pre>

<p>Si vous sélectionnez le texte avec <code>v</code> et que vous appuyer sur <code>:</code></p>

<p>Alors vous devez voir la commande suivante
<code>
:'&lt;,'&gt;
</code>
et Ajoutez la commande que vous allez appliquer à la sélection. Par exemple <code>:'&lt;,'&gt;!sort</code></p>

<p>Plus rigolo. On peux appeler des langages que l&#8217;on veut dans VIM</p>

<pre><code class="php">&lt;?php echo "bonjour";
</code></pre>

<p>Tapez <code>!!</code>
vous devriez voir apparaître
<code>
:.!
</code>
Compléter avec <code>:.!php</code></p>

<p>votre texte va se remplacer
<code>
bonjour
</code></p>

<p>Cela marche aussi avec python</p>

<pre><code class="python">print "olleh"[::-1]
</code></pre>

<p>Avec le curseur sur la ligne, appuyer sur <code>!!</code> puis ajoutez <code>:.!python</code></p>

<p>La ligne devient</p>

<pre><code class="">hello
</code></pre>

<h2>Exécuter une commande Bash depuis VIM</h2>

<p>La commande suivante</p>

<pre><code>php app/console cache:clear --env=prod
</code></pre>

<p>Si vous voulez exécuter la commande mais ne pas modifiez la ligne.</p>

<pre><code>:.w !bash
</code></pre>

<p>C&#8217;est un peu moins simple.</p>

<ul>
<li><code>:.</code> représente la ligne actuelle.</li>
<li><code>w</code> représente une écriture</li>
<li><code>!bash</code> via Bash.</li>
</ul>


<p>La documentation de VIM <code>:help :w_c</code></p>

<h2>en résumé</h2>

<ul>
<li>Si vous voulez appliquer votre commande sur tout le fichier <code>:%!commande</code></li>
<li>S vous voulez juste la ligne <code>:.!commande</code> ou tapez <code>!!</code>.</li>
<li>Si vous voulez sur une sélection <code>v</code> ou <code>V</code> puis <code>:</code> vous deviez voir ceci <code>:'&lt;,'&gt;</code>, ajoutez la commande souhaitée.</li>
</ul>

]]></content>
  </entry>
  
</feed>
