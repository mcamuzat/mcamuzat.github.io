<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Design-pattern | Mon blog perso.]]></title>
  <link href="http://mcamuzat.github.io/blog/categories/design-pattern/atom.xml" rel="self"/>
  <link href="http://mcamuzat.github.io/"/>
  <updated>2015-08-15T23:07:17+02:00</updated>
  <id>http://mcamuzat.github.io/</id>
  <author>
    <name><![CDATA[mcamuzat]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Suite Visiteur Pattern : Visiteur Booleen]]></title>
    <link href="http://mcamuzat.github.io/blog/2015/04/06/suite-visiteur-pattern-visiteur-bool%C3%A9en/"/>
    <updated>2015-04-06T19:55:44+02:00</updated>
    <id>http://mcamuzat.github.io/blog/2015/04/06/suite-visiteur-pattern-visiteur-booléen</id>
    <content type="html"><![CDATA[<h2>Introduction:</h2>

<p>Nous allons refaire la même chose que notre interpréteur d&#8217;expressions.
Mais avec des expressions booléennes.
Par exemple
<code>php
$expression = new Or( new And(New False(), New True()), new False);
</code>
Nous allons ensuite rajouter les comparaisons <code>==</code>, <code>&lt;</code>, etc ..
<code>php
$expression = new Not(new NotEqual(new Constant(5), new Variable('i')));
</code></p>

<p>Beaucoup de code. mais si vous avez compris la première partie. cela devrait aller.</p>

<h2>Expression Booléenne</h2>

<p>Nous définissons l&#8217;interface suivante.</p>

<pre><code class="php">/**
 * Une expression Booléenne
 */
interface BoolExpression
{
    public function accept(VisitorBoolExpression $v);
}
/**
 * Une classe abstraite.
 */
abstract class Unary implements BoolExpression
{
    public function accept(VisitorBoolExpression $v)
    {
        return $v-&gt;visit($this);
    }
}
</code></pre>

<p>Pour faire l&#8217;algèbre booléen j&#8217;ai besoin de <code>False</code> et de <code>True</code></p>

<p>Voici le code.</p>

<pre><code class="php">class True extends Unary {}

class False extends Unary {}
</code></pre>

<p>J&#8217;ai aussi besoin de la négation</p>

<pre><code class="php">class Not extends Unary {
    private $value;
    public function __construct(BoolExpression $expr) {
        $this-&gt;value = $expr;
    }
    public function getValue() {
        return $this-&gt;value;
    }
}
</code></pre>

<p>Je vais rajouter la condition And, Or, Nand (No-et), Nor(Non-ou)</p>

<p>Je définis une classe avec deux arguments dans le constructeur.
<code>php
class Binary extends Unary
{
    private $left;
    private $right;
    public function __construct(BoolExpression $left, BoolExpression $right) {
        $this-&gt;left = $left;
        $this-&gt;right = $right;
    }
    public function getLeft() {
        return $this-&gt;left;
    }
    public function getRight() {
        return $this-&gt;left;
    }
}
</code></p>

<p>Les classes sont alors très simples.
<code>php
// Or et And sont des mots réservés en Php.
class BinaryOr extends Binary{}
class BinaryAnd extends Binary{}
class BinaryNand extends Binary{}
class BinaryNor extends Binary{}
</code></p>

<p>J&#8217;ai un peu près tout.</p>

<p>On peut passer au Visiteur.
&#8220;` php
interface VisitorBoolExpression{
    public function visit(BoolExpression $expr);
}</p>

<p>class VisitorBoolEvaluation implements VisitorBoolExpression {
    protected $context;
    function __construct($context){
        $this->context = $context;
    }</p>

<pre><code>public function visit(BoolExpression $expr){
    $class = 'visit'.get_class($expr);
    return $this-&gt;$class($expr);
}
public function visitTrue(BoolExpression $expr)
{
    return true;
}
public function visitFalse(BoolExpression $expr)
{
    return false;
}
public function visitNot(BoolExpression $expr)
{
    return !$expr-&gt;getValue()-&gt;accept($this);
}
public function visitBinaryOr(BoolExpression $expr)
{
    return $expr-&gt;getLeft()-&gt;accept($this)||$expr-&gt;getRight()-&gt;accept($this);
}
public function visitBinaryAnd(BoolExpression $expr)
{
    return $expr-&gt;getLeft()-&gt;accept($this)&amp;&amp;$expr-&gt;getRight()-&gt;accept($this);

}
public function visitBinaryNor(BoolExpression $expr)
{
    return !($expr-&gt;getLeft()-&gt;accept($this)||$expr-&gt;getRight()-&gt;accept($this));

}
public function visitBinaryNand(BoolExpression $expr)
{
    return !($expr-&gt;getLeft()-&gt;accept($this) &amp;&amp; $expr-&gt;getRight()-&gt;accept($this));
}
</code></pre>

<p>}
&#8220;`</p>

<p>Quelques exemples.</p>

<p>On réutilise notre mémoire du billet précédent. On utilise aussi <code>var_dump</code> plutôt que <code>echo</code> car <code>echo false</code> ne renvoie rien.</p>

<pre><code class="php">$memory = new Memory();
$memory-&gt;write('i', 10);

$ve = new VisitorBoolEvaluation($memory);
// une expression
$expression =  new True();
// appelle le visiteur
var_dump($expression-&gt;accept($ve)) // affiche bool(true);
$expression =  new Not(new False());
var_dump($expression-&gt;accept($ve)) // affiche bool(true);
$expression =  new BinaryAnd(new Not(new False()), new BinaryOr(new True(), new False()));
var_dump($expression-&gt;accept($ve)) //Affiche bool(true);
</code></pre>

<p>bien sur on peux refaire un autre visiteur pour traduire en chaînes de caractères
&#8220;` php
class VisitorBoolPrint implements VisitorBoolExpression {
    protected $context;
    function __construct($context){
        $this->context = $context;
    }</p>

<pre><code>public function visit(BoolExpression $expr){
    $class = 'visit'.get_class($expr);
    return $this-&gt;$class($expr);
}
public function visitTrue(BoolExpression $expr)
{
    return "true";
}
public function visitFalse(BoolExpression $expr)
{
    return "false";
}
public function visitNot(BoolExpression $expr)
{
    return "!" . $epr-&gt;getValue()-&gt;accept($this);
}
public function visitBinaryOr(BoolExpression $expr)
{
    return "(" . $expr-&gt;getLeft()-&gt;accept($this)
    .'||' .$expr-&gt;getRight()-&gt;accept($this). ")";
}
...
...
</code></pre>

<p> }
&#8220;`
Le même exemple .</p>

<pre><code class="php">$memory = new Memory();
$memory-&gt;write('i', 10);
$ve = new VisitorBoolPrint($memory);
// une expression
$expression =  new True();
// appelle le visiteur
var_dump($expression-&gt;accept($ve)) // affiche true;
$expression =  new Not(new False());
var_dump($expression-&gt;accept($ve)) // affiche !false;
$expression =  new BinaryAnd(new Not(new False()), new BinaryOr(new True(), new False()));
var_dump($expression-&gt;accept($ve)) //Affiche (!false&amp;&amp;(true||false));
</code></pre>

<h2>Les comparaisons</h2>

<p>Nous pouvons rajouter le <code>==</code>, <code>!=</code>, <code>&gt;</code> , <code>&lt;</code> !</p>

<p>ajoutons de nouveau objet. les object prennent en entrée des expressions mais sortent des boléens.</p>

<pre><code class="php">class BinaryComparaison extends Unary
{
    private $left;
    private $right;
    public function __construct(Expression $left, Expression $right) {
        $this-&gt;left = $left;
        $this-&gt;right = $right;
    }
    public function getLeft() {
        return $this-&gt;left;
    }
    public function getRight() {
        return $this-&gt;right;
    }
}

class Equal extends BinaryComparaison{}
class NotEqual extends BinaryComparaison{}
//Greater Than Equal
class Gte extends BinaryComparaison{}
// Lesser Than Equal
class Lte extends BinaryComparaison{}
// Lesser Than
class Lt extends BinaryComparaison{}
// Greater Than
class Gt extends BinaryComparaison{}
</code></pre>

<p>Pour mon visiteur je vais utiliser mon visiteur d&#8217;expression du post précédent.</p>

<p>donc je modifie le constructeur.
&#8220;` php
    function __construct($context, $ve){
        $this->context = $context;
        $this->ve = $ve;
    }</p>

<pre><code>je ne montre que le égal, mais vous avez un peu près l'idée pour le reste. 
</code></pre>

<pre><code>public function visitEqual(BoolExpression $expr)
{
    return ($expr-&gt;getLeft()-&gt;accept($this-&gt;ve)  == $expr-&gt;getRight()-&gt;accept($this-&gt;ve));
}
</code></pre>

<pre><code>
Le visiteur booléen utilise un autre visiteur pour évaluer une expression. 

Un exemple d'utilisation
</code></pre>

<p>$memory = new Memory();
$memory->write(&lsquo;i&rsquo;, 10);
// une visiteur d&#8217;expression
$ve = new VisitorEvaluation($memory);
// un visiteur pour les expressions booléennes
$vb = new VisitorBoolEvaluation($memory, $ve);
// une expression
$expression =  new Not(new Equal( new Constant(10), new Addition(new Constant(5), new Variable(&lsquo;i&rsquo;))));
var_dump ( $expression->accept($vb) );// affiche bool(true)
&#8220;`</p>

<p>si je reprend mon autre visiteur <code>VisitorToPhp</code> avec le <code>visitorBoolPrint</code></p>

<pre><code class="php">$memory = new Memory();
$memory-&gt;write('i', 10);
$ve = new VisitorToPhp($memory);
$vb = new VisitorBoolPrint($memory, $ve);
// une expression
$expression =  new Not(new Equal( new Constant(10), new Addition(new Constant(5), new Variable('i'))));
var_dump ( $expression-&gt;accept($vb) ); //affiche  "!(10==(5+$i))"
</code></pre>

<h2>Une conclusion.</h2>

<ul>
<li>Dans le premier post : On a vu le visiteur pour évaluer/afficher des expressions.</li>
<li>dans le second post : le visiteur pour les expressions booléennes et les comparaisons. Celui-ci utilise le premier visiteur pour faire les calculs.</li>
</ul>


<p>dans un prochain post, je vais montrer un troisième visiteur <code>visitorInstruction</code> pour évaluer des instructions d&#8217;un langage très simple. Mais cela est un peu long à écrire. Il y a un peu de théorie et des figures à faire.</p>

<p>Merci de m&#8217;avoir lu.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Interpréteur Et Visiteur Pattern]]></title>
    <link href="http://mcamuzat.github.io/blog/2015/04/05/interpreteur-et-visiteur-pattern/"/>
    <updated>2015-04-05T18:16:10+02:00</updated>
    <id>http://mcamuzat.github.io/blog/2015/04/05/interpreteur-et-visiteur-pattern</id>
    <content type="html"><![CDATA[<h1>Introduction</h1>

<p>Nous allons voir ensemble sur une série trois posts</p>

<ul>
<li>le design-pattern interpréteur</li>
<li>les limitations et une solution qui va introduire le visiteur pattern</li>
</ul>


<h1>Mise en place</h1>

<p>Nous allons créer un simple calculatrice.</p>

<p>Nous définissons l&#8217;interface suivante</p>

<pre><code class="php">/**
 * Une expression arithmétique
 */
interface Expression
{
    public function interpret(Context $context = null);
}
</code></pre>

<h2>Evaluer des constantes</h2>

<p>Voici le code pour évaluer des constantes
&#8220;` php
Class Constant implements Expression
{
    private $value;
    public function __construct($value)
    {
        $this->value = $value;
    }</p>

<pre><code>public function interpret(Context $context = null) 
{
    return $this-&gt;value;
}
</code></pre>

<p>}
&#8220;`</p>

<p>Un exemple
<code>
$constante = new Constant(5);
echo $constante-&gt;interpret(); // affiche 5
</code></p>

<p>jusqu&#8217;ici rien de complexe. Si j&#8217;interprète la constante que j&#8217;ai définie à 5, j&#8217;obtiens 5.</p>

<h2>Evaluer des additions</h2>

<p>voici le code pour interpréter les additions</p>

<pre><code>Class Addition Implements Expression
{
    private $left;
    private $right;
    public function __construct(Expression $left, Expression $right) {
        $this-&gt;right = $right;
        $this-&gt;left = $left;
    }
    public function interpret(Context $context = null) {
        return $this-&gt;left-&gt;interpret($context) + $this-&gt;right-&gt;interpret($context);
    }

}
</code></pre>

<p>Un exemple
<code>
$addition = new Addition(new Constant(5), new Constant(6));
echo $constante-&gt;interpret(); // affiche 11
</code>
On utilise la <strong>récursion</strong> pour interpréter la partie droite et gauche</p>

<pre><code>$addition = new Addition(new Addition( new Constant(5), new Constant(6)), new Constante(4));
echo $constante-&gt;interpret(); // affiche 15
</code></pre>

<p>Faire la multiplication, la soustraction, la division ne sont pas plus compliquées. Il suffit de changer le signe dans la fonction interpret()</p>

<pre><code>    // muliplication 
    public function interpret(Context $context = null) {
        return $this-&gt;left-&gt;interpret($context) * $this-&gt;right-&gt;interpret($context);
    }
</code></pre>

<h2>Ajouter d&#8217;autres méthodes</h2>

<p>Ajoutons la methode Abso qui renvoie la valeur absolue, la fonction min qui renvoie le minimum
&#8220;` php
Class Abso Implements Expression
{
    public function __construct($value) {
        $this->value = $value;
    }
    public function interpret(Context $context = null) {
        return abs($this->value->interpret($context));
    }</p>

<p>}</p>

<p>Class Minimum Implements Expression
{
    public function __construct(Expression $left, Expression $right) {
        $this->right = $right;
        $this->left = $left;
    }
    public function interpret(Context $context = null) {
        return min($this->right->interpret($context),$this->left->interpret($context));
    }
}
&#8220;`</p>

<p>un exemple
<code>
$min = new Minimum(new Abso(-10), new Addition(new Constant(24), new Constant(2)));
echo $min-&gt;interpret(); // renvoie 10
</code></p>

<h2>Tout n&#8217;est qu&#8217;une question de contexte</h2>

<p>Nous allons ajouter les variables.</p>

<p>Il nous faut d&#8217;abord implémenter le Context</p>

<p>Voici la définition
&#8220;` php
/<em>*
 * Interface Context
 </em>/
interface Context
{
    // write a value in memory
    public function write($name, $value);
    // get a value from the memory
    public function read($name);
    //return all the value
    public function getAll()
}</p>

<p>/<em>*
 * A Memory
 </em>/
class Memory implements Context
{
    private $memory = array();
    // write a value in memory
    public function write($name, $value)
    {
        $this->memory[$name] = $value;
        return $this;
    }</p>

<pre><code>// get a value from the memory
public function read($name)
{
    return $this-&gt;memory[$name];
}

public function getAll()
{
    return $this-&gt;memory;
}
</code></pre>

<p>}</p>

<pre><code>
Il ne nous reste plus qu'à implémenter la variable.
</code></pre>

<p>class Variable implements Expression
{    public function __construct($name) {
        $this->name = $name;
    }
    public function interpret(Context $context = null){
        return $context->read($this->name);
    }
}</p>

<pre><code>On comprend l'intérêt du context. Il nous permet de passer un pseudo-scope..

Un exemple:
</code></pre>

<p>$memory = new Memory();
$memory->write(&lsquo;i&rsquo;, 10);
$expression = new Addition(new Constant(10), new Variable(&lsquo;i&rsquo;));
echo $expression->interpret($memory); // 20</p>

<p>$memory->write(&lsquo;i&rsquo;, 0);
echo $expression->interpret($memory); // 10
&#8220;`</p>

<p>On peux rajouter plein d&#8217;autre expression. L&#8217;avantage est qu&#8217;il suffit de rajouter une méthode <code>-&gt;interpret(..)</code> pour chaque objet.</p>

<h1>mais si on change le cahier des charges&hellip;</h1>

<p>Changeons le cahier des charges. Je souhaite transformer mon Expression en chaine de caractères. Je peux m&#8217;en sortir en surchargeant la méthode <code>__tostring</code></p>

<p>Par exemple :
<code>php
$expression = new Addition (new Addition(new Constant(3), new Constant(4)), new Constante(4));
$expression-&gt;__toString() // me donne ((3 + 4) + 4);
</code></p>

<pre><code>// pour la constante
        public function __toString() {
            return $this-&gt;value;
        }

// pour l'addition
         public function __toString() {
                // this-&gt;left-&gt;__toString()
                return '(' . $this-&gt;left . ' + ' . $this-&gt;right .')';
         }
</code></pre>

<p>Rechangeons le cahier des charges : je veux la traduction en Php</p>

<pre><code>$expression = new Addition (new Addition(new Variable('i'), new Constant(4)), new Constante(4));
$expression-&gt;__toPhp() // me donne (($i + 4) + 4);
</code></pre>

<p>je suis un peu bloqué, je dois rajouter à chaque fois une méthode dans chaque Object. Je perd un peu de la simplicité du pattern..</p>

<h2>Visiteur Pattern à la rescousse !</h2>

<p>Je vais définir une méthode <code>accept(Visitor $visitor)</code>
&#8220;` php
interface Expression{
     public function accept(VisitorExpression $v);
}</p>

<pre><code>
avec VisitorExpression définit ainsi
</code></pre>

<p>abstract class VisitorExpression{
    public abstract function visite(Expression $expr);
}
&#8220;`</p>

<p>Voici comment se transforme l&#8217;addition, la constante et la variable (je ne mets pas tout..)
&#8220;` php
Class Constant implements Expression
{
    private $value;
    public function __construct($value)
    {
        $this->value = $value;
    }
    public function getValue() {
        return $this->value;
    }
    public function accept(VisitorExpression $v)
    {
        return $v->visit($this);
    }</p>

<p>}</p>

<p>Class Addition Implements Expression
{
    public function __construct(Expression $left, Expression $right) {
        $this->right = $right;
        $this->left = $left;
    }
    public function getLeft() {
        return $this->left;
    }
    public function getRight() {
        return $this->right;
    }
    public function accept(VisitorExpression $v)
    {
        return $v->visit($this);
    }</p>

<p>}</p>

<p>class Variable implements Expression
{
    private $name;
    public function __construct($name) {
        $this->name = $name;
    }
    public function getName() {
        return $this->name;
    }
    public function accept(VisitorExpression $v)
    {
        return $v->visit($this);
    }
}</p>

<pre><code>
Voici l'implémentation de notre Visiteur
</code></pre>

<p>class VisitorEvaluation extends VisitorExpression {
    protected $context;
    function __construct($context){
        $this->context = $context;
    }</p>

<pre><code>public function visit(Expression $expr){
    $class = 'visit'.get_class($expr);
    return $this-&gt;$class($expr);
}
public function visitAddition(Expression $expr)
{
    return $expr-&gt;getLeft()-&gt;accept($this) +
        $expr-&gt;getRight()-&gt;accept($this);

}
public function visitConstant(Expression $expr)
{
    return $expr-&gt;getValue();

}
public function visitVariable(Expression $expr)
{
     return $this-&gt;context-&gt;read($expr-&gt;getName());
}
</code></pre>

<pre><code>en pratique. On appelle la méthode `accept`. Celle-ci appelle la methode `visit($this)`. la méthode visit détermine la fonction à appeller. 
Si c'est une constante alors `visistConstant()` celle-ci résout la valeur. pour une addition c'est un plus compliqué on ré-appelle récursivement `accept` sur chaque partie de l'addition.

Voici comment s'en servir
</code></pre>

<p>// j&#8217;ai besoin d&#8217;une mémoire
$memory = new Memory();
$memory->write(&lsquo;i&rsquo;, 10);
// j&#8217;ai besoin d&#8217;un visiteur
$ve = new VisitorEvaluation($memory);
// une expression
$expression = new Addition(new Constant(10), new Variable(&lsquo;i&rsquo;));
// appelle le visiteur
echo $expression->accept($ve); // 20
&#8220;`</p>

<p>On se rend compte qu&#8217;il n&#8217;y a plus de logique dans mes objet. Tout est sous-traité dans le visiteur.</p>

<p>L&#8217;avantage de cette méthode est qu&#8217;il est très simple de changer le visiteur sans changer la logique.</p>

<p>Par exemple le visiteur qui convertit en php</p>

<pre><code class="php">}
class VisitorToPhp extends VisitorEvaluation {
    public function visitAddition(Expression $expr)
    {
        return '(' .  $expr-&gt;getLeft()-&gt;accept($this) . '+'
            . $expr-&gt;getRight()-&gt;accept($this). ')';

    }
    public function visitVariable(Expression $expr)
    {
         return '$'. $expr-&gt;getName();
    }

    public function convertMemory()
    {
        $output = '';

        foreach($this-&gt;context-&gt;getAll() as $key =&gt; $value) {
            $output .= '$'.$key . ' = ' . $value . ';';
        }
        return $output;
    }

    public function getOutput()
    {
        return 'echo';
    }

    public function translate(Expression $exp) {
        return $this-&gt;convertMemory() . $this-&gt;getOutput() . $exp-&gt;accept($this);
    }
}
</code></pre>

<p>Et celui qui convertit en Javascript !
&#8220;`
class VisitorToJs extends VisitorToPhp {
    public function visitVariable(Expression $expr)
    {
         return $expr->getName();
    }</p>

<pre><code>public function convertMemory()
{
    $output = '';
    foreach($this-&gt;context-&gt;getAll() as $key =&gt; $value) {
        $output .= 'var '. $key . ' = ' . $value . ';';
    }
    return $output;
}
public function getOutput()
{
    return 'console.log';
}
</code></pre>

<p>}</p>

<pre><code></code></pre>

<p>$memory = new Memory();
$memory->write(&lsquo;i&rsquo;, 10);
$ve = new VisitorEvaluation($memory);
// une expression
$expression = new Addition(new Constant(10), new Variable(&lsquo;i&rsquo;));
// appelle le visiteur evaluation simple
echo $expression->accept($ve); // 20
// evaluation conversion php
$php = new VisitorToPhp($memory);
echo $expression->accept($php); // (10 + $i)
$js = new VisitorToJs($memory);
echo $expression->accept($js); // (10 + i)
// j&#8217;ai rajouté une méthode translate qui est un raccourci
echo $php->translate($expression); // $i = 10;echo(10+$i)
echo $js->translate($expression); // var i = 10;console.log(10+i)
&#8220;`</p>

<p>Les limitations du visiteur pattern</p>

<ul>
<li>toute la logique est sur le visiteur. s&#8217;il y a un beaucoup de type d&#8217;expression (dans notre cas Addition, Constant, Variable, Abso, Multiplication ..) c&#8217;est autant de ligne à rajouter dans celui-ci.</li>
<li>rajouter un <em>type</em>, oblige à le ré-implementer partout.</li>
</ul>


<p>Les avantages du visiteur pattern.
On peut parfaitement imaginer un type document, et lui ajouter un visiteur <code>toJson</code>, <code>toPdf</code>, <code>toEbook</code>, <code>toHtml</code>. sans jamais changer le modèle.</p>

<p>Nous continuerons avec le visiteur pattern dans un prochain post. Nous ajouterons un visiteur pour les expressions booléenes. puis nous ajouterons un visiteur pour des instructions. nous allons créer un mini-langage..</p>

<p>Ce projet vient des notes que j&#8217;avais prise quand j&#8217;étais au CNAM sur le cours de Design-Pattern en Java. J&#8217;avais adoré!</p>
]]></content>
  </entry>
  
</feed>
